<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>leetcode#153/#154. Find Minimum in Rotated Sorted Array I/II</title>
    <url>/2019-11-22-leetcode#153#154.-Find-Minimum-in-Rotated-Sorted-Array-III.html</url>
    <content><![CDATA[<h1 id="leetcode-153-154-Find-Minimum-in-Rotated-Sorted-Array-I-II"><a href="#leetcode-153-154-Find-Minimum-in-Rotated-Sorted-Array-I-II" class="headerlink" title="leetcode#153/#154. Find Minimum in Rotated Sorted Array I/II"></a>leetcode#153/#154. Find Minimum in Rotated Sorted Array I/II</h1><p>题目来源<a href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/description/" target="_blank" rel="noopener">leetcode#153</a> 和<a href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/" target="_blank" rel="noopener">leetcode#154</a> 要求在排序的旋转数组中寻找最小值。最小值可以很简单的遍历一次数组得到，时间复杂度为$O(n)$但是没有用到题目给的性质，所以会超时。</p>
<a id="more"></a>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="leetcode-153-无重复元素"><a href="#leetcode-153-无重复元素" class="headerlink" title="leetcode#153 无重复元素"></a>leetcode#153 无重复元素</h3><p>先分析leetcode#153中没有重复值的情况，采用二分查找的思路，设输入的数组长度为n表示为$A[n]$,经过观察可以发现pivot将A划分成了两个递增子数组L，R。使用指针p指向A的第一个元素A[0],指针q指向A的最后一个元素$A[n-1]$,使用指针m指向A的中间元素$A[\frac{n}{2}]$。如果中间元素位于第一个递增数组L，则有关系：$A[p]<a[m],a[m]>A[q]$,此时最小元素在m与q之间，将p移动到m，原来规模为n的问题变成规模为$q-m=\frac{n}{2}$的子问题。如果中间元素位于第二个递增数组R，则有关系：$A[p]&gt;A[m],A[m]&lt;A[q]$,此时最小元素在p与m之间，将q移动到m，原来规模为n的问题变成规模为$m-p=\frac{n}{2}$的子问题。直到最后q=p+1时，问题规模下降到2的情况，得到答案最小的元素为q指针指向的元素。可以看到每一次迭代，都会将n规模的问题下降到$\frac{n}{2}$规模。</a[m],a[m]></p>
<h3 id="leetcode-154-有重复元素"><a href="#leetcode-154-有重复元素" class="headerlink" title="leetcode#154 有重复元素"></a>leetcode#154 有重复元素</h3><p>在有重复值的情况下，会出现$A[m]==A[p]$的情况，这个时候是无法判断到底左右两边谁为递增序列。如</p>
<script type="math/tex; mode=display">
[2, 2, 2, 2, 1,1,1, 2]</script><p>这时候的$A[m]==A[3]$与$A[p]==A[0]$是相等的都是2，所以只能把两边的最小值，递归的调用求解出来。</p>
<h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><h3 id="leetcode-153-无重复元素-1"><a href="#leetcode-153-无重复元素-1" class="headerlink" title="leetcode#153 无重复元素"></a>leetcode#153 无重复元素</h3><p>可以画出递归图:</p>
<p><img src="https://res.cloudinary.com/bravey/image/upload/v1574430318/blog/coding/leetcode_153_reduction_graph.jpg" alt=""></p>
<p>用$T(n)​$表示对于一个长度为n的旋转数组进行查找最小值需要的次数，对于每一次迭代都有$T[n]=T[{\lfloor\frac{n}{2}\rfloor]+C}​$,C是一个常数。所以有</p>
<script type="math/tex; mode=display">
\begin{split}

T(n)&=T[{\lfloor\frac{n}{2}\rfloor]+C}\\

&=T[{\lfloor\frac{n}{2^2}\rfloor]+2C}\\

&=T[{\lfloor\frac{n}{2^3}\rfloor]+3C}\\

\dots\\

&=T[{\lfloor\frac{n}{2^k}\rfloor]+kC}\\

\end{split}</script><p>设在第k次迭代的时候长度下降到2，  此时有$\frac{n}{2^k}=2$解出$k=\log_2n-1$，所以有$T[n]=(\log_2n-1)C=O(\log_2n)$，所以算法的时间复杂度为$O(logn)$</p>
<h3 id="leetcode-154-有重复元素-1"><a href="#leetcode-154-有重复元素-1" class="headerlink" title="leetcode#154 有重复元素"></a>leetcode#154 有重复元素</h3><p>最坏的情况，当出现$A[m]==A[p]$的情况的时候有递推表达式：</p>
<script type="math/tex; mode=display">
\begin{split}
T(n)&=2T[{\lfloor\frac{n}{2}\rfloor]+C}\\
&=2^2T[{\lfloor\frac{n}{2^2}\rfloor]+C+2C}\\
&=2^3T[{\lfloor\frac{n}{2^3}\rfloor]+C+2C+2C}\\
\dots\\
&=2^kT[{\lfloor\frac{n}{2^k}\rfloor]+(2k-1)C}\\
\end{split}</script><p>设当第k次的时候下降到n=1，因此有$\frac{n}{2^k}=1$推出$k=\log_2n$所以有$T(n)=n+(2\log_2n-1)C=O(n)$,所以时间复杂度为O(n)。如果没有出现$A[m]==A[p]$的情况则和无重复值的情况一样，时间复杂度为$O(n)$</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>使用迭代和循环两种方式实现。 循环的时候比较的选择？mid是该和左边还是右边比呢？我自己写的是和左边的比，但是我看leetcode的题解都是和右边的比。</p>
<h3 id="leetcode-153-无重复元素-2"><a href="#leetcode-153-无重复元素-2" class="headerlink" title="leetcode#153 无重复元素"></a>leetcode#153 无重复元素</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*leetcode#153</span></span><br><span class="line"><span class="comment">https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/description/*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.size();</span><br><span class="line">        <span class="keyword">if</span>(len==<span class="number">1</span> || nums[<span class="number">0</span>]&lt;nums[len<span class="number">-1</span>]) <span class="keyword">return</span> nums[<span class="number">0</span>];<span class="comment">//长度为1的时候或者不旋转的时候直接返回</span></span><br><span class="line">        <span class="comment">// return dc_find(nums, 0, len-1);</span></span><br><span class="line">        <span class="keyword">return</span> loop_find(nums, <span class="number">0</span>, len<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">dc_find</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>((hi -lo)==<span class="number">1</span>) <span class="keyword">return</span> nums[hi];</span><br><span class="line">		<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> mid = lo + (hi -lo)/<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span>(nums[mid]&gt;nums[lo]) ans = dc_find(nums, mid, hi);</span><br><span class="line">		<span class="keyword">else</span> ans = dc_find(nums, lo, mid);</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">loop_find</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(lo&lt;hi)&#123;</span><br><span class="line">			<span class="keyword">if</span>((hi-lo)==<span class="number">1</span>) &#123;</span><br><span class="line">				ans = nums[hi];</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			mid = lo + (hi -lo)/<span class="number">2</span>;</span><br><span class="line">			<span class="keyword">if</span>(nums[mid]&gt;nums[lo]) lo = mid ;</span><br><span class="line">			<span class="keyword">else</span> hi = mid ;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/* code */</span></span><br><span class="line">	ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">	Solution Sol;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;Sol.findMin(vec)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="leetcode-154-有重复元素-2"><a href="#leetcode-154-有重复元素-2" class="headerlink" title="leetcode#154 有重复元素"></a>leetcode#154 有重复元素</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">leetcode#154</span></span><br><span class="line"><span class="comment">https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.size();</span><br><span class="line">        <span class="keyword">if</span>(len==<span class="number">1</span> || nums[<span class="number">0</span>]&lt;nums[len<span class="number">-1</span>]) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> dc_find(nums, <span class="number">0</span>, len<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">dc_find</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>((hi -lo)==<span class="number">1</span>) <span class="keyword">return</span> min(nums[lo], nums[hi]);<span class="comment">// 与无重复值的情况不同</span></span><br><span class="line">		<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> mid = lo + (hi -lo)/<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span>(nums[mid]&gt;nums[lo]) ans = dc_find(nums, mid, hi);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (nums[mid]==nums[lo])&#123;</span><br><span class="line">			ans = min(dc_find(nums, lo, mid), dc_find(nums, mid, hi));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> ans = dc_find(nums, lo, mid);</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/* code */</span></span><br><span class="line">	ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec = &#123;<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span> ,<span class="number">2</span> &#125;;</span><br><span class="line">	Solution Sol;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;Sol.findMin(vec)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是：<code>if((hi -lo)==1) return min(nums[lo], nums[hi]);</code> 递归的退出条件， 与无重复值的情况不同是可能出现只有两个值的时候最小值在左边的情况，所以需要比较最小值，而不是直接返回第二个。比如$[2,3,2]$ 的情况，划分为两个子问题$[2, 3] 与[3,2]$第一个子问题的时候最小值在第一个元素。</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>分治</tag>
        <tag>数组</tag>
        <tag>最小值</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>推荐系统</title>
    <url>/2019-11-19-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F.html</url>
    <content><![CDATA[<h1 id="推荐系统"><a href="#推荐系统" class="headerlink" title="推荐系统"></a>推荐系统</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>推荐的基本思路是根据历史数据比如用户以往的喜好或者相似用户的喜好来预测用户未来的喜好。基本假设是：（1）用户的喜好是会保持的并且随着时间而缓慢改变。（2）拥有相同品味的用户对与一个项目的打分也是相似的。因此可以根据以往的历史数据来进行推荐。</p>
<p>与搜索的不同：搜索的数据不是根据用户的资料而定制的，给出的答案是与搜素查询语句相关联的结果。</p>
<a id="more"></a>
<h2 id="推荐算法"><a href="#推荐算法" class="headerlink" title="推荐算法"></a>推荐算法</h2><h3 id="基于内容的方法"><a href="#基于内容的方法" class="headerlink" title="基于内容的方法"></a>基于内容的方法</h3><p>基于内容的方法基于这样一个事实：一个用户的兴趣应该和被推荐物品的描述想匹配。核心思路是找到用户资料与物品之间的相似度，推荐相似度高的物品。</p>
<p>步骤为：</p>
<ul>
<li>描述将被推荐的物品I</li>
<li>建立用户个人资料U来描述用户喜欢的物品</li>
<li>比较物品和用户个人资料来决定推荐的物品</li>
</ul>
<p>用户个人资料与物品的描述可以根据关键词进行向量化。使用例如TF-IDF的方法将物品与个人资料向量话后，就可以计算两者的相似度了。</p>
<h4 id="余弦相似度"><a href="#余弦相似度" class="headerlink" title="余弦相似度"></a>余弦相似度</h4><p>使用预先相似度计算这两个向量的相似度。对与两个n维向量X和Y其余弦相似度为：</p>
<script type="math/tex; mode=display">
sim(X,Y)=\dfrac{X\cdot Y}{||X||\times ||Y||}</script><p>分子是点乘，$||X||=\sqrt {x_1^2+x_2^2+\dots+x_n^2}$ 是向量的欧几里得范数，也就是向量的长度。</p>
<h3 id="协同过滤算法"><a href="#协同过滤算法" class="headerlink" title="协同过滤算法"></a>协同过滤算法</h3><p>协同过滤Collaborative Filtering有两中假设</p>
<ul>
<li>基于用户的协同过滤：假设之前对各物品打分相似的用户对于一个新的物品的打分也是相似的</li>
<li>基于物品的协同过滤：假设两个物品的用户打分是相似的，那么一个新用户对二者的打分也是相似的。</li>
</ul>
<p>算法的步骤是：</p>
<ul>
<li>对所有的用户或物品根据他们与当前的用户或物品的相似度来进行赋权。</li>
<li>选择相邻的用户或者物品的一个自己作为推荐</li>
<li>对于一个用户对一个具体的物品的打分，使用相邻的用户对该物品（或者与该物品相似物品）的打分来预测。</li>
<li>推荐拥有最高预测打分值的物品。</li>
</ul>
<p>用户/物品之间的相似度可以用余弦相似度或者皮尔森相关系数。</p>
<p><img src="https://res.cloudinary.com/bravey/image/upload/v1574157674/blog/Data%20Mining/correlation_coefficient.jpg" alt=""></p>
<p>最终的打分的预测更新为：</p>
<p><img src="https://res.cloudinary.com/bravey/image/upload/v1574157674/blog/Data%20Mining/update_rating.jpg" alt=""></p>
<p>用户u对物品i的打分有原来的该用户的平均打分$\bar r_u$与和该用户最相似的用户一起决定。</p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p><img src="https://res.cloudinary.com/bravey/image/upload/v1574157674/blog/Data%20Mining/example_1.jpg" alt=""></p>
<p>为了预测Jane对Aladdin的打分，第一步首先计算每个用户对电影的平均打分。第二步计算其他4个用户与Jane 的相似度，使用的是余弦相似度并且其他用户对Aladdin的打分不算进去，因此用的是除了Aladdin外的3部电影来计算的。计算出来选择与Jane最相似的2个用户Joe、Jorge。</p>
<p><img src="https://res.cloudinary.com/bravey/image/upload/v1574157674/blog/Data%20Mining/example_2.jpg" alt=""></p>
<p>根据前面两部计算的结果计算Jane对Aladdin的打分。</p>
<h2 id="推荐系统的评测"><a href="#推荐系统的评测" class="headerlink" title="推荐系统的评测"></a>推荐系统的评测</h2><p>主要使用精确率，召回率，F1-Score3个指标来进行评价。</p>
<p><img src="https://res.cloudinary.com/bravey/image/upload/v1574157674/blog/Data%20Mining/presicion_recall.jpg" alt=""></p>
<p>F1-Score的计算方式为：</p>
<script type="math/tex; mode=display">
F1-Score = \dfrac{2Precison\times Recall}{Precision+Recall}</script><p>精确率表示所有相关的物品中被推荐出来的比例，召回率表示所有推荐的物品中实际相关的比例，F1-Score则是二者的总体评价。</p>
]]></content>
      <categories>
        <category>数据挖掘</category>
      </categories>
      <tags>
        <tag>课程</tag>
        <tag>国科大</tag>
        <tag>余弦相似度</tag>
        <tag>推荐</tag>
      </tags>
  </entry>
  <entry>
    <title>聚类方法</title>
    <url>/2019-11-19-%E8%81%9A%E7%B1%BB%E6%96%B9%E6%B3%95.html</url>
    <content><![CDATA[<h1 id="聚类方法"><a href="#聚类方法" class="headerlink" title="聚类方法"></a>聚类方法</h1><p>聚类属于无监督学习，因为输入的数据是没有标签的，通过算法每个样本自动的划分到相应的簇中。</p>
<h2 id="K-means"><a href="#K-means" class="headerlink" title="K-means"></a>K-means</h2><p>k均值是一种基于形心的技术。给定一个包含n 个数据对象的数据库，以及要生成的簇的数目k，一个划分类的算法将数据对象组织为k 个划分（k≤n），其中每个划分代表一个簇。通常会采用一个划分准则（经常称为相似度函数，similarity function），例如距离dist(i,j)，以便在同一个簇中的对象是“相似的”，而不同簇中的对象是“相异的”。</p>
<p>K-means把簇的形心定义为簇内点的均值，通过贪心的方法不断迭代形心的坐标，直到形心的坐标不再改变而结束迭代。</p>
<a id="more"></a>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>算法的步骤为：</p>
<ul>
<li>首先在数据集D中选择k个对象，每个对象代表一个簇的初试均值即形心。</li>
<li>对剩下的对象，根据其与这个k个形心的欧式距离将其分配到距离最近的形心的簇。</li>
<li>完成了分配后重新计算每个簇的均值中心点并更新。</li>
<li>使用更新后的均值中心点，重新分配每一个对象。</li>
<li>不断迭代，直到本轮的中心点与上一轮的相同，即本轮形成的簇与上一轮相同。</li>
</ul>
<h3 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h3><p>伪代码为：</p>
<p><img src="https://res.cloudinary.com/bravey/image/upload/v1574157674/blog/Data%20Mining/kmeans_code.jpg" alt=""></p>
<p>K-means对离群点敏感，因为当一个离群点被分配到一个簇的时候，可能会严重扭曲簇的均值。</p>
<p>k中心点算法是基于对象的，通过挑选实际的对象来代表簇，其余的对象被分配与其最为相似的代表对象所在的簇。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《数据挖掘概念与技术》第3版 第十章聚类分析：基本概念和方法</p>
]]></content>
      <categories>
        <category>数据挖掘</category>
      </categories>
      <tags>
        <tag>课程</tag>
        <tag>国科大</tag>
        <tag>聚类</tag>
        <tag>K-Means</tag>
      </tags>
  </entry>
  <entry>
    <title>关联规则</title>
    <url>/2019-11-18-%E5%85%B3%E8%81%94%E8%A7%84%E5%88%99.html</url>
    <content><![CDATA[<h1 id="关联规则"><a href="#关联规则" class="headerlink" title="关联规则"></a>关联规则</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>关联规则挖掘Association rules mining 挖掘出数据库中的频繁模式，频繁项之间的关联规则。</p>
<a id="more"></a>
<p>关联规则的形式为</p>
<script type="math/tex; mode=display">
A\Rightarrow B[support=?, confident=?]</script><p>规则的支持度support和置信度confident分别反映出规则的有用性和确定性。定义为：</p>
<script type="math/tex; mode=display">
\begin{split}
support(A\Rightarrow B)&=P(A\bigcap B)=\dfrac{count(A\bigcap B)}{count(total)}\\
confident(A\Rightarrow B)&=P(B|A)=\dfrac{count(A\bigcap B)}{count(A)}
\end{split}</script><p>$A\bigcap B$ 表示A事件和B事件一起发生。使用比例的支持度称为相对支持度，使用直接的次数称为绝对支持度。当规则满足设定的最小支持度和最小置信度的时候，规则是强关联规则。强关联规则并不一定是有趣的，使用提升度lift来衡量两个事件之间的相关性</p>
<script type="math/tex; mode=display">
lift=\dfrac{P(A\bigcap B)}{P(A)P(B)}</script><p>当lift大于1的时候表示A事件和B时间是正相关的，A随着B的出现而出现，lift为1的时候二者是独立的，lift小与1的时候二者负相关，意味着一个的出现可能导致另一个不出现。</p>
<p>关联规则的挖掘分为两步：</p>
<ol>
<li>找出所有的频繁项集 一个详细的出现次数大于最小支持度的次数则是频繁的</li>
<li>由频繁项集产生强关联规则</li>
</ol>
<p>包含k个项的项集称之为k项集，如果集合中的项都是频繁的，那么集合称之为频繁k项集。</p>
<p>挖掘频繁项集的算法：Apriori和FP-Growth</p>
<h2 id="Apriori"><a href="#Apriori" class="headerlink" title="Apriori"></a>Apriori</h2><p>Apriori运用了一个先验规则：每个频繁项集的子集一定也是频繁的项集，使用这个规则来剪枝很多候选项（非频繁的子集其父集也一定不是频繁的所以可以不用考虑）。</p>
<p>算法步骤为：</p>
<ul>
<li>首先扫描一次数据库得到频繁1项集</li>
<li>根据频繁k项集$L_k$生成频繁k+1项集（连接步和剪枝步组成）<ul>
<li>先根据频繁k项集组合生成候选项</li>
<li>扫描数据库得到候选项的支持度</li>
<li>将不满足支持度的剔除</li>
</ul>
</li>
<li>当没有频繁项或者候选项可以生成的时候终止</li>
</ul>
<h3 id="连接步"><a href="#连接步" class="headerlink" title="连接步"></a>连接步</h3><p>为了找出$L_k$ ,通过$L_{k-1}$与自身连接产生候选k项集的集合$C_k$设$l_1$和$l_2$ 是$L_{k - 1}$ 中的项集。记号$l_i[j]$表示$l_i$ 的第j 项（例如，$l_1[k-2]$表示$l_1$ 的倒数第3 项）。为方便计，假定事务或项集中的项按字典次序排序即$l_i[k]&lt;l_i[k+1]$。执行连接$L_{k - 1}$ 与$L_{k - 1}$；其中，$L_{k - 1}$ 的元素是可连接的，如果它们前(k-2)个项相同；即，$L_{k - 1}$ 的元素l1 和l2 是可连接的，如果$(l_1 [1] = l_2 [1]) ∧ (l_1 [2]= l_2 [2]) ∧ … ∧ (l_1 [k-2] = l_2 [k-2]) ∧ (l_1 [k-1] &lt; l_2 [k-1])$。条件$(l_1 [k-1] &lt; l_2 [k-1])$是简单地保证不产生重复。连接$l_1$ 和$l_2$ 产生的结果项集是$l_1 [1] l_1 [2]… l_1 [k-1] l_2 [k-1]$。</p>
<p>举个例子假设频繁三项集有$l_1=[a,b,c], l_2=[a.b,d]$ 满足前缀相同最后一项不同所以可以产生候选的4项集：$C_4=[a,b,c,d]$ 把$l_2$的最后一项拼接到$l_1$后面。</p>
<h3 id="剪枝步"><a href="#剪枝步" class="headerlink" title="剪枝步"></a>剪枝步</h3><p>$C_k$是频繁k项集的$L_k$的父集，可以扫描数据库来确定每一个$C_k$中的计数。但是$C_k$可能很大，所涉及的计算量也就很大。为压缩$C_k$，可以用以下办法使用Apriori 的先验性质：任何非频繁的(k-1)-项集都不是可能是频繁k-项集的子集。因此，如果一个候选k-项集的(k-1)项子集不在$L_{k - 1}$ 中，则该候选也不可能是频繁的，从而可以由$C_k$ 中删除。这种子集测试可以使用所有频繁项集的散列树(hash tree)快速完成。</p>
<p><img src="https://res.cloudinary.com/bravey/image/upload/v1574157675/blog/Data%20Mining/Apriori_example.jpg" alt=""></p>
<p>如上图的例子，第一次扫描得到频繁1项集的候选项$C_1$，然后根据支持度去除支持度计数小于2的$\{D\}$ 得到$L_1$，然后$L_1$中的各项进行连接步操作得到$C_2$，$C_2$ 执行剪枝步操作，因为所有项的子集都在$L_1$中所以不需要剪枝。进行第二次扫描得到$C_2$各项的支持度计数，然后把低于最小支持度的$\{A,B\},\{A,E\}$ 两项删除从而得到频繁2项集$L_2$。根据$L_2$执行连接步(只能由{B,C} 和{B, E}连接，其他的前缀不同)生成的$C_3=\{B,C,E\}$ 因为对应的3个子集{B,C},｛B,E｝和{C, E}都在频繁2项集中，所以也不需要剪枝。第三次扫描后得到$C_3$中各项的支持度计数，因为大于最小支持度计数，因此不需要删去得到了频繁3项集，因为频繁3项集只有一项无法进行连接步操作生成候选项集，所以算法终止。</p>
<h3 id="产生关联规则"><a href="#产生关联规则" class="headerlink" title="产生关联规则"></a>产生关联规则</h3><p>以上图为例，得到了频繁3项集$L_3={\{B,C,E\}}$后，对其所有非空子集$\{B\},\{C\},\{E\},\{B,E\},\{B,C\},\{C,E\}$ 计算对应的关联规则$l_1 \Rightarrow l_2\space or \space l_2 \Rightarrow l_1 $的置信度，如果满足最小置信度阈值则是强关联规则。</p>
<h3 id="算法伪代码"><a href="#算法伪代码" class="headerlink" title="算法伪代码"></a>算法伪代码</h3><p><img src="https://res.cloudinary.com/bravey/image/upload/v1574157676/blog/Data%20Mining/Apriori_code.jpg" alt=""></p>
<h3 id="改进算法"><a href="#改进算法" class="headerlink" title="改进算法"></a>改进算法</h3><ul>
<li>Partition ：仅扫描数据库两次</li>
<li>DHP：降低候选项的数目</li>
<li>DIC：降低扫描次数</li>
</ul>
<h3 id="评价"><a href="#评价" class="headerlink" title="评价"></a>评价</h3><p>Apriori算法需要多次扫描数据库这带来的开销很大，同时会生成大量的候选项集并做子集测试也造成了很大的计算开销。</p>
<h2 id="FP-Growth"><a href="#FP-Growth" class="headerlink" title="FP-Growth"></a>FP-Growth</h2><p>频繁模式增长FP-Growth将代表频繁项集的数据库压缩到一颗频繁模式树Frequent Patterns (FP树)中。</p>
<h3 id="FP树的构建"><a href="#FP树的构建" class="headerlink" title="FP树的构建"></a>FP树的构建</h3><ul>
<li>首先扫描一次数据库，找到频繁一项集。</li>
<li>根据支持度计数降序排列频繁项记为L</li>
<li>创建一个根节点，并标记为null</li>
<li>再次扫描数据库，将每个事务按照L中的顺序排列。为每个事务新建一个分支<ul>
<li>如果事务中的项已经在分支中，则分支上的节点计数+1</li>
<li>如果项不在分支中，则在前缀路径下新建一个节点，计数为1</li>
</ul>
</li>
<li>建立一个项头表把FP树中的每一项的节点相连。</li>
</ul>
<p><img src="https://res.cloudinary.com/bravey/image/upload/v1574157675/blog/Data%20Mining/FP_tree_construct.jpg" alt="FP树"></p>
<p>以上图为例，第一次扫描后得到的频繁一项集为$L_1=\{f:4,c:4,a:3,b:3,m:3,p:3\}$ 已经按照支持度计数降序排列为F-list。第二次扫描数据库，并按照F-list的顺序将每个事务排列（注意：低于支持度计数的项已经被删除了）。建立一个根节点并标记为null,第一个事务是$\{f,c,a,m,p\}$</p>
<p><img src="https://res.cloudinary.com/bravey/image/upload/v1574157675/blog/Data%20Mining/fp_tree_1.jpg" alt=""></p>
<p>因为是第一个事务所以没有前缀路径可以共用，每个项都需要建立一个节点。第二个事务是$\{f,c,a,b,m\}$因为$\{f,c,a\}$ 是已经有的路径，所以对应的在这3个节点计数+1，$\{b,m\}$ 没有可以共享的路径所以需要新建立这两个节点。</p>
<p><img src="https://res.cloudinary.com/bravey/image/upload/v1574157674/blog/Data%20Mining/fp_tree_2.jpg" alt=""></p>
<p>当所有事务都被加入到FP树后建立项头表将相同的项给链接起来就可以得到前面的完整的FP树。</p>
<h3 id="条件模式基的构造"><a href="#条件模式基的构造" class="headerlink" title="条件模式基的构造"></a>条件模式基的构造</h3><p>从项头表中具有最低的支持度计数的项开始构造每一个项的条件模式基Conditional Pattern Base。一个项的条件模式基定义为以这个项为后缀的前缀路径。</p>
<p><img src="https://res.cloudinary.com/bravey/image/upload/v1574157675/blog/Data%20Mining/conditional_patter_base.jpg" alt=""></p>
<p>以上图为例，先构造p的条件模式基，在FP树中，以p为后缀的路径为$fcam:2 和cb:1$ 后面的计数是根据每条路径的后缀的计数来确定的因此第一条$fcamp$路径的计数为2而$cbp$为1。 依次可以得到每个项的条件模式基。对每一个项的条件模式基都可以按照前述的FP树的构造方法得到其对应的条件FP树。以m的条件模式基构建的条件FP树为：<br><img src="https://res.cloudinary.com/bravey/image/upload/v1574157675/blog/Data%20Mining/m_conditional_fptree.jpg" alt=""></p>
<p>因为b的支持度计数只有1所以删去。</p>
<h3 id="频繁模式的产生"><a href="#频繁模式的产生" class="headerlink" title="频繁模式的产生"></a>频繁模式的产生</h3><p>根据条件FP树的路径产生频繁模式，路径的每个非空子集与对应的项组合产生对应的频繁模式。比如m的FP树路径为：$\{fca\}$ 对应的子集有$\{f\},\{c\},\{a\}, \{f,c\},\{f,a\},\{a,c\},\{f,c,a\}$与m组合后得到的频繁模式有：$\{f,m\},\{c,m\},\{a.m\}, \{f,c,m\},\{f,a.m\},\{a,c,m\},\{f,c,a,m\}$</p>
<h3 id="FP树的优点"><a href="#FP树的优点" class="headerlink" title="FP树的优点"></a>FP树的优点</h3><p>完整的保留了频繁模式挖掘的所有信息，不损失每个事务可能的频繁项集。将发现长频繁模式的问题转换成递归地发现一些短模式，然后与后缀连接。它使用最不频繁的项作后缀，提供了好的选择性。该方法大大降低了搜索开销。</p>
<p>FP-Growth采用分治的方法专注于小的数据集，不产生候选项集，只扫描两次数据库。因此性能比Apriori算法好。</p>
<h3 id="FP-Growth-伪代码"><a href="#FP-Growth-伪代码" class="headerlink" title="FP-Growth 伪代码"></a>FP-Growth 伪代码</h3><p><img src="https://res.cloudinary.com/bravey/image/upload/v1574157675/blog/Data%20Mining/FP-Growth_code.jpg" alt=""></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《数据挖掘概念与技术》第3版 第六章挖掘频繁模式、关联和相关性：基本概念和方法</p>
]]></content>
      <categories>
        <category>数据挖掘</category>
      </categories>
      <tags>
        <tag>课程</tag>
        <tag>国科大</tag>
        <tag>关联规则</tag>
        <tag>Apriori</tag>
        <tag>FP-Growth</tag>
      </tags>
  </entry>
  <entry>
    <title>分类与预测</title>
    <url>/2019-11-17-%E5%88%86%E7%B1%BB%E4%B8%8E%E9%A2%84%E6%B5%8B.html</url>
    <content><![CDATA[<h1 id="分类与预测"><a href="#分类与预测" class="headerlink" title="分类与预测"></a>分类与预测</h1><h2 id="分类与预测的差别"><a href="#分类与预测的差别" class="headerlink" title="分类与预测的差别"></a>分类与预测的差别</h2><p>分类对给定的数据集一般是离散的，确定这些数据对应类别。而预测是对连续的数据，根据历史数据来预测未知的数据或者缺失值等。</p>
<p>分类的过程分为两步：</p>
<ul>
<li><p>模型构建</p>
<p>使用训练数据集对模型进行训练，模型可以被表示为一些分类的规则集合，决策树或者是数学公式。</p>
</li>
<li><p>模型使用</p>
<p>先使用模型来对测试数据进行分类，如果准确率能够接受则使用模型去对没有标注过的数据进行分类。</p>
</li>
</ul>
<p>分类属于有监督学习，训练的数据是经过标注的。聚类属于无监督学习训练数据未经过标注不知道样本的标签。</p>
<a id="more"></a>
<p>在进行分类和预测之前需要对数据进行预处理包括数据清洗来处理噪声和缺失值，相关性分析来进行特征提取，数据转换比如归一化等。</p>
<p>对于分类方法的评测指标有：准确性，速度，鲁棒性，可规模性（硬盘数据），可解释性等</p>
<h2 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h2><p>决策树是一个类似于流程图的树结构；其中，每个内部结点表示在一个属性上的测试，每个分枝代表一个测试输出，而每个树叶结点代表类或类分布。树的最顶层结点是根结点。给定数据经过决策树不同节点的决策最终走到叶子节点，从而完成了对数据的分类。决策树不需要任何领域知识也不需要参数，适合探测式知识发现。</p>
<p>决策数的构建分为两步：</p>
<ul>
<li>树的构建 从根节点开始递归的选择属性进行建树</li>
<li>剪枝 ：减去反映噪声或者离群点的分枝</li>
</ul>
<h3 id="构建决策树"><a href="#构建决策树" class="headerlink" title="构建决策树"></a>构建决策树</h3><p>算法伪代码为：</p>
<p><img src="https://res.cloudinary.com/bravey/image/upload/v1574086256/blog/Data%20Mining/decision_tree_code.jpg" alt=""></p>
<p>三个参数D是输入的数据集,attribute_list是输入数据中的属性集合和Atrribute_selection_method是指定选择属性的启发式过程，可以选择信息增益或者是基尼指数Gini index。</p>
<p>步骤为：</p>
<ol>
<li><p>首先从根节点N开始，根节点中的数据是原始的需要分类的原始数据集。</p>
</li>
<li><p>如果D中的数据都属于同一类，那么根节点N变成叶子节点，标记为这一类。</p>
</li>
<li><p>否则，调用Atrribute_selection_method来选择最佳的分裂属性，并给出分裂子集。理想情况下希望分裂子集尽可能的纯，也就是希望分裂自己尽可能的都属于同一类。</p>
</li>
<li><p>用选出来的分裂属性在节点N上进行划分，并输出划分的数据子集。并把分裂属性从属性列表中删除。</p>
<ol>
<li>选出来的属性是离散值的话，有多少个取值就产生多少个分支</li>
<li>连续值的话选择一个分裂值，大于这个分裂值为一个分支，小于等于为另外一个分支</li>
<li>离散值而且必须是二叉树的话：属于这个值为一个分支，否则为另外一个分支</li>
</ol>
<p><img src="https://res.cloudinary.com/bravey/image/upload/v1574086256/blog/Data%20Mining/split_choice.jpg" alt=""></p>
</li>
<li><p>对于每一个删除了最佳分裂属性的输出的子集$D_j$ 递归的调用算法。</p>
</li>
<li><p>递归的终止条件：</p>
<ol>
<li>数据集D都属于同一类</li>
<li>属性列表为空，使用数据集中的多数类来标记节点。<strong>（多数投票）</strong></li>
<li>如果一个分支的数据$D_j$为空，则新增加一个叶子节点，用父节点数据集D中的多数类来标记它。</li>
</ol>
</li>
<li><p>返回决策数的节点N</p>
</li>
</ol>
<h3 id="属性选择度量"><a href="#属性选择度量" class="headerlink" title="属性选择度量"></a>属性选择度量</h3><p>很明显，决策树的关键点是怎么选择分裂的属性。有如下三种方式。</p>
<h4 id="信息增益"><a href="#信息增益" class="headerlink" title="信息增益"></a>信息增益</h4><p>ID3这种决策树方法使用。</p>
<p>先计算数据集D的熵：</p>
<script type="math/tex; mode=display">
Info(D)=-\sum_{i=1}^{m}p_ilog_2(p_i)</script><p>假设数据集中D有m个类别${C_1,C_2\dots C_m}$，那么每一类的概率可以用所占的比例$p_i=\dfrac{count(C_i)}{count(D)}$来估计。</p>
<p>假设属性A 具有v 个不同值${a_1 ,…, a_v}$。可以用属性A 将S 划分为v 个子集${S_1 ,…, S_v}$；其中，<br>$S_j$ 包含S 中这样一些样本，它们在A 上具有值$a_j$。如果A 选作测试属性,则获得的信息增益,也就是划分成了子集后的熵为：</p>
<script type="math/tex; mode=display">
Info_A(D)=\sum_{j=1}^{v}\dfrac{|D_j|}{|D|}\times Info(D_j)</script><p>信息增益定义为原来的的信息需求（近基于类比例）与新的信息需求（对A划分后）之间的差：</p>
<script type="math/tex; mode=display">
Gain(A)=Info(D)-Info_A(D)</script><p>具有最高信息增益的属性是最佳分裂属性。可以这样理解，划分后越纯那么整个状态越不混乱，也就是熵越低。所以选择划分后熵最低而信息增益最高的属性。</p>
<h4 id="信息增益率"><a href="#信息增益率" class="headerlink" title="信息增益率"></a>信息增益率</h4><p>信息增益偏向有许多输出的测试，它倾向于选择具有大量值的属性。比如按照唯一的标识符id来划分，每个划分出来的都只包含一个数据都是纯的，但是这样的划分显然没有作用。</p>
<p>C4.5使用增益率来进行选择分裂属性。增益率用分裂信息值将信息增益归一化。</p>
<script type="math/tex; mode=display">
SplitInfo_A(D)=-\sum_{j=1}^{v}\dfrac{|D_j|}{|D|}\times log_2(\dfrac{|D_j|}{D})</script><p>分裂信息值代表由训练数据集D根据属性A划分v个分区后，这v个分区的熵。前面的$Info_A(D)$是对每个分区还计算了一下分区里面的熵然后进行加权，而这里是全局地看待这v个分局而进行的计算。</p>
<p>增益率定义为：</p>
<script type="math/tex; mode=display">
GainRate(A)=\dfrac{Gain(A)}{SplitInfo_A(D)}</script><p>选择具有最大增益率的属性作为分裂属性。</p>
<h4 id="基尼指数"><a href="#基尼指数" class="headerlink" title="基尼指数"></a>基尼指数</h4><p>基尼指数在CART中使用，基尼指数度量数据集的不纯度，定义为：</p>
<script type="math/tex; mode=display">
Gini(D)=1-\sum_{i=1}^{m}p_i^2</script><p>$p_i=\dfrac{|C_i|}{|D|}$依然用每一类的比例来估计。基尼指数考虑每个属性的二元划分，根据属性A划分成两个两个子集$D_1,D_2$在这种划分下的基尼指数为：</p>
<script type="math/tex; mode=display">
Gini_A(D)=\dfrac{|D_1|}{|D|}Gini(D_1)+\dfrac{|D_2|}{|D|}Gini(D_2)</script><p>选择具有最低的基尼指数作为分裂属性。  </p>
<h3 id="决策树决策规则"><a href="#决策树决策规则" class="headerlink" title="决策树决策规则"></a>决策树决策规则</h3><p>构建好了决策树后，决策规则使用IF-THEN的语句来表示。<img src="https://res.cloudinary.com/bravey/image/upload/v1574086256/blog/Data%20Mining/decision_tree_rules.jpg" alt=""></p>
<p>比如上图的决策规则是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">IF age is Middle_aged THEN buys_computer = yes</span><br><span class="line">IF age is youth AND student = no THEN buys_computer = no</span><br><span class="line">IF age is youth AND student = yes THEN buys_computer = yes</span><br><span class="line">IF age is senior AND credit_rating=excellent THEN buys_computer = no</span><br><span class="line">IF age is senior AND credit_rating=fair THEN buys_computer = yes</span><br></pre></td></tr></table></figure>
<p>有多少个叶子节点相应的有多少决策规则，在到达叶子节点的路径上有多少个节点就有多少个并列的条件。</p>
<h3 id="过拟合与树剪枝"><a href="#过拟合与树剪枝" class="headerlink" title="过拟合与树剪枝"></a>过拟合与树剪枝</h3><p>在创建决策树时，由于数据中的噪声和离群点，许多分支反映的是训练数据中的异常。使用剪枝的方法来处理这种过拟合的问题。</p>
<h4 id="先剪枝"><a href="#先剪枝" class="headerlink" title="先剪枝"></a>先剪枝</h4><p>先剪枝prepruning方法提前停止树的创建。比如设定一个阈值当信息增益等度量超过阈值则分裂，不超过就停止分裂，用投票的方法确定标签。但是阈值的设置比较困难，所以不常用。</p>
<h4 id="后剪枝"><a href="#后剪枝" class="headerlink" title="后剪枝"></a>后剪枝</h4><p>后剪枝postpruning方法从完全创建好了的决策树进行剪枝。剪去后也依然使用投票的方法来确定标签。</p>
<p>CART使用<strong>代价复杂度</strong>剪枝算法，C4.5使用<strong>悲观剪枝</strong>的方法。二者都是根据错误率，简单说就是如果减去这个分支后错误率提升不大就可以减去。</p>
<h3 id="决策树评价"><a href="#决策树评价" class="headerlink" title="决策树评价"></a>决策树评价</h3><p>比其他的分类方法有着相对更快的学习速度，能够转换成容易理解的决策规则，准确率也能接受，而且也可以适用于大规模的数据。</p>
<h2 id="贝叶斯分类"><a href="#贝叶斯分类" class="headerlink" title="贝叶斯分类"></a>贝叶斯分类</h2><p>朴素贝叶斯分类发假定一个属性值在给定类上的影响独立于其他属性的值，这个假定称为类条件独立性。做这个假定是为了简化计算，因而称之为朴素的。</p>
<h3 id="贝叶斯定理"><a href="#贝叶斯定理" class="headerlink" title="贝叶斯定理"></a>贝叶斯定理</h3><p>贝叶斯定理用来求解后验概率。公式为：</p>
<script type="math/tex; mode=display">
P(H|X)=\dfrac{P(H)P(X|H)}{P(X)}</script><p>X是数据样本，分类未知。H是对X的分类的假设，比如X属于C类。P(H)是猜测的类的概率，P(X)是观察到的样本X的概率，而P(H|X)是在给定H的假设下，观察到X样本的概率。</p>
<h3 id="朴素贝叶斯分类"><a href="#朴素贝叶斯分类" class="headerlink" title="朴素贝叶斯分类"></a>朴素贝叶斯分类</h3><h4 id="工作过程"><a href="#工作过程" class="headerlink" title="工作过程"></a>工作过程</h4><ol>
<li><p>训练数据集D中一个样本X向量用一个n维的列向量$[x_1,x_2\dots x_n]^T$来表示它对应的n个属性$[A_1,A_2\dots A_n]$的测量值。</p>
</li>
<li><p>假定有m个类$C_1,C_2\dots C_n$,将X预测为拥有最高后验概率的类。</p>
<script type="math/tex; mode=display">
max(P(C_i|X))=max(\dfrac{P(X|C_i)P(C_i)}{P(X)})</script></li>
<li><p>因为$P(X)$是常数，所以只用最大化$P(X|C_i)P(C_i)$ $P(C_i)$用类的频率来估计</p>
</li>
<li><p>在类条件独立的假定下有：</p>
<script type="math/tex; mode=display">
P(X|C_i)=\prod_{k=1}^nP(x_k|C_i)=P(x_1|C_i)P(x_2|C_i)\dots P(x_n|C_i)</script><p>$x_k$表示样本X向量对应的第k个属性$A_k$的值。</p>
<ol>
<li><p>如果$A_k$是分类属性，那么$P(x_k|C_i)$是D中属性$A_k$的值为$x_k$的$C_i$类的元组数除以D中$C_i$的数目 </p>
</li>
<li><p>如果$A_k$是连续值，则假定连续值服从均值为$\mu$,标准差为$\sigma$的高斯分布。</p>
<script type="math/tex; mode=display">
g(x,\mu,\sigma)=\dfrac{1}{\sqrt{2\pi}\sigma}e^{-\dfrac{(x-\mu)^2}{2\sigma^2}}</script><p>所以可以得到：</p>
<script type="math/tex; mode=display">
P(x_k|C_i)=g(x_k,\mu_{C_i},\sigma_{C_i})</script></li>
</ol>
</li>
<li><p>对每一类都分别计算$P(X|C_i)P(C_i)$ 最后选择最大的作为这个样本的分类。</p>
</li>
</ol>
<h4 id="零概率值的解决"><a href="#零概率值的解决" class="headerlink" title="零概率值的解决"></a>零概率值的解决</h4><p>在做连乘的时候如果有一个的概率为0，那么整个计算结果都为0。可以假设训练数据集很大，将每个取值的计数都加1而造成的概率估计可以忽略不计。这样就可以避免出现零概率的情况，称之为<strong>拉普拉斯估计或这拉普拉斯校准法</strong></p>
<h3 id="评价"><a href="#评价" class="headerlink" title="评价"></a>评价</h3><p>朴素贝叶斯的优势：比较容易实现，在大多数情况可以取得好结果。缺点是：因为做了属性互相独立的假设，因此会降低准确率。而且实际上，大部分属性之间并不互相独立。</p>
<p>可以使用贝叶斯信念网络来处理。</p>
<h2 id="BP神经网络"><a href="#BP神经网络" class="headerlink" title="BP神经网络"></a>BP神经网络</h2><h3 id="多层前馈神经网络"><a href="#多层前馈神经网络" class="headerlink" title="多层前馈神经网络"></a>多层前馈神经网络</h3><p>后向传播算法Back propagation在多层前馈神经网络上学习。由输入层、一个或多个隐藏层和一个输出层组成。</p>
<p><img src="C:\Users\BraveY\Documents\BraveY\blog\images\data mining\multi_layer_feed_forward_network.jpg" alt=""></p>
<p>输入层的单元称作输入单元，隐藏层和输出层单元称作输出单元或者神经节点。输入向量输入进输入单元，然后加权同时地提供给隐藏层的输出单元。在全连接的情况下每一层单元与前后层单元都会有相应的权重，因为权重不会回馈到输入节点，所以称为前馈的。因此一次输入就完成输出。</p>
<h3 id="网络拓扑的定义"><a href="#网络拓扑的定义" class="headerlink" title="网络拓扑的定义"></a>网络拓扑的定义</h3><p>应该设计多少层隐藏层，每一层有多少单元，输入层单元应该有多少，是否全连接等都是网络拓扑需要考虑的。</p>
<p>需要先对输入值进行归一化，将值落入[0,1]之间。离散值的属性可以进行重新编码，让每一个域值都有一个输入单元。如果属性A有3个可能的值${a_0, a_1, a_2}$那么就需要设计3个输入单元$I_0, I_1,I_2$，输入单元$I_1$为1对应属性$A=a_1$。</p>
<p>如果进行分类的话如果只有两类那么输出单元只用一个就可以了，多于2类的情况每一类都有一个输出单元。</p>
<p>隐藏层单元数目的设计，没有明确的规定，通过反复实验的过程，来确定。一般选择一个隐藏层就可以了，权重的初始值也会影响结果的准确率。</p>
<h2 id="后向传播"><a href="#后向传播" class="headerlink" title="后向传播"></a>后向传播</h2><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>后向传播通过迭代地处理训练数据，把每个样本的网络预测值与实际已知的目标值相比较。对每个训练样本，修改网络的权重使得网络预测和实际目标值之间的均方误差最小。修改后向进行，从输出层一直传递到输入层的，因此叫做后向传播。</p>
<p>算法伪代码为：</p>
<p><img src="https://res.cloudinary.com/bravey/image/upload/v1574086256/blog/Data%20Mining/bp_code.jpg" alt=""></p>
<p>步骤为：</p>
<p><strong>初始化权重：</strong>权重被初始化为小随机数（比如-1到1，或者-0.5到0.5），偏倚bias也初始化为小随机数。</p>
<p><strong>向前传播输入</strong>：输入单元的输出就是输入值。隐藏层和输出层单元的净输入用上一层输入的线性组合计算。输出单元的输出用激活函数计算，激活函数是logistic或这S型sigmoid函数,激活函数将较大的输入值域映射到区间[0,1]</p>
<p><img src="https://res.cloudinary.com/bravey/image/upload/v1574086256/blog/Data%20Mining/bpnn_io.jpg" alt=""></p>
<p>隐藏层或者输出层单元j其输入为如下，其中$w_{ij}$是上层单元i到单元j的权重，$O_i$是上一层单元的输出，$\theta_j$是单元j的偏倚。偏倚用来充当阈值，改变单元的活性</p>
<script type="math/tex; mode=display">
I_j=\sum_{i}w_{ij}O_i+\theta_j</script><p>单元j的输出$O_j$为：</p>
<script type="math/tex; mode=display">
O_j=\dfrac{1}{1+e^{I_j}}</script><p><strong>向后传播误差</strong>：通过更新权重和反映网络预测误差的偏倚，向后传播误差。对于输出层单元j，误差如下，其中$O_j$ 是单元j的实际输出， $T_j$ 是j给定训练样本的实际目标值，$O_j(1-O_j)$是逻辑斯提函数的导数。</p>
<script type="math/tex; mode=display">
Err_j=O_j(1-O_j)(T_j-O_j)</script><p>隐藏层单元j的误差，考虑下一层中j连接的单元的误差加权和。误差如下：</p>
<script type="math/tex; mode=display">
Err_j=O_j(1-O_j)\sum_kErr_kw_{jk}</script><p>其中$w_{jk}$是下一层单元k与单元j的连接权重，而$Err_k$是单元k的误差。</p>
<p>更新权重和偏倚，以反映误差的传播。权重更新公式如下，其中$\Delta w_{ij}$是权重的改变量。</p>
<script type="math/tex; mode=display">
\begin{split}
\Delta w_{ij}&=l\times Err_jO_i\\
w_{ij}&=w_{ij}+\Delta w_{ij}
\end{split}</script><p>变量l是<strong>学习率</strong>，通常去[0,1]之间的常数值。学习率帮助避免陷入决策空间的局部极小，并有助于找到全局最小。学习率太低的话，学习将进行的很慢。学习率太高的话，可能出现在不适当的解之间的摆动。一种调整规则是将学习率设置为迭代次数的倒数。</p>
<p>偏倚的更新公式为：其中$\Delta \theta_{ij}$是偏倚的改变量。</p>
<script type="math/tex; mode=display">
\begin{split}
\Delta \theta_{ij}&=l\times Err_j\\
\theta_{ij}&=\theta_{ij}+\Delta \theta_{ij}
\end{split}</script><p>更新的策略有实例更新：每处理一个样本就更新权重和偏倚。周期更新为处理玩所有样本后再更新。实例更新通常产生更准确的结果。</p>
<p><strong>终止条件：</strong></p>
<ul>
<li>前一周期所有的$\Delta w_{ij}$都太小，小于某个阈值</li>
<li>前一周其误分类的数据百分比小于某个阈值</li>
<li>超过预先指定的周期数。实践中权重收敛可能需要数十万个周期。</li>
</ul>
<p>和决策树一样，神经网络也可以剪枝，去除那些影响很小的连接。</p>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p>
<ul>
<li>对噪声的高容忍</li>
<li>对连续值的良好适配</li>
<li>对真实数据的良好处理</li>
<li>效果很好</li>
</ul>
<p>缺点：</p>
<ul>
<li>很长的训练时间</li>
<li>要求大量的参数</li>
<li>解释性很差</li>
</ul>
<h2 id="其他分类方法"><a href="#其他分类方法" class="headerlink" title="其他分类方法"></a>其他分类方法</h2><p>包括KNN、集成学习比如（Baggin、Boosting）</p>
<h2 id="预测"><a href="#预测" class="headerlink" title="预测"></a>预测</h2><p>线性回归模型、多项式回归模型、广义线性模型、对数线性模型（针对分类数据）</p>
<h2 id="准确率和误差的衡量"><a href="#准确率和误差的衡量" class="headerlink" title="准确率和误差的衡量"></a>准确率和误差的衡量</h2><p>使用混淆矩阵confusion matrix来表示分类的情况。</p>
<p><img src="https://res.cloudinary.com/bravey/image/upload/v1574086256/blog/Data%20Mining/confusion_matrix.jpg" alt=""></p>
<p>准确率和错误率表示为：</p>
<script type="math/tex; mode=display">
\begin{split}
Accuracy&=\dfrac{(true\_pos+true\_neg)}{pos+neg}\\
Error rate&=1-Accuracy
\end{split}</script><p>还有其他几个指标</p>
<script type="math/tex; mode=display">
\begin{split}
sensitivity&=\dfrac{true\_pos}{pos} /* 真阳的识别率*/\\
specificity&=\dfrac{true\_neg}{neg} /* 真阴的识别率*/\\
precision&=\dfrac{true\_pos}{true\_pos+true\_neg} /* 预测的精度*/\\
\end{split}</script><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《数据挖掘概念与技术》第3版 第八章分类：基本概念 第九章 分类高级方法</p>
]]></content>
      <categories>
        <category>数据挖掘</category>
      </categories>
      <tags>
        <tag>课程</tag>
        <tag>国科大</tag>
        <tag>分类</tag>
        <tag>贝叶斯</tag>
        <tag>神经网络</tag>
        <tag>决策树</tag>
      </tags>
  </entry>
  <entry>
    <title>数据预处理</title>
    <url>/2019-11-16-%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86.html</url>
    <content><![CDATA[<h1 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h1><h2 id="为什么数据预处理"><a href="#为什么数据预处理" class="headerlink" title="为什么数据预处理"></a>为什么数据预处理</h2><p>原始数据可能掺杂着噪音、空值或者不正确、不一致、充满冗余值等。没有高质量的数据，很难挖掘出高质量的规则，因此需要数据预处理。数据预处理主要有：数据清洗、数据集成、数据归约、数据离散等几个任务。</p>
<a id="more"></a>
<h2 id="数据描述"><a href="#数据描述" class="headerlink" title="数据描述"></a>数据描述</h2><p>得到一份数据后，需要先对数据进行一个大概的认识，主要从中心趋势和发散特征两方面统计进行描述。</p>
<h3 id="中心趋势度量"><a href="#中心趋势度量" class="headerlink" title="中心趋势度量"></a>中心趋势度量</h3><h4 id="平均值-mean"><a href="#平均值-mean" class="headerlink" title="平均值 mean"></a>平均值 mean</h4><p>均值又分为：</p>
<ul>
<li><p>算术均值</p>
<p> $\bar x=\frac{1}{n}\sum_{i=1}^{n}x_i$</p>
</li>
<li><p>加权均值</p>
<p>$\bar x= \frac{\sum_{i=1}^{n}w_ix_i}{\sum_{i=1}^{n}w_i}$</p>
</li>
<li><p>截尾均值 Trimmed mean</p>
<p>均值对极端数据比如离群点很敏感。因此截取高低两端的一部分数据后再计算均值，但是截去的部分不能太多不超过$20\%$</p>
</li>
</ul>
<h4 id="中位数-median"><a href="#中位数-median" class="headerlink" title="中位数 median"></a>中位数 median</h4><p>对于倾斜（非对称）数据，数据中心的更好度量是中位数。</p>
<p>假定数据有序，则当n为奇数时中位数是中间的值，当n为偶数的时候，中位数不唯一，可以是中间两个值和之间的任意值。如果属性是数值属性，那么一般约定取中间两个值的平均值。</p>
<h4 id="众数-mode"><a href="#众数-mode" class="headerlink" title="众数 mode"></a>众数 mode</h4><p>另一种中心趋势的度量方法，众数是集合中出现最频繁的值。数据可能会有多个众数，如果最高频的值有多个的时候。如果每个数据值近出现一次，是没有众数的。</p>
<p>有一个、两个、三个众数的分别称为：单峰的(unimodal)、双峰的（bimodal）和三峰的（trimodal）</p>
<h4 id="中列数-midrange"><a href="#中列数-midrange" class="headerlink" title="中列数 midrange"></a>中列数 midrange</h4><p>中列数是数据集的最大和最小值的平均值。</p>
<h4 id="对称与倾斜"><a href="#对称与倾斜" class="headerlink" title="对称与倾斜"></a>对称与倾斜</h4><p>完全对称的数据分布的单峰频率曲线中，均值、中位数和众数三者是相同的中心值。</p>
<p>不对称的情况分为：</p>
<ul>
<li>正倾斜：众数小于中位数</li>
<li>负倾斜：众数大于中位数</li>
</ul>
<p>如下所示,最上方是对称的，左下是正倾斜的，右下是负倾斜的。</p>
<p><img src="https://res.cloudinary.com/bravey/image/upload/v1573992640/blog/Data%20Mining/symmetric_skewed.jpg" alt=""></p>
<h3 id="数据散布度量"><a href="#数据散布度量" class="headerlink" title="数据散布度量"></a>数据散布度量</h3><h4 id="极差、四分位数和四分位数极差"><a href="#极差、四分位数和四分位数极差" class="headerlink" title="极差、四分位数和四分位数极差"></a>极差、四分位数和四分位数极差</h4><p><strong>极差（range）</strong>：最大值与最小值之差。</p>
<p>有序数据值下的数据集合的第k 个百分位数是具有如下性质的值x：数据项的百分之k 在x 上或低于x。在中位数M上或低于M 的值对应于第50 个百分位数。</p>
<p><strong>四分位数</strong>将数据分为4段总共有3个四分位数，Q1是第25个百分位数，Q2即是Median是第50个百分位数，Q3是第75个百分位数。</p>
<p>100-分位数通常称为百分位数，它们把数据分成100个大小相等的连贯集。中位数、四分位数和百分位数是使用最广泛的分位数。</p>
<p>第一个和第三个四分位数之间的距离是分布的一种简单度量，它给出被数据的中间一半<br>所覆盖的范围。该距离称为中间<strong>四分位数极差（IQR）</strong>：$IQR=Q_3-Q_1$</p>
<h4 id="五数概括、盒图与离群点"><a href="#五数概括、盒图与离群点" class="headerlink" title="五数概括、盒图与离群点"></a>五数概括、盒图与离群点</h4><p><strong>离群点(Outlier)</strong>：与$Q_1$或者$Q_3$这两个分位数的值超过$1.5IQR$</p>
<p>五数概括使用最小值、$Q_1$ 、中位数、$Q_3$、最大值来概述数据的中心与散布。</p>
<p>可以使用盒图来体现五数概括 。</p>
<ul>
<li>盒的端点在四分位数上，使得盒的长度是中间四分位数区间IQR</li>
<li>中位数用盒内的线标记</li>
<li>盒外的两条线（称作胡须）延伸到最小（Minimum）和最大（Maximum）观测值。如果最大最小值超过$1.5IQR$，那么只延伸到这个部分。</li>
</ul>
<p><img src="https://res.cloudinary.com/bravey/image/upload/v1573992640/blog/Data%20Mining/box_plot.jpg" alt=""></p>
<p>如上图所示，最大值超过了$1.5IQR$所以只延伸到了$1.5IQR$，而超过$1.5IQR$部分的被标记为离群点。</p>
<h4 id="方差、标准差"><a href="#方差、标准差" class="headerlink" title="方差、标准差"></a>方差、标准差</h4><p>方差Variance与标准差Standard deviation指出数据分布的散布程度。</p>
<p>总体方差的计算：$\sigma^2=\frac{1}{n}\sum_{i=1}^{n}(x_i-\mu)^2={\frac{1}{n}\sum_{i=1}^{n}x_i^2}-{\mu}^2$</p>
<p>样本方差的计算：$s^2=\frac{1}{n-1}\sum_{i=1}^{n}(x_i-\bar x)^2={\frac{1}{n-1}（\sum_{i=1}^{n}x_i^2}-\frac{1}{n}\sum_{i=1}^{n}x_i^2）$</p>
<p>$\mu$是总体数据的平均值，而$\bar x$是总体数据中的一部分样本的均值，可以用样本的均值来估计总体的均值。样本方差是无偏估计的，<a href="https://www.zhihu.com/question/20099757" target="_blank" rel="noopener">样本方差与总体方差的差别</a></p>
<p>标准差是方差的平方根，就是$\sigma$或者s。它的性质是：</p>
<ul>
<li>$\sigma$<strong>度量关于平均值的发散</strong>，仅当选择平均值作为中心度量时使用。</li>
<li>仅当不存在发散时，即当所有的观测值都相同时，$\sigma=0$。否则，$\sigma&gt;0$。</li>
</ul>
<h3 id="数据描述的图形表示"><a href="#数据描述的图形表示" class="headerlink" title="数据描述的图形表示"></a>数据描述的图形表示</h3><h4 id="直方图"><a href="#直方图" class="headerlink" title="直方图"></a>直方图</h4><p>直方图Histogram 或者频率直方图Frequency histograms 针对单变量，对于比较单变量观测组，它可能不如分位数图、q-q 图和盒图方法有效。</p>
<p><img src="https://res.cloudinary.com/bravey/image/upload/v1573992639/blog/Data%20Mining/histogram.jpg" alt=""></p>
<h4 id="分位数图"><a href="#分位数图" class="headerlink" title="分位数图"></a>分位数图</h4><p>分位数图Quantile Plot每个观测值$x_i$与一个百分数$f_i$配对，指出大约$f_i \times 100\%$的数据小于值$x_i$，“大约”是因为可能没有一个精确的小数值$f_i$，使得数据的$f_i\%$小于或等于$x_i$。0.25 分位数对应于Q1，0.50 分位数对应于中位数，而0.75 分位数对应于Q3。</p>
<p>$f_i$的定义：$f_i=\frac{i-0.5}{N}$这些数由$\frac{1}{2N}$（稍大于0）到$1-\frac{1}{2N}$（稍小于1），以相同的步长1/n 递增。</p>
<p><img src="https://res.cloudinary.com/bravey/image/upload/v1573992640/blog/Data%20Mining/Quantile_Plot.jpg" alt=""></p>
<h4 id="分位数-分位数图"><a href="#分位数-分位数图" class="headerlink" title="分位数-分位数图"></a>分位数-分位数图</h4><p>分位数-分位数图Quantile-Quantile Plot，或q-q 图对着另一个的对应分位数，绘制一个单变量分布的分位数。它是一种强有力的直观表示工具，使得用户可以观察从一个分布到另一个是否有漂移。![]<a href="https://res.cloudinary.com/bravey/image/upload/v1573992640/blog/Data%20Mining/qq_plot.jpg" target="_blank" rel="noopener">https://res.cloudinary.com/bravey/image/upload/v1573992640/blog/Data%20Mining/qq_plot.jpg</a>)</p>
<p>部门1的分布相对于部门2有一个漂移，更趋向于部门2，说明部门2的单价趋向于比部门1高。</p>
<h4 id="散点图"><a href="#散点图" class="headerlink" title="散点图"></a>散点图</h4><p>散点图(scatter plot)是确定两个量化变量之间看上去是否有联系、模式或趋势的最有效的图形方法之一。</p>
<p>它观察的是<strong>双变量</strong>，可以观察点簇和离群点，或者考察相关性。正相关x随着y的增加而增加，负相关x随着y的增长而减少。</p>
<p><img src="https://res.cloudinary.com/bravey/image/upload/v1573992640/blog/Data%20Mining/scatter_plot.jpg" alt=""></p>
<h2 id="数据清洗"><a href="#数据清洗" class="headerlink" title="数据清洗"></a>数据清洗</h2><h4 id="缺失值"><a href="#缺失值" class="headerlink" title="缺失值"></a>缺失值</h4><ul>
<li>忽略元组</li>
<li>人工填写缺值</li>
<li>使用全局常量填充 ：比如Unknown </li>
<li>所有样本的中心值填充：均值或者中位数 均值要求数据对称分布，倾斜分布用中位数</li>
<li>给定元组的分类相同的样本的均值或者中位数</li>
<li>最可能的值：使用贝叶斯推理、回归、决策数等进行预测。 前面几种是有偏的，这种方法最常用。</li>
</ul>
<h4 id="噪声数据"><a href="#噪声数据" class="headerlink" title="噪声数据"></a>噪声数据</h4><h5 id="分箱"><a href="#分箱" class="headerlink" title="分箱"></a>分箱</h5><p>分箱方法通过考察“邻居”（即，周围的值）来平滑存储数据的值。存储的值被分布到一些“桶”或箱中。由于分箱方法导致值相邻，因此它进行局部平滑。</p>
<p>要求数据有序因此需要<strong>先进行排序</strong>，有三种方法：</p>
<ul>
<li><strong>箱均值光滑</strong>：箱中的每一个值被替换为箱中的均值</li>
<li><strong>箱中位数光滑：</strong>箱中的每一个值被替换为箱中的中位数</li>
<li><strong>箱边界光滑：</strong>边界为箱中的最大与最小值，每个值被替换为距离其最近的边界值。</li>
</ul>
<p>而箱子的分法有<strong>等频（等深）</strong>：每个箱子中的样本数目一样。<strong>等宽</strong>：按照取值范围将样本划分，每个箱子中的取值范围一致，比如样本数据取值为[0,10]那么可以按照等宽为2，把[0,2),[2,4)这样的取值范围来把样本划分到对应区间所在的范围中。</p>
<p><img src="https://res.cloudinary.com/bravey/image/upload/v1573992639/blog/Data%20Mining/bin.jpg" alt=""></p>
<h5 id="回归"><a href="#回归" class="headerlink" title="回归"></a>回归</h5><p>用函数拟合数据来光滑数据，将离拟合曲线远的数据标记为噪声数据。</p>
<h5 id="聚类"><a href="#聚类" class="headerlink" title="聚类"></a>聚类</h5><p>使用聚类分析后，检测出离群点，然后把离群点标记为噪声数据。</p>
<h2 id="数据转换"><a href="#数据转换" class="headerlink" title="数据转换"></a>数据转换</h2><h3 id="归一化-规范化"><a href="#归一化-规范化" class="headerlink" title="归一化/规范化"></a>归一化/规范化</h3><h4 id="最大-最小归一化"><a href="#最大-最小归一化" class="headerlink" title="最大-最小归一化"></a>最大-最小归一化</h4><p>对原始数据进行线性变换，映射到新的区间[new_min, new_max]中去。这种方法保持了原始数据之间的联系。</p>
<script type="math/tex; mode=display">
v_i'=\frac{v_i-min_A}{max_A-min_A}(new\_max_A-new\_min_A)</script><h4 id="z-score归一化"><a href="#z-score归一化" class="headerlink" title="z-score归一化"></a>z-score归一化</h4><p>新的值使用均值和标准差进行映射。$\bar A$和$\sigma_A$ 分别是样本的均值和他的标准差。</p>
<script type="math/tex; mode=display">
v_i'=\frac{v_i-\bar A}{\sigma_A}</script><h4 id="小数定标归一化"><a href="#小数定标归一化" class="headerlink" title="小数定标归一化"></a>小数定标归一化</h4><p>小数定标归一化 Normalization by decimal scaling。移动原来的小数点的位置来进行归一化。</p>
<script type="math/tex; mode=display">
v_i'=\dfrac{v_i}{10^j}</script><p>j是让$Max(|v_i’|&lt;1)$的最小整数，比如如果是254，那么j取3就可以让其为0.254小于1。</p>
<h2 id="冗余与相关性分析"><a href="#冗余与相关性分析" class="headerlink" title="冗余与相关性分析"></a>冗余与相关性分析</h2><p>一个属性可以由另外的属性导出，那么另外的属性就是冗余的。有些冗余可以通过<strong>相关性分析</strong>来检测</p>
<h3 id="数值数据的相关系数"><a href="#数值数据的相关系数" class="headerlink" title="数值数据的相关系数"></a>数值数据的相关系数</h3><p>相关系数Correlation coefficient也称作皮尔森积矩系数Pearson’s product moment coefficient估计两个属性A,B的相关度。</p>
<script type="math/tex; mode=display">
r_{A.B}=\dfrac{\sum_{i=1}^{n}(a_i-\bar A)(b_i-\bar B)}{(n-1)\sigma_A\sigma_B}=\dfrac{\sum_{i=1}^{n}(a_ib_i)-n\bar A\bar B}{(n-1)\sigma_A\sigma_b}</script><p>$-1\le r_{A,B}\le 1$ ,$r_{A,B}&gt;0$ A和B两个属性正相关，A的值随着B的值增长而增长。$r_{A,B}&lt;0$为负相关，A的值随着B的值增长而减少。该值越大，一个属性蕴涵另一个的可能性越大。因此，一个很大的值表明A（或B）可以作为冗余而被去掉。如果结果值等于0，则A 和B 是独立的，它们之间不相关。可以参见前述的散点图。</p>
<h3 id="分类数据的-chi-2-相关检验"><a href="#分类数据的-chi-2-相关检验" class="headerlink" title="分类数据的$\chi^2$相关检验"></a>分类数据的$\chi^2$相关检验</h3><p>分类数据Categorical Data中，两类数据可以通过$\chi^2$卡方检验来发现它们的相关性。计算公式为：</p>
<script type="math/tex; mode=display">
\begin{split}
&\chi^2=\sum_{i=1}^{c}\sum_{j=1}^{r}\dfrac{o_{ij}-e_{ij}}{e_{ij}}\\\\
&e_{ij}=\dfrac{count(A=a_i)\times count(B=b_j)}{n}
\end{split}</script><p>$o_{ij}$ 是联合事件$(A_i,B_j)$的观测频度也就是实际频数，而$e_{ij}$ 是$(A_i,B_j)$的期望值。n是总的数据样本数。使用相依表来表示数据。</p>
<p><img src="https://res.cloudinary.com/bravey/image/upload/v1573992639/blog/Data%20Mining/rely_table.jpg" alt=""></p>
<p>图中括号中的是每个单元的预测值。总共抽取1500个样本，因此n=1500。A类是否喜欢看小说有两类取值，B类性别也有两类取值，因此c=2，r=2。计算单元（男，小说）的预测值有：</p>
<script type="math/tex; mode=display">
e_{11}=\dfrac{count(男)\times count(小说)}{n}=\dfrac{300\times450}{1500}=90</script><p>其他几个单元的预测值都在括号中。因此可以计算出：</p>
<script type="math/tex; mode=display">
\chi^2=\dfrac{(250-90)^2}{90}+\dfrac{(50-210)^2}{210}+\dfrac{(200-360)^2}{360}+\dfrac{(1000-840)^2}{840}=507.93</script><p>对于这个2*2的表，自由度为（2-1)(2-1)=1。对于自由度1，在0.001的置信水平下，查表得到拒绝假设的值是10.828。算出来的值大与它，因此认为性别和爱看小说不是独立的，是强相关的。</p>
<h2 id="数据归约"><a href="#数据归约" class="headerlink" title="数据归约"></a>数据归约</h2><p>数据归约技术 Data Reduction可以用来得到数据集的归约表示，它小得多，但仍接近地保持原数据的完整性。</p>
<p>分为：</p>
<ul>
<li>维规约：降维</li>
<li>数量规约：用替代的、较小的的数据形式替换原始数据。比如只存放数据的模型参数</li>
<li>数据压缩：通过变换将原始数据压缩，不损失原来的信息叫做无损，否则是有损</li>
</ul>
<h3 id="维规约"><a href="#维规约" class="headerlink" title="维规约"></a>维规约</h3><h4 id="小波变换"><a href="#小波变换" class="headerlink" title="小波变换"></a>小波变换</h4><p>DWT）是一种线性信号处理技术，当用于数据向量D 时，将它转换成不同的数值向量小波系数D’。两个向量具有相同的长度。虽然变换后向量维度一样，但是可以仅存放一小部分最强的小波系数，就能保留近似的压缩数据。DWT提供比离散傅利叶DFT更好的有损压缩，DWT 将提供原数据更精确的近似。因此，对于等价的近似，DWT 比DFT 需要的空间小。不像DFT，小波空间局部性相当好，有助于保留局部细节。</p>
<p>该方法如下：</p>
<ol>
<li>输入数据向量的长度L 必须是2 的整数幂。必要时，通过在数据向量后添加0，这一条件可以满足。</li>
<li>每个变换涉及应用两个函数。第一个使用某种数据平滑，如求和或加权平均。第二个进行加权差分，产生数据的细节特征。</li>
<li>两个函数作用于输入数据对，产生两个长度为L/2 的数据集。一般地，它们分别代表输入数据的平滑后或低频的版本和它的高频内容。</li>
<li>两个函数递归地作用于前面循环得到的数据集，直到结果数据集的长度为2。</li>
<li>由以上迭代得到的数据集中选择值，指定其为数据变换的小波系数。</li>
</ol>
<h4 id="主成分分析"><a href="#主成分分析" class="headerlink" title="主成分分析"></a>主成分分析</h4><p>主成分分析PCA 又称Karhunen-Loeve 或K-L 方法）搜索c 个最能代表数据的k-维正交向量；这里c ≤ k。这样，原来的数据投影到一个较小的空间，导致数据压缩。PCA 可以作为一种维归约形式使用。然而，不象属性子集选择通过保留原属性集的一个子集来减少属性集的大小。PCA 通过创建一个替换的、较小的变量集“组合”属性的本质。原数据可以投影到该较小的集合中。</p>
<p>详解的过程暂时不记录，查看模式识别的教材。<strong>只适用数值数据</strong></p>
<h4 id="属性-特征子集选择"><a href="#属性-特征子集选择" class="headerlink" title="属性/特征子集选择"></a>属性/特征子集选择</h4><p>也就是降维。使用压缩搜索空间的启发式的算法，典型的是贪心算法。每次找到一个局部的好的属性，剔除掉差的属性。</p>
<p>属性子集选择的基本启发式方法包括以下技术：</p>
<ul>
<li>逐步向前选择：该过程由空属性集开始，选择原属性集中最好的属性，并将它添加到该集合中。</li>
<li>逐步向后删除：该过程由整个属性集开始。在每一步，删除掉尚在属性集中的最坏属性。</li>
<li>向前选择和向后删除的结合：向前选择和向后删除方法可以结合在一起，每一步选择一个最好的属性，并在剩余属性中删除一个最坏的属性。</li>
<li>判定树归纳：判定树算法，如ID3 和C4.5 。</li>
</ul>
<h3 id="数量规约"><a href="#数量规约" class="headerlink" title="数量规约"></a>数量规约</h3><h4 id="数据立方体集成"><a href="#数据立方体集成" class="headerlink" title="数据立方体集成"></a>数据立方体集成</h4><p>将数据整理成之前介绍过的数据立方体，把感兴趣的数据整理到基本立方体base cuboid上面。比如如果只关注每个季度的销售数据，那么可以将原来的每天的数据整理成每个季度的销售数据。这样就可以大大减少原来的数据量了。</p>
<h4 id="回归-1"><a href="#回归-1" class="headerlink" title="回归"></a>回归</h4><p>因为展开内容很多，只记录下有这些方法。当把数据拟合为某一种模型后只用记录这些模型的参数就可以了</p>
<ul>
<li>线性回归</li>
<li>多元线性回归</li>
<li>对数线性模型</li>
</ul>
<h4 id="直方图-1"><a href="#直方图-1" class="headerlink" title="直方图"></a>直方图</h4><p>就是前面叙述的分箱的方法，使用一个桶来记录一个属性的频次。或者等宽的方法，用区间来记录每个区间中的频次。</p>
<h4 id="聚类-1"><a href="#聚类-1" class="headerlink" title="聚类"></a>聚类</h4><p>聚类后，用数据的簇代表替换实际的数据。即只记录簇的中心点。</p>
<h4 id="抽样"><a href="#抽样" class="headerlink" title="抽样"></a>抽样</h4><p>假定大的数据集D 包含N 个元组。我们看看对D 的可能选样。</p>
<p>简单选择n 个样本，不回放(<strong>SRSWOR</strong>)：由D 的N 个元组中抽取n 个样本（n &lt; N）；其中， D中任何元组被抽取的概率均为1/N。即，所有元组是等可能的。</p>
<p>简单选择n 个样本，回放(<strong>SRSWR</strong>)：该方法类似于SRSWOR，不同在于当一个元组被抽取后，记录它，然后放回去。这样，一个元组被抽取后，它又被放回D，以便它可以再次被抽取。</p>
<h3 id="数据压缩"><a href="#数据压缩" class="headerlink" title="数据压缩"></a>数据压缩</h3><p>主要使用编码机制来进行压缩。包括字符串、音频、视频的压缩。</p>
<h3 id="数据离散和概念分层"><a href="#数据离散和概念分层" class="headerlink" title="数据离散和概念分层"></a>数据离散和概念分层</h3><p>可以使用分箱来、聚类、决策树和相关分析来进行离散化。而对于标称数据可以进行概念分层，前面的数据立方体就是用的这个思路。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《数据挖掘概念与技术》第3版 第三章数据预处理</p>
]]></content>
      <categories>
        <category>数据挖掘</category>
      </categories>
      <tags>
        <tag>课程</tag>
        <tag>国科大</tag>
        <tag>降维</tag>
        <tag>相关性分析</tag>
      </tags>
  </entry>
  <entry>
    <title>数据仓库</title>
    <url>/2019-11-15-%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93.html</url>
    <content><![CDATA[<h1 id="数据仓库"><a href="#数据仓库" class="headerlink" title="数据仓库"></a>数据仓库</h1><h2 id="什么是数据仓库"><a href="#什么是数据仓库" class="headerlink" title="什么是数据仓库"></a>什么是数据仓库</h2><p>有多种定义，按照一位数据仓库系统构造方面的领衔设计师William H. Inmon的说法：数据仓库是一个面向主题的、集成的、时变的、非易失的数据集合，支持管理者的决策过程。</p>
<p>一句话总结：通过数据仓库来完成对一个项目的相关需求的快速分析，是一个联机分析处理（Online Analytical Processing System）系统，具体的定义见<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93" target="_blank" rel="noopener">百度百科</a>。</p>
<a id="more"></a>
<h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><ul>
<li><strong>面向主题的</strong>：数据仓库围绕一些主题，如顾客、供应商、产品和销售组织。数据仓库关注决策者的数据建模与分析，而不是构造组织机构的日常操作和事务处理。</li>
<li><strong>集成的：</strong>通常，构造数据仓库是将多个异种数据源，如关系数据库、一般文件和联机事务处理记录，集成在一起。</li>
<li><strong>时变的</strong>：数据存储从历史的角度（例如，过去5-10 年）提供信息。</li>
<li><strong>非易失的：</strong>数据仓库总是。物理地分离存放数据；这些数据源于操作环境下的应用数据</li>
</ul>
<h3 id="操作数据库系统与数据仓库的区别"><a href="#操作数据库系统与数据仓库的区别" class="headerlink" title="操作数据库系统与数据仓库的区别"></a>操作数据库系统与数据仓库的区别</h3><p>我们常见的关系数据库就是联机操作数据库，联机操作数据库系统的主要任务是执行联机事务和查询处理。这种系统称为联机事务处理（OLTP）系统。</p>
<p><img src="https://res.cloudinary.com/bravey/image/upload/v1573875850/blog/OLTP_OLAP.jpg" alt=""></p>
<h2 id="数据立方体"><a href="#数据立方体" class="headerlink" title="数据立方体"></a>数据立方体</h2><p>数据仓库基于<strong>多维数据模型</strong>，这种模型将数据看做数据立方体形式。</p>
<p>数据立方体的定义：在一个多维的平台上面对数据建模和观察，由<strong>维和事实</strong>定义。</p>
<p>每个维都可以有一个与之相关联的表，称作维表，在表中进一步的描述维更具体的属性（比如名字、类型等）。</p>
<p>多维数据模型围绕一个具体的主题（比如销售）这样的中心主题来组织。主题用事实表表示。事实是数值度量的，事实表包括事实的<strong>名称或度量</strong>。</p>
<p>一个具体的例子如下所示，表示的是关于销售这个事实的数据立方体。其中左边是一个二维的数据立方体，右边是一个三维的数据立方体。可以扩展到n维。以3d这个数据立方体，讲解下682这个值的含义，表示Toronto市，security项目在Q2季度的销售量。<img src="https://res.cloudinary.com/bravey/image/upload/v1573875852/blog/data_cube.jpg" alt=""></p>
<h2 id="数据仓库建模"><a href="#数据仓库建模" class="headerlink" title="数据仓库建模"></a>数据仓库建模</h2><p>数据仓库最流行的数据模型是多维数据模型，这种模型有三种形式：星形模式（Star schema）、雪花模式（snowflake schema）、事实星座（fact constellation）</p>
<h3 id="星形模式"><a href="#星形模式" class="headerlink" title="星形模式"></a>星形模式</h3><p>最常见的模式，在这种模式下，数据仓库包括：</p>
<ul>
<li>一个大的事实表，里面又包含<ul>
<li>事实的维度</li>
<li>事实的度量</li>
</ul>
</li>
<li>多组小的维表，详细记录一个维度的属性</li>
</ul>
<p>例子如下，展开了很像星光四射，因而得名。<img src="https://res.cloudinary.com/bravey/image/upload/v1573875853/blog/start_schema.jpg" alt=""></p>
<p>最中间的是销售事实表，总共有4个维度：时间、商品、部门（branch）、地点，3个度量：销售数量、销售金额、平均销售量。</p>
<h3 id="雪花模式"><a href="#雪花模式" class="headerlink" title="雪花模式"></a>雪花模式</h3><p>雪花模式是星形模式的变种，其中某些维表被规范化，因而把数据进一步分解到附加的表中。</p>
<p><img src="https://res.cloudinary.com/bravey/image/upload/v1573875852/blog/snowfake_schema.jpg" alt=""></p>
<p>星形模式是只有一层的，而雪花模式可以延伸。图中在item维度又延伸出了供应商这个维度，在地点维度又延伸出了城市这个维度。</p>
<h3 id="事实星座"><a href="#事实星座" class="headerlink" title="事实星座"></a>事实星座</h3><p>对于一些复杂的应用可能需要多个事实表共享维表，这种模式可以看成星形模式的汇集，所以称做事实星座。</p>
<p><img src="https://res.cloudinary.com/bravey/image/upload/v1573875852/blog/fact_schema.jpg" alt=""></p>
<p>上面总共有两个事实表：销售与运输(Shipping)。因为两个事实表有些维度是共享的，所以同时指向相同的维度就可以了。</p>
<h3 id="概念分层"><a href="#概念分层" class="headerlink" title="概念分层"></a>概念分层</h3><p>概念分层(Concept Hierarchy)，对一个维度在概念上进行分层。</p>
<p><img src="https://res.cloudinary.com/bravey/image/upload/v1573875852/blog/location_hierarchy.jpg" alt=""></p>
<p>比如在地点上可以从办公室上升到城市上升到国家一直到最后的最高层所有。每个维度的最高层都是all所有这个级别。上图地点的分层是基于全序的层次结构，也可以组织成基于偏序的格结构，如下对时间的分层。</p>
<p><img src="https://res.cloudinary.com/bravey/image/upload/v1573875851/blog/time_hierarchy.jpg" alt=""></p>
<p>对于连续的属性值或或者维度，通过将其离散化来定义概念分层。</p>
<p><img src="https://res.cloudinary.com/bravey/image/upload/v1573875851/blog/numeric_hierarchy.jpg" alt=""></p>
<h3 id="OLAP操作"><a href="#OLAP操作" class="headerlink" title="OLAP操作"></a>OLAP操作</h3><p>进行实际分析的时候需要执行OLAP操作，典型的有下面四种。</p>
<h4 id="上卷（roll-up）"><a href="#上卷（roll-up）" class="headerlink" title="上卷（roll-up）"></a>上卷（roll-up）</h4><p>上卷操作沿着一个维度的概念分层向上攀升。如下图所示的第1个操作，对location维度从城市上卷到国家，则原来的立方体的location维度从原来有4个城市变成只有两个国家。</p>
<h4 id="下钻（drill-down）"><a href="#下钻（drill-down）" class="headerlink" title="下钻（drill-down）"></a>下钻（drill-down）</h4><p>下钻是上卷的逆操作，它由不太详细的数据到更详细的数据。</p>
<p>比如从第1个上卷的操作得到的数据立方体做从国家到城市的逆操作就回到了原来的数据立方体。第二个操作就是下钻操作，在time维度上从季度下钻到了月。</p>
<h4 id="切片（slice）和切块（dice）"><a href="#切片（slice）和切块（dice）" class="headerlink" title="切片（slice）和切块（dice）"></a>切片（slice）和切块（dice）</h4><p>切片操作在给定的立方体上一个维度上面进行选择，形成一个新的子立方体。比如第3个操作，切边选择了time=Q1，因而得到的子立方体都是在Q1季度上的数据。</p>
<p>切块操作则是在多个维度上进行选择。比如第4个操作就是在location维度选择多伦多与温哥华，而在time维度上选择Q1与Q2季度，而在item维度上选择家庭娱乐与计算机。</p>
<h4 id="转轴（pivot）"><a href="#转轴（pivot）" class="headerlink" title="转轴（pivot）"></a>转轴（pivot）</h4><p>转轴又称作旋转(rotate)，是一种目视操作，移动了数据的视角。比如第5个操作，将原来的item维度在下，location维度在上。旋转后变成了item维度在上，而location维度在下。类似于矩阵的转置。</p>
<p><img src="https://res.cloudinary.com/bravey/image/upload/v1573875851/blog/olap_operation.jpg" alt=""></p>
<h4 id="操作实例"><a href="#操作实例" class="headerlink" title="操作实例"></a>操作实例</h4><p> Starting with the base cuboid [day, doctor, patient],what OLAP operations should be performed in order<br>to list the total fee collected by each doctor in 1999?</p>
<p>首先要求所有的费用，因此对patient维度做上卷操作，上卷到all所有这个层次。然后时间限定在了1999年，因此对day维度做上卷操作，上卷到年这个层次。最后进行切边操作，选择1999年这个年份。</p>
<h2 id="数据仓库实现"><a href="#数据仓库实现" class="headerlink" title="数据仓库实现"></a>数据仓库实现</h2><h3 id="数据立方体的有效计算"><a href="#数据立方体的有效计算" class="headerlink" title="数据立方体的有效计算"></a>数据立方体的有效计算</h3><p>前述的OLAP操作依赖于对数据立方体的计算操作，既是针对不同维度上面的聚合，SQL的术语是分组（group-by）。对于n个维度的数据立方体，不考虑每个维度的概念分层，则总共可以构成的分组（不同维度组合的集合）有$2^n$种。如下所示，一个（city，item，year）的三维数据立方体可以有8种分组方式。</p>
<p>其实不考虑概念分层意味着每个维度可以有最高层all和最低层两个分层。因此如果考虑概念分层，假设有n个维度</p>
<p>，每个维度都有m个分层，则这样来说可有$m^n$个方体。</p>
<p><img src="https://res.cloudinary.com/bravey/image/upload/v1573875850/blog/cube_group_by.jpg" alt=""></p>
<p>为了实现快速返回OLAP的操作，需要提前将这些分组的结果存储下来，这样当指定OLAP操作，直接去访问这些分组就可以了。这种提前计算方体结果的方法，称作<strong>物化（materialization）</strong>但是考虑到概念分层，存储所有的分组结果是不现实的。采用<strong>部分物化（partial materaialiaztion）</strong>预先计算一部分适当的常用的子集。</p>
<h3 id="OLAP索引"><a href="#OLAP索引" class="headerlink" title="OLAP索引"></a>OLAP索引</h3><h4 id="位图索引（bitmap-indexing）"><a href="#位图索引（bitmap-indexing）" class="headerlink" title="位图索引（bitmap indexing）"></a>位图索引（bitmap indexing）</h4><p>在给定属性的位图索引中，属性域中的每个值v，有一个不同的位向量bit vector(即一列值)Bv。如果给定的属性域包含n 个值，则位图索引中每项需要n 位（即，n 位向量）。如果数据表中给定行的属性值为v，则在位图索引的对应行，表示该值的位为1，该行的其它位均为0。可以理解成one hot 编码。</p>
<p><img src="https://res.cloudinary.com/bravey/image/upload/v1573875851/blog/index_map.jpg" alt=""></p>
<p>Region有3种取值，所以3个位向量，也就是对应3列值；Type有2种取值，所以对应2列值。</p>
<h5 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h5><p>优点：与散列和树索引相比，位图索引有优势。对于基数较小的域它特别有用，因为比较、连接、和聚集操作都变成了位算术运算，大大减少了运行时间。由于字符串可以用单个位表示，位图索引大大降低了空间和I/O 开销。对于基数较高的域，使用压缩技术，这种方法可以接受。但是不是很适合。</p>
<p>缺点：因为值域中的每一个可能的值都需要一个位向量来记录，所以当基数较大时，会需要开辟很大的存储空间，因为每一个记录其实只使用到了一位，因此造成了很大的浪费。同时当可取的值连续时无法使用位图来记录。</p>
<h4 id="连接索引"><a href="#连接索引" class="headerlink" title="连接索引"></a>连接索引</h4><p>如果两个关系R(RID,A)和S(B,SID)在属性A和B 上连接，则连接索引记录包含(RID,SID)对，其中RID 和SID 分别为来自R 和S 的记录标识符。</p>
<p><img src="https://res.cloudinary.com/bravey/image/upload/v1573875850/blog/join_index.jpg" alt=""></p>
<p>在左边的销售事实表中有同location和item两个维度的链接，那么就可以有右边3中连接索引。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《数据挖掘概念与技术》第3版 第四章数据仓库与联机分析处理</p>
]]></content>
      <categories>
        <category>数据挖掘</category>
      </categories>
      <tags>
        <tag>课程</tag>
        <tag>国科大</tag>
        <tag>数据仓库</tag>
        <tag>OLAPS</tag>
      </tags>
  </entry>
  <entry>
    <title>Clementine教程</title>
    <url>/2019-11-07-Clementine%E6%95%99%E7%A8%8B.html</url>
    <content><![CDATA[<h1 id="Clementine教程"><a href="#Clementine教程" class="headerlink" title="Clementine教程"></a>Clementine教程</h1><p>数据挖掘课程要求使用这个软件Clementine来进行实验，之前完全没听说过这个软件。网上搜到的资料也比较少，特别是CSDN上面有个博客名字叫做Clementine完整教程，然后内容也是Clementine教程这几个字，把我给惊呆了，这也能写博客？现在实验都已经做完了因此记录下使用方法，希望对其他人能有帮助。</p>
<a id="more"></a>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="页面"><a href="#页面" class="headerlink" title="页面"></a>页面</h3><p>在Clementine软件中只需要简单的像画图一样，把整个数据挖掘的操作流程对应的节点给连接起来就可以使用了。先对页面简单的介绍下，页面如下。</p>
<p><img src="https://res.cloudinary.com/bravey/image/upload/v1573095648/blog/clementine.jpg" alt=""></p>
<p>在最下面的一栏是相对应的各个节点：Favorites中是常用的节点，Sources中是输入的数据节点，Field中是数据的属性设置节点，Modeling中是一些数据挖掘模型节点比如决策树神经网络等模型，Output中是输出节点用来查看数据。</p>
<p>在右上角中的Streams显示整个工作台中的所有Stream，Outputs中是每次运行后得到输出结果，Models中是流程所用到的模型。</p>
<p>数据挖掘的过程可以简单的分为两步：第一步对模型进行训练 第二步对训练好的模型进行使用。而一个完整的数据挖掘流程Stream中在Clementine中需要包含：数据输入节点-&gt;输入属性设置节点-&gt;模型节点-&gt;输出节点。在第一步模型训练中可以不使用输出节点。</p>
<h2 id="数据导入"><a href="#数据导入" class="headerlink" title="数据导入"></a>数据导入</h2><p>在下方节点栏中的Sources中选择Var.file节点，拖到中间的画布。然后双击设置输入数据的文件导入，如下所示：<br><img src="https://res.cloudinary.com/bravey/image/upload/v1573097265/blog/varfile1.jpg" alt=""></p>
<p>在导入数据后选择分隔符我的数据是用tab分割的)，之后点击Apply完成设置。</p>
<h2 id="数据显示"><a href="#数据显示" class="headerlink" title="数据显示"></a>数据显示</h2><p>在导入了数据后可以使用输出节点来输出数据，选择Outputs中的Table节点来输出数据。如下所示：</p>
<p><img src="C:\Users\BraveY\AppData\Local\Temp\1573097747688.png" alt=""></p>
<p>对输入节点训练集.txt邮件有个connect可以进行连接。或者使用快捷键F2来连接。连接好后右键execute就可以得到上图显示了。</p>
<h2 id="模型训练"><a href="#模型训练" class="headerlink" title="模型训练"></a>模型训练</h2><p>以使用决策树模型为例子，给定的输入数据集是一个在线测试系统中学生做的各项测试的数据，final是期末考试是否及格。也就是通过学生在测试系统的数据，来预测学生期末考试是否会及格。在选择模型前，需要在Fidel Ops中选择一个type节点来设置输入数据中各个属性。如下所示：</p>
<p><img src="https://res.cloudinary.com/bravey/image/upload/v1573098328/blog/type.jpg" alt=""></p>
<p>第一个PersonId设置为Typeless不进行输入，决策树输出的是final，并设置为flag类型。其他数据都设置为range。</p>
<p>接下来选择模型，在Modeling中选择C5.0这个决策树模型。并与前面的type节点连接。如下所示：</p>
<p><img src="https://res.cloudinary.com/bravey/image/upload/v1573098962/blog/train_tree.jpg" alt=""></p>
<p>可以选择专家模式自定义剪枝率等参数。设置好后执行就可以得到训练好的模型了，将会显示在右上角的model中，这样就完成模型训练这个Stream了。</p>
<p>在右上角的models中选择训练好的final模型，右键browse，然后选择viewer就可以查看训练好的决策树模型了。如下所示。</p>
<p><img src="https://res.cloudinary.com/bravey/image/upload/v1573099406/blog/model.jpg" alt=""><br><img src="https://res.cloudinary.com/bravey/image/upload/v1573099392/blog/viewer.jpg" alt=""></p>
<h2 id="模型使用"><a href="#模型使用" class="headerlink" title="模型使用"></a>模型使用</h2><p>同样导入数据节点验证集.txt，设置好type节点(测试集的flag属性也设置为输入了)，再把训练好的模型从右上角给拖进来，最后设置输出节点。整个流程与前述相同，得到的验证流程如下：<br><img src="https://res.cloudinary.com/bravey/image/upload/v1573099826/blog/test_stream.jpg" alt=""><br>输出节点使用混淆矩阵来查看模型的准确性，具体设置为：<br><img src="https://res.cloudinary.com/bravey/image/upload/v1573099827/blog/confuse_matrix.jpg" alt=""><br>最后执行就可以得到最终的显示了如下：<br><img src="https://res.cloudinary.com/bravey/image/upload/v1573099826/blog/matrix_out.jpg" alt=""></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其他模型比如神经网络等的使用流程大同小异，如果需要数据集与测试集以及英文教程可以联系我。</p>
]]></content>
      <categories>
        <category>数据挖掘</category>
      </categories>
      <tags>
        <tag>Clementine</tag>
      </tags>
  </entry>
  <entry>
    <title>内嵌汇编</title>
    <url>/2019-10-31-%E5%86%85%E5%B5%8C%E6%B1%87%E7%BC%96.html</url>
    <content><![CDATA[<h1 id="内嵌汇编"><a href="#内嵌汇编" class="headerlink" title="内嵌汇编"></a>内嵌汇编</h1><p>操作系统高级教程上面需要阅读Linux内核0.11的源码，其中在书《Linux内核设计的一书》第2.5节异常处理类中段服务程序挂接的部分，遇到了嵌入在C语言中的汇编代码，之前从来没有学习过汇编，因此记录下。</p>
<a id="more"></a>
<h2 id="AT-amp-T基础知识"><a href="#AT-amp-T基础知识" class="headerlink" title="AT&amp;T基础知识"></a>AT&amp;T基础知识</h2><p>内嵌汇编使用的是AT&amp;T汇编，所以首先稍微讲解下AT&amp;T的汇编指令的基础知识。</p>
<h3 id="操作数前缀"><a href="#操作数前缀" class="headerlink" title="操作数前缀"></a>操作数前缀</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">movl   $8,%eax </span><br><span class="line">movl   $0xffff,%ebx </span><br><span class="line">int     $0x80</span><br></pre></td></tr></table></figure>
<p>看到在AT%T汇编中诸如”%eax”、”%ebx”之类的寄存器名字前都要加上”%”；”$8”、”$0xffff”这样的立即数之前都要加上”$”。  </p>
<h3 id="源-目的操作数顺序"><a href="#源-目的操作数顺序" class="headerlink" title="源/目的操作数顺序"></a>源/目的操作数顺序</h3><p>   在Intel语法中，第一个操作数是目的操作数，第二个操作数源操作数。而在AT&amp;T中，第一个数是源操作数，第二个数是目的操作数。 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// INTEL语法</span><br><span class="line">MOV EAX,8 //EAX是目的操作数， 8是源操作数</span><br><span class="line">// AT&amp;T语法</span><br><span class="line">movl   $8,%eax //8是源操作数 EAX是目的操作数</span><br></pre></td></tr></table></figure>
<h3 id="标识长度的操作码后缀"><a href="#标识长度的操作码后缀" class="headerlink" title="标识长度的操作码后缀"></a>标识长度的操作码后缀</h3><p>在AT&amp;T的操作码后面有时还会有一个后缀，其含义就是指出操作码的大小。“l”表示长整数（32位），“w”表示字（16位），“b”表示字节（8位）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">movb    %bl,%al</span><br><span class="line">movw   %bx,%ax</span><br><span class="line">movl     %ebx,%eax</span><br><span class="line">movl     (%ebx),%eax</span><br></pre></td></tr></table></figure>
<h2 id="GCC内嵌汇编"><a href="#GCC内嵌汇编" class="headerlink" title="GCC内嵌汇编"></a>GCC内嵌汇编</h2><p>Linux操作系统内核代码绝大部分使用C语言编写，只有一小部分使用汇编语言编写，例如与特定体系结构相关的代码和对性能影响很大的代码。GCC提供了内嵌汇编的功能，可以在C代码中直接内嵌汇编语言语句，大大方便了程序设计。 </p>
<h3 id="基本行内汇编"><a href="#基本行内汇编" class="headerlink" title="基本行内汇编"></a>基本行内汇编</h3><p>基本行内汇编很容易理解，一般是按照下面的格式：</p>
  <figure class="highlight plain"><figcaption><span>```</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">在“asm”后面有时也会加上“__volatile__”表示编译器不要优化代码，后面的指令保留原样 </span><br><span class="line"></span><br><span class="line"> ```__asm__  __volatile__(&quot;hlt&quot;);``` </span><br><span class="line"></span><br><span class="line">如果有很多行汇编，则每一行后要加上“\n\t” ：</span><br><span class="line"></span><br><span class="line">```assembly</span><br><span class="line"> asm( &quot;pushl %eax\n\t&quot;</span><br><span class="line"> &quot;movl $0,%eax\n\t&quot;</span><br><span class="line">&quot;popl %eax&quot;);</span><br></pre></td></tr></table></figure>
<p>或者我们也可以分成几行来写，如： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">asm(&quot;movl %eax,%ebx&quot;);</span><br><span class="line">asm(&quot;xorl %ebx,%edx&quot;);</span><br><span class="line">asm(&quot;movl $0,_booga);</span><br></pre></td></tr></table></figure>
<p>通常使用汇编语句最方便的方式是把它们放在一个宏内，而宏语句需要在一行上定义，因此使用反斜杠<code>\</code>将这些语句连成一行，所以上述语句如果在宏中定义的话就是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">asm</span>( <span class="string">"pushl %eax; \</span></span><br><span class="line"><span class="string"> movl $0,%eax; \</span></span><br><span class="line"><span class="string">popl %eax"</span>);</span><br></pre></td></tr></table></figure>
<h3 id="扩展的行内汇编"><a href="#扩展的行内汇编" class="headerlink" title="扩展的行内汇编"></a>扩展的行内汇编</h3><p>在扩展的行内汇编中，可以将C语言表达式（比如C语言中的变量）指定为汇编指令的操作数，而且不用去管如何将C语言表达式的值读入寄存器，以及如何将计算结果写回C变量，你只要告诉程序中C语言表达式与汇编指令操作数之间的对应关系即可， GCC会自动插入代码完成必要的操作。 </p>
<p>使用内嵌汇编，要先编写汇编指令模板，然后将C语言表达式与指令的操作数相关联，并告诉GCC对这些操作有哪些限制条件。例如下面的内嵌汇编语句： </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> input = <span class="number">8</span>;</span><br><span class="line">	<span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    __asm__ __violate__  (<span class="string">"movl %1,%0"</span> : <span class="string">"=r"</span> (result) : <span class="string">"r"</span> (input));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,result);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>“movl %1,%0”</code>是指令模板；“%0”和“%1”代表指令的操作数，称为占位符，“=r”代表它之后是输入变量且需用到寄存器，指令模板后面用小括号括起来的是C语言表达式 ，其中input是输入变量，该指令会完成把input的值复制到result中的操作 。</p>
<h3 id="扩展的行内汇编的语法"><a href="#扩展的行内汇编的语法" class="headerlink" title="扩展的行内汇编的语法"></a>扩展的行内汇编的语法</h3><p>内嵌汇编语法如下：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">asm(&quot;汇编语句模块&quot;</span><br><span class="line"></span><br><span class="line">     :输出寄存器 </span><br><span class="line"></span><br><span class="line">     :输入寄存器 </span><br><span class="line"></span><br><span class="line">     :会被修改的寄存器);</span><br></pre></td></tr></table></figure>
<p>即格式为<code>asm ( &quot;statements&quot; : output_regs : input_regs : clobbered_regs)</code></p>
<p>汇编语句模块必不可少，其他三部分可选，如果使用了后面的部分，而前面部分为空，也需要用“:”格开，相应部分内容为空。 </p>
<h4 id="汇编语句模块"><a href="#汇编语句模块" class="headerlink" title="汇编语句模块"></a>汇编语句模块</h4><p>汇编语句模块由汇编语句序列组成，语句之间使用“;”、“\n”或“\n\t”分开。指令中的操作数可以使用占位符引用C语言变量，<strong>操作数占位符</strong>最多10个，名称如下：%0，%1…，%9。指令中使用占位符表示的操作数，总被视为long型（4，个字节），但对其施加的操作根据指令可以是字或者字节，当把操作数当作字或者字节使用时，默认为低字或者低字节。对字节操作可以显式的指明是低字节还是次字节。方法是在%和序号之间插入一个字母，“b”代表低字节，“h”代表高字节，例如：%h1。 </p>
<p>占位符的理解：将汇编输出寄存器与输入寄存器从输出寄存器行开始左到右从上到下进行编号分别为：%0，%1…，%9。比如有代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define get_seg_byte(seg,addr) \</span><br><span class="line">(&#123; \</span><br><span class="line">register char __res; \</span><br><span class="line">__asm__(&quot;push %%fs; \</span><br><span class="line">mov %%ax,%%fs; \</span><br><span class="line">movb %%fs:%2,%%al; \</span><br><span class="line">pop %%fs&quot; \</span><br><span class="line">:&quot;=a&quot; (__res) \</span><br><span class="line">:&quot;&quot; (seg),&quot;m&quot; (*(addr))); \</span><br><span class="line">__res;&#125;)</span><br></pre></td></tr></table></figure>
<p>输出寄存器”=a”eax记为%0,输入寄存器””(依然是eax)记为%1,输入寄存器”m”为%2。</p>
<h4 id="输出寄存器"><a href="#输出寄存器" class="headerlink" title="输出寄存器"></a>输出寄存器</h4><p>描述输出操作数，不同的操作数描述符之间用逗号格开，每个操作数描述符由<strong>限定字符串和C语言变量</strong>组成。每个<strong>输出操作数的限定字符串必须包含“=”</strong>，表示它是一个输出操作数。例如：</p>
<figure class="highlight plain"><figcaption><span>__volatile__ ("pushfl ; popl %0 ; cli":"</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">在这里“x”便是最终存放输出结果的C程序变量，而“=g”则是限定字符串，限定字符串表示了对它之后的变量的限制条件 。</span><br><span class="line"></span><br><span class="line">#### 输入寄存器</span><br><span class="line"></span><br><span class="line">描述输入操作数，不同的操作数描述符之间使用逗号格开，每个操作数描述符同样也由限定字符串和C语言表达式或者C语言变量组成。例：</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">__asm__ volatile__ (&quot;lidt %0&quot; : : &quot;m&quot; (real_mode_idt));</span><br></pre></td></tr></table></figure>
<p>其中%0是占位操作符，而输出寄存器为空，输入寄存器的值为C语言表达式real_mode_idt。</p>
<h4 id="限定字符串"><a href="#限定字符串" class="headerlink" title="限定字符串"></a>限定字符串</h4><p>又叫做寄存器加载代码</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>限定字符</th>
<th>描述</th>
<th>限定字符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>a</td>
<td>使用寄存器eax</td>
<td>m</td>
<td>使用内存地址</td>
</tr>
<tr>
<td>b</td>
<td>使用寄存器ebx</td>
<td>o</td>
<td>使用内存地址并可以加偏移值</td>
</tr>
<tr>
<td>m、o、V、p</td>
<td>使用寄存器ecx</td>
<td>I</td>
<td>使用常数0~31 立即数</td>
</tr>
<tr>
<td>g、X</td>
<td>寄存器或内存</td>
<td>J</td>
<td>使用常数0~63 立即数</td>
</tr>
<tr>
<td>I、J、N、i、n</td>
<td>立即数</td>
<td>K</td>
<td>使用常数0~255立即数</td>
</tr>
<tr>
<td>D</td>
<td>使用edi</td>
<td>L</td>
<td>使用常数0~65535 立即数</td>
</tr>
<tr>
<td>q</td>
<td>使用动态分配字节可寻址寄存器（eax、ebx、ecx或edx）</td>
<td>M</td>
<td>使用常数0~3  立即数</td>
</tr>
<tr>
<td>r</td>
<td>使用任意动态分配的寄存器</td>
<td>N</td>
<td>使用1字节常数（0~255）立即数</td>
</tr>
<tr>
<td>g</td>
<td>使用通用有效的地址即可（eax、ebx、ecx、edx或内存变量）</td>
<td>O</td>
<td>使用常数0~31 立即数</td>
</tr>
<tr>
<td>A</td>
<td>使用eax与edx联合（64位）</td>
<td>i</td>
<td>立即数</td>
</tr>
</tbody>
</table>
</div>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>直接摘抄自《Linux内核完全注释》第5.2.2 traps.c程序的第82页</p>
<ul>
<li>例子1：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">01 #define get_seg_byte(seg,addr) \</span><br><span class="line">02 (&#123; \</span><br><span class="line">03 register char __res; \</span><br><span class="line">04 __asm__(&quot;push %%fs; \</span><br><span class="line">05 mov %%ax,%%fs; \</span><br><span class="line">06 movb %%fs:%2,%%al; \</span><br><span class="line">07 pop %%fs&quot; \</span><br><span class="line">08 :&quot;=a&quot; (__res) \</span><br><span class="line">09 :&quot;&quot; (seg),&quot;m&quot; (*(addr))); \</span><br><span class="line">10 __res;&#125;)</span><br></pre></td></tr></table></figure>
<p> 第1 行定义了宏的名称，也即是宏函数名称 <code>get_seg_byte(seg,addr)</code> 。第 3 行定义了一个寄存器变量 res 。第 4 行上的 <code>__asm__</code>表示嵌入汇编语句的开始。从第 4 行到第 7 行的 4 条语句是 AT&amp;T 格式的汇编语句。</p>
<p>第 8 行即是输出寄存器，这句的含义是在这段代码运行结束后将 eax 所代表的寄存器的值放入<code>__res</code>变量中，作为本函数的输出值， “=a” 中的 “a” 称为加载代码， “=” 表示这是输出寄存器。第 9 行表示在这段代码开始运行时将 seg 放到 eax 寄存器中， “” 表示使用与上面同个位置的输出相同的寄存器。而 (<em>(addr))表示一个内存偏移地址值。为了在上面汇编语句中使用该地址值，嵌入汇编程序规定把输出和输入寄存器统一按顺序编号，顺序是从输出寄存器序列从左到右从上到下以 “%0” 开始，分别记为 %0 、 %1 、 …%9 。因此，输出寄存器的编号是 %0 （这里只有一个输出寄存器），输入寄存器前一部分 (“” (seg)) 的编号是 %1 ，而后部分的编号是 %2 。上面第 6 行上的 %2 即代表 (</em>(addr)) 这个内存偏移量。现在我们来研究 4—7 行上的代码的作用。第一句将 fs 段寄存器的内容入栈；第二句将 eax 中的段值赋给 fs 段寄存器；第三句是把 fs:(*(addr)) 所指定的字节放入 al 寄存器中。当执行完汇编语句后，输出寄存器 eax 的值将被放入 <code>__res</code> ，作为该宏函数（块结构表达式）的返回值。</p>
<p>通过上面分析，我们知道，宏名称中的 seg 代表一指定的内存段值，而 addr 表示一内存偏移地址量。到现在为止，我们应该很清楚这段程序的功能了吧！该宏函数的功能是从指定段和偏移值的内存地址处取一个字节。</p>
<p>通过上面的例子说明，阅读这段代码时应该像CPU处理指令时的逻辑一样，先从输出输入寄存器语句开始知道输入输出是什么，然后再阅读汇编语句，处理完后再看最后的返回是什么。</p>
<ul>
<li>例子2</li>
</ul>
<p>再来看下Linux 内核中main()中对中断异常挂接的trap_init()中的设计到的一个GCC内嵌汇编。代码路径为；include\asm\system.h</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 #define _set_gate(gate_addr,type,dpl,addr) \</span><br><span class="line">2 __asm__ (&quot;movw %%dx,%%ax\n\t&quot; \</span><br><span class="line">3	&quot;movw %0,%%dx\n\t&quot; \</span><br><span class="line">4	&quot;movl %%eax,%1\n\t&quot; \</span><br><span class="line">5	&quot;movl %%edx,%2&quot; \</span><br><span class="line">6	: \</span><br><span class="line">7	: &quot;i&quot; ((short) (0x8000+(dpl&lt;&lt;13)+(type&lt;&lt;8))), \</span><br><span class="line">8	&quot;o&quot; (*((char *) (gate_addr))), \</span><br><span class="line">9	&quot;o&quot; (*(4+(char *) (gate_addr))), \</span><br><span class="line">10	&quot;d&quot; ((char *) (addr)),&quot;a&quot; (0x00080000))</span><br></pre></td></tr></table></figure>
<p>首先从第6行输出寄存器开始阅读：输出寄存器为空。然后是第7至10行的输入寄存器。第%0个输入寄存器使用“i”表示输入立即数，第%1个输入寄存器使用“o”表示使用内存地址并可以加偏移值，第%2个输入寄存器依然使用“o”代码，第%3个寄存器使用“d”表示使用寄存器edx，第%4个寄存器使用“a”表示使用寄存器eax。</p>
<p>之后再看下汇编语句：依次进行值得传递。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《Linux内核设计的艺术》新设计团队 著</p>
<p>《Linux内核完全注释》赵炯 编著</p>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>汇编</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>数组中的主要元素</title>
    <url>/2019-10-14-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E4%B8%BB%E8%A6%81%E5%85%83%E7%B4%A0.html</url>
    <content><![CDATA[<h1 id="数组中的主要元素"><a href="#数组中的主要元素" class="headerlink" title="数组中的主要元素"></a>数组中的主要元素</h1><p>leetcode#169题，找出一个数组中出现次数超过$\lfloor \dfrac{n}{2}\rfloor$ 次数的元素，也就是过半的主要元素。题目来源：</p>
<p><a href="https://leetcode.com/problems/majority-element/" target="_blank" rel="noopener">https://leetcode.com/problems/majority-element/</a> </p>
<a id="more"></a>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p>遍历一次数组然后将每个元素出现的次数放在哈希表中，key是元素，value是出现的次数。然后输出哈希表中值大于$\lfloor \dfrac{n}{2}\rfloor$ 的元素。</p>
<h4 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h4><p>遍历数组的时间复杂度为O(n)，新建一个哈希表造成的空间复杂度为O(n)。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p>第一个是自己写的,输入是为了自己调试和算法课程作业的UOJ，这个OJ有个卡内存的坑后面讲。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.size(); i++)&#123;</span><br><span class="line">            m[nums[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> major = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator it= m.begin(); it!=m.end(); it++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(it-&gt;second&gt;=max)&#123;</span><br><span class="line">                max = it-&gt;second;</span><br><span class="line">                major = it-&gt;first;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> major;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Solution sol;</span></span><br><span class="line">    <span class="comment">// std::vector&lt;int&gt; vec=&#123;3,2,3&#125;;</span></span><br><span class="line">    <span class="comment">// int ans = sol.majorityElement(vec);</span></span><br><span class="line">    <span class="comment">// cout&lt;&lt;ans&lt;&lt;endl;</span></span><br><span class="line">    <span class="comment">// cin&gt;&gt;ans;</span></span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    Solution Sol;</span><br><span class="line">    <span class="keyword">int</span> ans;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;len)&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec(len);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;vec[i];</span><br><span class="line">        &#125;</span><br><span class="line">        ans = Sol.majorityElement(vec);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后再来看看花花大神写的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Author: Huahua</span></span><br><span class="line"><span class="comment">// Runtime : 23 ms</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; count;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">int</span> num : nums)</span><br><span class="line">            <span class="keyword">if</span> (++count[num] &gt; n / <span class="number">2</span>) <span class="keyword">return</span> num;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我自己写的代码多了一步冗余操作，就是完整的把count哈希表给建立完毕之后又多次一举的进行遍历寻找最大值。实际上在对原来的数组进行遍历的同时一定会出现主要元素的计数大于$\lfloor \dfrac{n}{2}\rfloor$，这个时候直接返回就可以了。</p>
<h3 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h3><p>首先考虑最简单的情况，当n=1的时候，这个唯一的元素就是主要元素，这是一个最简单的子问题。那么是否所有自问都能正确返回主要元素呢？很明显当n=2的时候，如果A[0]!=A[1]，这个时候A是没有主要元素的。因为如果使用分治的话，子问题一定要有一个解得，所以当出现两个子问题的主要元素不一致的时候，如何来得到原问题的解呢？这时只能通过遍历，统计两个子问题对应的主要元素在更大的局部中出现的次数来解决。如果左边的主要元素在原问题的数组中出现的次数大于右边的主要元素那么答案就是左边的主要元素，否则的话就是右边的元素（需要注意的是返回右边的时候是包含右边的主要元素次数等于左边的情况，不过无所谓，因为后面的上一层还是要遍历统计的）。总结一下：</p>
<p><strong>Divide</strong> 将输入数组A划分为左边A[0, n/2] 与右边A[n/2+1, n-1]两个数组</p>
<p><strong>Conquer</strong> 左边的主要元素与右边的主要元素分别再各自递归的调用函数求解。</p>
<p><strong>Merge</strong> 如果左边与右边的主要元素相等，那么就直接返回这个主要元素。如果不等那就统计这两个主要元素在A中的出现次数，然后返回较大的那个，次数相等的话左右两个主要元素随便返回其中一个。</p>
<h4 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h4><p>根据上面的思路可以写出递推式：首先是考虑最好的情况:就是每次都有左右两个子数组的主要元素相同，不需要判别，此时有递推公式：</p>
<script type="math/tex; mode=display">
\begin{equation}\nonumber
\begin{split}
T(n)&=2T[{\lfloor\frac{n}{2}\rfloor]+Cn}\\\\
&=2^2T[{\lfloor\frac{n}{2^2}\rfloor]+C+2C}\\\\
&=2^3T[{\lfloor\frac{n}{2^3}\rfloor]+C+2C+2C}\\\\
\dots\\\\
&=2^kT[{\lfloor\frac{n}{2^k}\rfloor]+(2k-1)C}\\\\
\end{split} 
\end{equation}</script><p>每次分解后规模变为左右两个子树，因此下降到$\lfloor\frac{n}{2}\rfloor$,而每次比较左右两个子树最大深度与更新最大路径长度所需的时间为常数C。设当第k次的时候下降到规模为1的叶子节点，因此有$\frac{n}{2^k}=1$推出$k=\log_2n$所以有$T(n)=n+(2\log_2n-1)C=O(n)$,所以时间复杂度为O(n)。</p>
<p>考虑最坏的情况：每次都需要重新遍历来确定主要元素，也就是递归树中的每一层都需要遍历数组也就是O(n)的成本。所以有递推公式</p>
<script type="math/tex; mode=display">
T(n)=2T[{\lfloor\frac{n}{2}\rfloor]+Cn}</script><p>根据主定理可以得出算法的最坏时间复杂度为$O(nlogn)$</p>
<p>空间复杂度因为可以使用左右的索引来进行划分，不需要额外的空间所以是O(1)。</p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dc_majority</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;vec, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lo&gt;=hi) <span class="keyword">return</span> vec[lo];</span><br><span class="line">        <span class="keyword">int</span> mid = lo + (hi-lo)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> l_ans = dc_majority(vec, lo, mid);</span><br><span class="line">        <span class="keyword">int</span> r_ans = dc_majority(vec, mid+<span class="number">1</span>, hi);</span><br><span class="line">        <span class="keyword">if</span>(l_ans==r_ans) <span class="keyword">return</span> l_ans;</span><br><span class="line">        <span class="keyword">int</span> l_ans_nums=<span class="number">0</span>, r_ans_nums = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=lo; i&lt;=hi; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(vec[i]==l_ans) l_ans_nums++;</span><br><span class="line">            <span class="keyword">if</span>(vec[i]==r_ans) r_ans_nums++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l_ans_nums&gt;r_ans_nums ? l_ans : r_ans;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> major=dc_majority(nums, <span class="number">0</span>, nums.size()<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> major;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Solution sol;</span></span><br><span class="line">    <span class="comment">// std::vector&lt;int&gt; vec=&#123;3,2,3&#125;;</span></span><br><span class="line">    <span class="comment">// int ans = sol.majorityElement(vec);</span></span><br><span class="line">    <span class="comment">// cout&lt;&lt;ans&lt;&lt;endl;</span></span><br><span class="line">    <span class="comment">// cin&gt;&gt;ans;</span></span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    Solution Sol;</span><br><span class="line">    <span class="keyword">int</span> ans;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;len)&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec(len);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;vec[i];</span><br><span class="line">        &#125;</span><br><span class="line">        ans = Sol.majorityElement(vec);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="摩尔投票"><a href="#摩尔投票" class="headerlink" title="摩尔投票"></a>摩尔投票</h3><p>每次从数组中删除一对不同的元素，按照题意到最后一定会剩下至少一个元素（假设每次不同的元素都是由一个主要元素和非主要元素组成的，这样的话最终仍然剩下主要元素，假设每次不同的元素都是非主要元素构成，最后肯定也会剩下多余的主要元素。也可以理解成捉对厮杀，因为主要元素的占比超过一半，其他非主要元素小于一半，所以最后一相减一定有主要元素剩下。）</p>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><p>直接用的花花大神的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> majority = nums.front();</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num == majority) ++count;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (--count == <span class="number">0</span>) &#123;</span><br><span class="line">                count = <span class="number">1</span>;</span><br><span class="line">                majority = num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> majority;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="复杂度-2"><a href="#复杂度-2" class="headerlink" title="复杂度"></a>复杂度</h4><p>根据代码分析很容易得出时间复杂度为O(n), 空间复杂度为O(1)。</p>
<h2 id="OJ的输入"><a href="#OJ的输入" class="headerlink" title="OJ的输入"></a>OJ的输入</h2><p>这道题最开始是在UOJ上面的课程作业，我最开始做的时候不管怎么调，用什么方法，包括摩尔投票都会爆内存超过限制，后面分析出来的原因是：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Solution Sol;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">	<span class="keyword">int</span> n ;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n)&#123;</span><br><span class="line">		<span class="comment">//int tmp = n;</span></span><br><span class="line">		<span class="keyword">int</span> element;</span><br><span class="line">		<span class="keyword">while</span>(n--)&#123;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;element;</span><br><span class="line">			vec.push_back(element);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;Sol.majorityElement(vec)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我的输入是用push_back()来输入进vector中的，而vector的内存是动态申请的，不足的话会申请原来的两倍，所以造成了内存超过限制的原因，比如只需要11m的，假设上一次的vector申请到的是10m，所以下次就申请了20m造成了内存超过限制。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://zxi.mytechroad.com/blog/divide-and-conquer/leetcode-169-majority-element/" target="_blank" rel="noopener">http://zxi.mytechroad.com/blog/divide-and-conquer/leetcode-169-majority-element/</a> </p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>分治</tag>
        <tag>哈希</tag>
        <tag>摩尔投票</tag>
      </tags>
  </entry>
  <entry>
    <title>逆序对的计数</title>
    <url>/2019-10-07-%E9%80%86%E5%BA%8F%E5%AF%B9%E7%9A%84%E8%AE%A1%E6%95%B0.html</url>
    <content><![CDATA[<h1 id="逆序对的计数"><a href="#逆序对的计数" class="headerlink" title="逆序对的计数"></a>逆序对的计数</h1><p>leetcode#493题，给定一个数组A，寻找i<j，但是有a[i]>A[j]的数目。变种为重要逆序对的寻找即寻找A[i]&gt;kA[j]的数目。</j，但是有a[i]></p>
<p>题目来源：<a href="https://leetcode.com/problems/reverse-pairs/" target="_blank" rel="noopener">https://leetcode.com/problems/reverse-pairs/</a></p>
<a id="more"></a>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>基本的逆序对与重要逆序对思路一致，因此只对逆序对进行讲解。</p>
<h3 id="暴力枚举"><a href="#暴力枚举" class="headerlink" title="暴力枚举"></a>暴力枚举</h3><p>从前往后遍历数组，枚举出所有(A[i],A[j])，然后统计符合条件的重要逆序对的数目，很明显所需要的时间复杂度为</p>
<p>$O(n^2)$</p>
<h3 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h3><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>先考虑最简单的情况：</p>
<p>如果input的数组长度为n=1，则输出为0，不存在逆序对。会做</p>
<p>n=2的时候，可以分解成两个n=1的情况。因为左右两边都是一个元素自然都不存在逆序对，考虑一个元素在左边，一个在右边的情况可以得出(8,4)一个逆序对的情况，所以输出为1。会做</p>
<p>n=4的时候：同样的可以分解成两个n=2的情况，因为我们已经解决了n=2的问题。这时候左边数组存在一个(8,4)的逆序对，右边数组存在一个(3,2)的逆序对。这时候主要考虑的是交叉的情况，如果左右两个数组都是没有结构的，那么只能用两个指针来挨个遍历左右两边的数组了时间复杂度为$O(n^2)$ 。如果左右两边数组都是有序的情况下，就可以减少很多冗余的比较操作了，当$L_i&gt;R_j$ 时，左边数组位于$L_i$ 后面的元素肯定都会大于$R_j$ ，因此就不用在比较$L_i$ 后面的元素了,将右边数组指针+1寻找更大的元素来进行比较。当$L_i&lt;R_j$时，需要将左边的指针+1，寻找一个更大的左边元素进行比较。因为左右指针总共的移动次数不超过数组长度，所以这时的复杂度为$O(n)$。以图中的例子来说明，当有4大于3的时候，就不需要比较8是否大于3了。</p>
<p>一个形象的比喻是两个人打牌，一个人L拿的是左边的数组，另一个人R是右边的数组，牌已经从小到大整理好了。如果L最小的牌比R的最小的牌都大，那么L手中所有的牌都比R的最小的牌大。R要找到比L当前牌更大的牌只能向后寻找，如果找不到说明，L所有的牌都比R大，如果找到了是$R_j$那么L就向后面再找一个新的比$R_j$的牌大的新牌$L_i$ 。规则就是从左到右出牌，牌小的先出，最后谁的牌出完那么游戏结束，结束逆序对的统计。</p>
<p><img src="https://res.cloudinary.com/bravey/image/upload/v1570434502/blog/reversepairs.jpg" alt=""></p>
<h4 id="归纳"><a href="#归纳" class="headerlink" title="归纳"></a>归纳</h4><p>可以看到，在上述分析过程中我们可以将输入为n的数组不断划分为原来的一半直至最后n=1的情况，从n=1的情况再向上合并得到上层问题的答案，也就是归并排序的过程中加上了逆序对的统计，这是一个很典型的分治策略。</p>
<p><strong>Divide</strong> 将输入数组A划分为左边A[0, n/2] 与右边A[n/2+1, n-1]两个数组</p>
<p><strong>Conquer</strong> 左边的逆序对数目与右边的逆序对数目分别再各自递归的调用函数求解，同时对其排序。</p>
<p><strong>Merge</strong> 统计逆序对元素交叉在左右两边的情况，并将两个排好序的子数组合并成一个新的有序数组</p>
<h4 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h4><p>将规模为n的问题分解成两个两个$\frac{n}{2}$ 的子问题问题，同时对两个子问题进行合并的复杂度为O(n)，所以有递推公式：</p>
<script type="math/tex; mode=display">
T(n)=\left\{
  \begin{array}{**lr**}  
             1 &  n=1\\\\  
             2T(\frac{n}{2})+O(n)
             \end{array}  
\right.</script><p>根据主定理有最后的复杂度为$O(n\log(n))$</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">https://leetcode.com/problems/reverse-pairs/</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp_vec;<span class="comment">//把tmp_vec设置成共有变量，而不在函数中设置为临时变量可以减少多次对其创建与销毁，提高效率</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reversePairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">int</span> size = nums.size();</span><br><span class="line">    	tmp_vec.resize(nums.size());</span><br><span class="line">        <span class="keyword">return</span> MergeSort(nums, <span class="number">0</span>, size<span class="number">-1</span>); <span class="comment">// 不用全局变量否则，多线程的时候会被修改。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">MergeSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(lo&gt;=hi) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">// base case 递归必备</span></span><br><span class="line">		<span class="keyword">int</span> mid = lo + (hi -lo)/<span class="number">2</span>; <span class="comment">//防止两个超级大的int相加后造成溢出</span></span><br><span class="line">		<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">		ans += MergeSort(vec, lo, mid); <span class="comment">//左边merge的计数</span></span><br><span class="line">		ans += MergeSort(vec, mid+<span class="number">1</span>, hi); <span class="comment">//右边merge的计数</span></span><br><span class="line">		ans += Merge(vec, lo, hi, mid);<span class="comment">// 返回什么？ 本次merge的技术 也就是split 的情况</span></span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">Merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi, <span class="keyword">int</span> mid)</span></span>&#123; <span class="comment">//采用双指针来一次把左右两边的小值冒泡出来放到合并后的数组中，同时完成对逆序数目的统计</span></span><br><span class="line">		<span class="keyword">int</span> p = lo;</span><br><span class="line">		<span class="keyword">int</span> q = mid + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">int</span> count = <span class="number">0</span>;<span class="comment">//记录逆序数目</span></span><br><span class="line">		<span class="keyword">int</span> index = lo;</span><br><span class="line">		<span class="keyword">while</span>(p&lt;=mid&amp;&amp;q&lt;=hi)&#123;</span><br><span class="line">			<span class="keyword">if</span>((<span class="keyword">long</span>)vec[p] &gt; (<span class="keyword">long</span>)vec[q]*<span class="number">3</span>)&#123;</span><br><span class="line">				count += mid-p+<span class="number">1</span>;</span><br><span class="line">				q++;</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				p++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//正常的merge操作</span></span><br><span class="line">		p = lo ;</span><br><span class="line">		q = mid + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span>(p&lt;=mid&amp;&amp;q&lt;=hi)&#123;</span><br><span class="line">			<span class="keyword">if</span>(vec[p]&gt;=vec[q]) tmp_vec[index++]=vec[q++];</span><br><span class="line">			<span class="keyword">else</span> tmp_vec[index++]=vec[p++];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span>(p&lt;=mid) tmp_vec[index++]=vec[p++];</span><br><span class="line">		<span class="keyword">while</span>(q&lt;=hi) tmp_vec[index++]=vec[q++];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=lo; i&lt;=hi; i++)&#123;</span><br><span class="line">			vec[i] = tmp_vec[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> count;</span><br><span class="line">	&#125;    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Solution Sol;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">	<span class="keyword">int</span> n ;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n)&#123;</span><br><span class="line">		<span class="comment">//int tmp = n;</span></span><br><span class="line">		<span class="keyword">int</span> element;</span><br><span class="line">		<span class="keyword">while</span>(n--)&#123;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;element;</span><br><span class="line">			vec.push_back(element);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;Sol.reversePairs(vec)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>归并排序</tag>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title>数组中的第K大的数</title>
    <url>/2019-09-19-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E5%A4%A7%E7%9A%84%E6%95%B0.html</url>
    <content><![CDATA[<h1 id="数组中的第K大的数"><a href="#数组中的第K大的数" class="headerlink" title="数组中的第K大的数"></a>数组中的第K大的数</h1><p>leetcode#215题，给定一个数组，要求找出其第K大的个数。</p>
<a id="more"></a>
<p>题目来源：</p>
<p><a href="https://leetcode.com/problems/kth-largest-element-in-an-array/" target="_blank" rel="noopener">https://leetcode.com/problems/kth-largest-element-in-an-array/</a> </p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>简单：（1）通过对数组排序后可以直接对升序排序后的数组返回下标为len-k（降序就直接返回下标为k）。(2) 选择排序算法中时间复杂度比较低的快排进行排序，可以直接使用<algorithm>库中的sort()函数进行排序。</algorithm></p>
<p>优化： 仔细分析快排的思路：在分割的过程中每次返回一个主元pivot,主元左边的元素都小于pivot,右边的元素都大于piovt，然后再分别对两边递归排序。因为题目要求的只是返回一个第k大的数，所以不需要完整地对执行完所有递归。当寻找到的主元pivot的坐标刚好等于len-k时，就可以直接返回；如果pivot<len-k说明要找的数目在右边，则只用对右边进行快排；如果pivot>len-k，说明要寻找的数字在左边，则只用对左半边进行快排。</len-k说明要找的数目在右边，则只用对右边进行快排；如果pivot></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">https://leetcode.com/problems/kth-largest-element-in-an-array/</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="keyword">int</span> ans;</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">quicksort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(lo&gt;=hi) &#123; <span class="comment">//正常情况下退出时相等的情况，为了避免其他逻辑错误因此再加上lo大于hi的情况</span></span><br><span class="line">				ans = vec[hi]; <span class="comment">// 递归到最后还没有找到说明就是最后的这个元素就是要找的第k大，不考虑k大len的情况。</span></span><br><span class="line">				<span class="keyword">return</span>; <span class="comment">// base case 递归必备，有个出口只有一个元素的时候不会再递归。</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">int</span> piv = partition(vec, lo, hi);</span><br><span class="line">			<span class="keyword">if</span>(piv==k)&#123;</span><br><span class="line">				ans = vec[k];</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(k&lt;piv) quicksort(vec,lo,piv<span class="number">-1</span>,k);<span class="comment">//左边递归 piv不再参与两边的快排,因为已经找到它的位置了。</span></span><br><span class="line">			<span class="keyword">else</span> quicksort(vec,piv+<span class="number">1</span>,hi,k);<span class="comment">//右边递归</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;vec,<span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">			<span class="keyword">int</span> loNow = lo - <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">int</span> piov = hi;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = lo; i&lt;=hi<span class="number">-1</span>; i++)&#123; <span class="comment">// 必须小于等于，因为hi是下标而不是数组长度，</span></span><br><span class="line">											<span class="comment">//如果是长度的话i&lt;len-1,会访问到倒数第二个，下标的话就不会。</span></span><br><span class="line">				<span class="keyword">if</span>(vec[i]&lt;=vec[piov])&#123;</span><br><span class="line">					loNow++;</span><br><span class="line">					swap(vec, loNow, i);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			swap(vec, loNow+<span class="number">1</span>, piov);</span><br><span class="line">			piov = loNow+<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">return</span> piov;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">			<span class="keyword">int</span> tmp = vec[a];</span><br><span class="line">			vec[a] = vec[b];</span><br><span class="line">			vec[b] = tmp;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> len, k;</span><br><span class="line">	Solution Sol;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">	<span class="comment">//while(cin&gt;&gt;len&gt;&gt;k)</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;len, &amp;k)!=EOF)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> tmp_len = len ;</span><br><span class="line">		<span class="keyword">while</span>(tmp_len--) &#123;</span><br><span class="line">			<span class="keyword">int</span> element;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;element);</span><br><span class="line">			vec.push_back(element);</span><br><span class="line">		&#125;</span><br><span class="line">		Sol.quicksort(vec, <span class="number">0</span>, len<span class="number">-1</span>, len-k);</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;Sol.ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"> 	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>快排</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>OJ输入输出</title>
    <url>/2019-09-08-OJ%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA.html</url>
    <content><![CDATA[<h1 id="OJ输入输出"><a href="#OJ输入输出" class="headerlink" title="OJ输入输出"></a>OJ输入输出</h1><p>算法课要求打UOJ，实际操作后发现与leetcode，牛客这些只用写解决类不一样，OJ要求自己编写输入输出。所以对于输入输出还是很头痛，在此总结下。</p>
<a id="more"></a>
<h2 id="C-输入输出"><a href="#C-输入输出" class="headerlink" title="C++输入输出"></a>C++输入输出</h2><p>输入输出不是对文件进行操作的，可以理解成是在命令行中进行输入与输出。所以主要使用标准输入流cin进行数据的输入，标准输出流cout进行输出。因为有多组测试样例，所以一般需要放在while循环中来读取数据并进行操作。总思路是输入一组输入对应的输出一组输出，边输入边输出。</p>
<p>需要注意的是cin 会自动跳过空格、tab、换行符等不可见的符号，所以可以在同一行中输入a,b两个值，而不用自己去分割空格。</p>
<h3 id="只有一组输入输出"><a href="#只有一组输入输出" class="headerlink" title="只有一组输入输出"></a>只有一组输入输出</h3><p>直接从键盘获取一组输入，随后输出，以计算a+b为例。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt; iostream &gt;   </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> a,b; </span><br><span class="line">     <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; a+b &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="有多组测试数据，直到读至输入文件结尾为止"><a href="#有多组测试数据，直到读至输入文件结尾为止" class="headerlink" title="有多组测试数据，直到读至输入文件结尾为止"></a><strong>有多组测试数据，直到读至输入文件结尾为止</strong></h2><p>有多组测试数据，需要在while循环中读取数据并进行处理。当输入</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt; iostream &gt;    </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">       <span class="keyword">int</span> a,b;</span><br><span class="line">       <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; a+b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="在开始的时候输入一个N，接下来是N组数据"><a href="#在开始的时候输入一个N，接下来是N组数据" class="headerlink" title="在开始的时候输入一个N，接下来是N组数据"></a><strong>在开始的时候输入一个N，接下来是N组数据</strong></h2><p>在while循环中进行数据读入，需要注意的是如果后面需要用到n这个参数，需要使用临时变量来存储n，否则n在循环后会变成0.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a, b, n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; a + b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="未知输入数据量，但以某个特殊输入为结束标志"><a href="#未知输入数据量，但以某个特殊输入为结束标志" class="headerlink" title="未知输入数据量，但以某个特殊输入为结束标志"></a>未知输入数据量，但以某个特殊输入为结束标志</h2><p>当a或者b为0的时候结束输入，否则读入一组a，b并输出二者之和。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a ,b;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b&amp;&amp;(a||b))&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;a+b&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="重定向输入"><a href="#重定向输入" class="headerlink" title="重定向输入"></a>重定向输入</h2><p>将输入从控制台重定向到文件，从文件进行输入。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;  </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    freopen(<span class="string">"input.txt"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);  <span class="comment">//输入将被重定向到文件</span></span><br><span class="line">    <span class="keyword">int</span> a,b;  </span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;  </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;a+b&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="字符串输入"><a href="#字符串输入" class="headerlink" title="字符串输入"></a>字符串输入</h2><p>使用<code>cin.getline()</code>函数，其原型为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">istream&amp; <span class="title">getline</span><span class="params">(<span class="keyword">char</span> line[], <span class="keyword">int</span> size, <span class="keyword">char</span> endchar = <span class="string">'\n'</span>)</span></span>;</span><br><span class="line"><span class="keyword">char</span> line[]： 就是一个字符数组，用户输入的内容将存入在该数组内。</span><br><span class="line"><span class="keyword">int</span> size : 最多接受几个字符，用户超过size的输入都将不被接受。</span><br><span class="line"><span class="keyword">char</span> endchar :当用户输入endchar指定的字符时，自动结束，默认是回车符。</span><br></pre></td></tr></table></figure>
<p>所以输入指定数目的字符串可以写成：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[ <span class="number">255</span> ];</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>.getline( buf, <span class="number">255</span> ));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以使用string类型来进行输入，如下程序循环输入pair组字符串，每组字符串有两个字符串用空格分开。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> pair;</span><br><span class="line">    <span class="built_in">string</span> str1, str2;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;pair)&#123;</span><br><span class="line">		<span class="keyword">while</span>(pair--)&#123;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;str1;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;str2;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;str1&lt;&lt;str2&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的输入样式为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">ABCD AEFC</span><br><span class="line">SCFEZ BNI</span><br><span class="line">3</span><br><span class="line">ABCD AEFC</span><br><span class="line">SCFEZ BNI</span><br><span class="line">ABCD XVC</span><br></pre></td></tr></table></figure>
<p>即第一次输入2组字符串，第一组字符串为：<code>ABCD 与 AEFC</code>这两个字符串，cin会跳过空格即自动把空格前的ABCD这个字符串作为str1的输入而把空格后面的<code>AEFC</code>作为str2的输入。第二组字符串为：<code>SCFEZ BNI</code> ,与前面同理不赘述。</p>
<p>第二次输入为3组字符串，与第一次同理。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/qiao1245/article/details/53020326" target="_blank" rel="noopener">https://blog.csdn.net/qiao1245/article/details/53020326</a> </p>
<p><a href="https://www.cnblogs.com/emerson027/articles/9319135.html" target="_blank" rel="noopener">https://www.cnblogs.com/emerson027/articles/9319135.html</a> </p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OJ</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>实模式寻址方式</title>
    <url>/2019-09-08-%E5%AE%9E%E6%A8%A1%E5%BC%8F%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F.html</url>
    <content><![CDATA[<h1 id="实模式寻址方式"><a href="#实模式寻址方式" class="headerlink" title="实模式寻址方式"></a>实模式寻址方式</h1><p>在上《操作系统高级教程》课时有BIOS启动时的实模式，讲到 CS与IP这两个寄存器，但是始终不能理解为什么说CS:IP可以表示一个物理地址，查询后才理解到与实模式的寻址方式有关。</p>
<a id="more"></a>
<h2 id="8086的寻址方式"><a href="#8086的寻址方式" class="headerlink" title="8086的寻址方式"></a>8086的寻址方式</h2><p>为了理解实模式，首先需要理解Intel 8086这个16位CPU的寻址模式。</p>
<p>8086的CPU是16位，即它的所有寄存器和寄存器之间的数据总线都是16位的，而其外部数据总线却是20位的。那么如何才能访问到20位也就是1MB的地址空间呢？显然一个寄存器是不够的所以就用两个寄存器来存储，这也就是段式寻址（内存分段）。段式寻址需要使用一个寄存器作为段寄存器比如CS代码段寄存器，使用另外一个寄存器比如IP指令指针寄存器作为偏移寄存器。计算物理地址的时候首先将段寄存器的16位地址向左移动4位（也就是最开始段寄存器的地址x16），然后将左移4位后的段地址与偏移地址相加就可以得到一个20位的物理地址了。也可以理解成最开始的段寄存器的地址默认后面还有4位，只是都省略成0，这样就可以放在16位寄存器中了。</p>
<h2 id="实模式寻址方式-1"><a href="#实模式寻址方式-1" class="headerlink" title="实模式寻址方式"></a>实模式寻址方式</h2><p>实模式（Real mode） 是Intel 80286和之后的80x86兼容CPU的操作模式，所有的80x86CPU的开机状态都是实模式。实模式的特性是一个20位的存储器地址空间（即1MB的存储器）可以被寻址。为了兼容，也为了解决最开始的启动问题，Intel将所有80x86系列的CPU（包括最新型号的64位CPU）的硬件都设计为加电即进入16位实模式状态运行。在实模式状态下寄存器是16位的，地址总线是20位的，也就是说实模式下寻址空间为1MB。因此与8086这个16位机器一样，为了实现20位寻址依然采取段式寻址方式。</p>
<p>开机时的第一个操作就是执行BIOS程序，CPU的硬件逻辑被设计为加电瞬间强行将CS的值设置为0XF000,IP的值设置为0XFFF0，这样CS:IP 的地址就是CS值左移四位变成0xF0000后加上IP的偏移地址也就是0xF0000+0XFFF0 也就是0xFFFF0，而0xFFFF0这个地址也就是BIOS程序的地址，CPU将开始执行这个地址的BIOS代码，从而开始BIOS的启动。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《Linux内核设计的艺术》第二版</p>
<p><a href="https://zh.wikipedia.org/wiki/X86#%E7%9C%9F%E5%AF%A6%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/X86#%E7%9C%9F%E5%AF%A6%E6%A8%A1%E5%BC%8F</a> </p>
<p><a href="https://zh.wikipedia.org/wiki/Intel_8086#%E5%86%85%E5%AD%98%E5%88%86%E6%AE%B5" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/Intel_8086#%E5%86%85%E5%AD%98%E5%88%86%E6%AE%B5</a> </p>
<p><a href="https://zhuanlan.zhihu.com/p/69504370" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/69504370</a> </p>
<p><a href="https://blog.csdn.net/unix21/article/details/8450214" target="_blank" rel="noopener">https://blog.csdn.net/unix21/article/details/8450214</a> </p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>内存寻址</tag>
        <tag>寄存器</tag>
        <tag>BIOS</tag>
      </tags>
  </entry>
  <entry>
    <title>shadowsocks的部署</title>
    <url>/2019-08-24-shadowsocks%E7%9A%84%E9%83%A8%E7%BD%B2.html</url>
    <content><![CDATA[<h1 id="shadowsocks-的部署"><a href="#shadowsocks-的部署" class="headerlink" title="shadowsocks 的部署"></a>shadowsocks 的部署</h1><p>部署shadowsocks主要有两个作用：</p>
<ol>
<li>可以翻墙 </li>
<li>可以白嫖校园网的ipv6 </li>
</ol>
<a id="more"></a>
<h2 id="1-购买VPS服务器"><a href="#1-购买VPS服务器" class="headerlink" title="1. 购买VPS服务器"></a>1. 购买VPS服务器</h2><p>目前使用vultr的VPS服务器，5刀一个月，使用的CENTOS发行版。貌似日本的服务器网速最快，而且支持IPV6。在部署服务器的时候就需要开启IPV6。</p>
<h2 id="2-服务器设置"><a href="#2-服务器设置" class="headerlink" title="2. 服务器设置"></a>2. 服务器设置</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>在/root/目录下创建文件夹</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir shadowsocks</span><br><span class="line">cd shadowsocks/</span><br></pre></td></tr></table></figure>
<p>安装python和pip工具以及git</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install python-setuptools &amp;&amp; easy_install pip</span><br><span class="line">yum install git</span><br></pre></td></tr></table></figure>
<p>使用pip通过git安装shadowsocks</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install git+https://github.com/shadowsocks/shadowsocks.git@master</span><br><span class="line">ssserver</span><br></pre></td></tr></table></figure>
<p>ssserver 命令用来查看是否安装成功</p>
<h3 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi shadowsocks.json</span><br></pre></td></tr></table></figure>
<p>脚本内容为：</p>
<p>多端口账户脚本如下</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"server"</span>:<span class="string">"::"</span>,</span><br><span class="line">    <span class="attr">"local_address"</span>: <span class="string">"127.0.0.1"</span>,</span><br><span class="line">    <span class="attr">"local_port"</span>:<span class="number">1080</span>,</span><br><span class="line">    <span class="attr">"port_password"</span>:&#123;</span><br><span class="line">    <span class="attr">"8388"</span>:<span class="string">"frankfurt123"</span>,</span><br><span class="line"> 	<span class="attr">"2343"</span>:<span class="string">"password"</span></span><br><span class="line">&#125;,</span><br><span class="line">    <span class="attr">"timeout"</span>:<span class="number">300</span>,</span><br><span class="line">    <span class="attr">"method"</span>:<span class="string">"aes-256-cfb"</span>,</span><br><span class="line">    <span class="attr">"fast_open"</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中server:”::” 用两个:: 冒号来表示可以同时使用ipv4和ipv6来访问服务器，如果就只有ipv4的地址的话，只能使用ipv4来翻墙。</p>
<p>通过脚本来启动shadowsocks</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssserver -c /root/shadowsocks/shadowsocks.json -d start</span><br><span class="line">ssserver -c /root/shadowsocks/shadowsocks.json -d status</span><br><span class="line">ssserver -c /root/shadowsocks/shadowsocks.json -d stop</span><br></pre></td></tr></table></figure>
<p>至此通过添加服务器配置就应该可以使用shadowsocks+switchomega客户端了，如果还不可以的话，多半是因为防火墙的问题。</p>
<h3 id="防火墙设置"><a href="#防火墙设置" class="headerlink" title="防火墙设置"></a>防火墙设置</h3><p>将8388添加到防火墙白名单。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=8388/tcp --permanent</span><br><span class="line">firewall-cmd --reload</span><br><span class="line">firewall-cmd --list-ports</span><br></pre></td></tr></table></figure>
<h2 id="客户端设置"><a href="#客户端设置" class="headerlink" title="客户端设置"></a>客户端设置</h2><p>我使用的是win10 可以从：<a href="https://github.com/shadowsocks/shadowsocks-windows" target="_blank" rel="noopener">https://github.com/shadowsocks/shadowsocks-windows</a> 下载</p>
<p>MacOS：<a href="https://github.com/shadowsocks/ShadowsocksX-NG/releases" target="_blank" rel="noopener">https://github.com/shadowsocks/ShadowsocksX-NG/releases</a> </p>
<p>在服务器设置界面依次添加IPV6的地址、端口、密码、加密方式就可以使用IPV6进行白嫖了。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/shadowsocks/shadowsocks/tree/master" target="_blank" rel="noopener">https://github.com/shadowsocks/shadowsocks/tree/master</a> </p>
]]></content>
      <categories>
        <category>deploy</category>
      </categories>
      <tags>
        <tag>shadowsocks</tag>
        <tag>翻墙</tag>
        <tag>ipv6</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis Makefile注解</title>
    <url>/2019-04-26-Redis-Makefile%E6%B3%A8%E8%A7%A3.html</url>
    <content><![CDATA[<h1 id="Redis-Makefile注解"><a href="#Redis-Makefile注解" class="headerlink" title="Redis Makefile注解"></a>Redis Makefile注解</h1><p>Redis的makefile是阅读源码的第一步，总共有292行，读起来也是头大，记录之。</p>
<a id="more"></a>
<p>4.02版本源码为：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Redis Makefile</span></span><br><span class="line"><span class="comment"># Copyright (C) 2009 Salvatore Sanfilippo &lt;antirez at gmail dot com&gt;</span></span><br><span class="line"><span class="comment"># This file is released under the BSD license, see the COPYING file</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The Makefile composes the final FINAL_CFLAGS and FINAL_LDFLAGS using</span></span><br><span class="line"><span class="comment"># what is needed for Redis plus the standard CFLAGS and LDFLAGS passed.</span></span><br><span class="line"><span class="comment"># However when building the dependencies (Jemalloc, Lua, Hiredis, ...)</span></span><br><span class="line"><span class="comment"># CFLAGS and LDFLAGS are propagated to the dependencies, so to pass</span></span><br><span class="line"><span class="comment"># flags only to be used when compiling / linking Redis itself REDIS_CFLAGS</span></span><br><span class="line"><span class="comment"># and REDIS_LDFLAGS are used instead (this is the case of 'make gcov').</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Dependencies are stored in the Makefile.dep file. To rebuild this file</span></span><br><span class="line"><span class="comment"># Just use 'make dep', but this is only needed by developers.</span></span><br><span class="line"></span><br><span class="line">release_hdr := <span class="variable">$(<span class="built_in">shell</span> sh -c './mkreleasehdr.sh')</span></span><br><span class="line"><span class="comment"># uname -s 获取操作系统的类型 Linux</span></span><br><span class="line">uname_S := <span class="variable">$(<span class="built_in">shell</span> sh -c 'uname -s 2&gt;/dev/null || echo not')</span></span><br><span class="line"><span class="comment">#uname -m 获取机子的架构 x86_64</span></span><br><span class="line">uname_M := <span class="variable">$(<span class="built_in">shell</span> sh -c 'uname -m 2&gt;/dev/null || echo not')</span></span><br><span class="line"><span class="comment"># 优化选项</span></span><br><span class="line">OPTIMIZATION?=-O2</span><br><span class="line"><span class="comment"># 依赖目标</span></span><br><span class="line">DEPENDENCY_TARGETS=hiredis linenoise lua</span><br><span class="line">NODEPS:=clean distclean</span><br><span class="line"></span><br><span class="line"><span class="comment"># Default settings</span></span><br><span class="line"><span class="comment"># 使用c99标准编译，-pedantic 保证代码规范满足ISO C和ISO C++标准</span></span><br><span class="line">STD=-std=c99 -pedantic -DREDIS_STATIC=''</span><br><span class="line"><span class="comment"># 输出所有编译警告信息 ，Wno-missing-field-initializers 不输出missing-的警告信息</span></span><br><span class="line">WARN=-Wall -W -Wno-missing-field-initializers</span><br><span class="line">OPT=<span class="variable">$(OPTIMIZATION)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#默认目录</span></span><br><span class="line">PREFIX?=/usr/local</span><br><span class="line"><span class="comment">#安装的默认目录</span></span><br><span class="line">INSTALL_BIN=<span class="variable">$(PREFIX)</span>/bin</span><br><span class="line">INSTALL=install</span><br><span class="line"></span><br><span class="line"><span class="comment"># Default allocator defaults to Jemalloc if it's not an ARM</span></span><br><span class="line"><span class="comment">#内存分配器的指定 默认libc，linux系统而且架构不是armv61和71的时候则是jemalloc，</span></span><br><span class="line">MALLOC=libc</span><br><span class="line"><span class="keyword">ifneq</span> (<span class="variable">$(uname_M)</span>,armv6l)</span><br><span class="line"><span class="keyword">ifneq</span> (<span class="variable">$(uname_M)</span>,armv7l)</span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(uname_S)</span>,Linux)</span><br><span class="line">	MALLOC=jemalloc</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># To get ARM stack traces if Redis crashes we need a special C flag.</span></span><br><span class="line"><span class="keyword">ifneq</span> (,<span class="variable">$(<span class="built_in">findstring</span> armv,<span class="variable">$(uname_M)</span>)</span>)</span><br><span class="line">        CFLAGS+=-funwind-tables</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Backwards compatibility for selecting an allocator</span></span><br><span class="line"><span class="comment">#编译的时候指定内存分配器</span></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(USE_TCMALLOC)</span>,yes)</span><br><span class="line">	MALLOC=tcmalloc</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(USE_TCMALLOC_MINIMAL)</span>,yes)</span><br><span class="line">	MALLOC=tcmalloc_minimal</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(USE_JEMALLOC)</span>,yes)</span><br><span class="line">	MALLOC=jemalloc</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(USE_JEMALLOC)</span>,no)</span><br><span class="line">	MALLOC=libc</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Override default settings if possible</span></span><br><span class="line"><span class="keyword">-include</span> .make-settings</span><br><span class="line"><span class="comment"># 最终的编译选项CFLAGS是-c的选项，LDFLAGS是链接的选项</span></span><br><span class="line">FINAL_CFLAGS=<span class="variable">$(STD)</span> <span class="variable">$(WARN)</span> <span class="variable">$(OPT)</span> <span class="variable">$(DEBUG)</span> <span class="variable">$(CFLAGS)</span> <span class="variable">$(REDIS_CFLAGS)</span></span><br><span class="line">FINAL_LDFLAGS=<span class="variable">$(LDFLAGS)</span> <span class="variable">$(REDIS_LDFLAGS)</span> <span class="variable">$(DEBUG)</span></span><br><span class="line"><span class="comment"># m这个lib是libmath 也就是math的链接</span></span><br><span class="line">FINAL_LIBS=-lm</span><br><span class="line"><span class="comment"># 调试信息</span></span><br><span class="line">DEBUG=-g -ggdb</span><br><span class="line"><span class="comment">#根据操作系统继续指定编译选项</span></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(uname_S)</span>,SunOS)</span><br><span class="line">	<span class="comment"># SunOS</span></span><br><span class="line">        <span class="keyword">ifneq</span> ($(@@),32bit)</span><br><span class="line">		CFLAGS+= -m64</span><br><span class="line">		LDFLAGS+= -m64</span><br><span class="line">	<span class="keyword">endif</span></span><br><span class="line">	DEBUG=-g</span><br><span class="line">	DEBUG_FLAGS=-g</span><br><span class="line">	<span class="keyword">export</span> CFLAGS LDFLAGS DEBUG DEBUG_FLAGS</span><br><span class="line">	INSTALL=cp -pf</span><br><span class="line">	FINAL_CFLAGS+= -D__EXTENSIONS__ -D_XPG6</span><br><span class="line">	FINAL_LIBS+= -ldl -lnsl -lsocket -lresolv -lpthread -lrt</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(uname_S)</span>,Darwin)</span><br><span class="line">	<span class="comment"># Darwin</span></span><br><span class="line">	FINAL_LIBS+= -ldl</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(uname_S)</span>,AIX)</span><br><span class="line">        <span class="comment"># AIX</span></span><br><span class="line">        FINAL_LDFLAGS+= -Wl,-bexpall</span><br><span class="line">        FINAL_LIBS+=-ldl -pthread -lcrypt -lbsd</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(uname_S)</span>,OpenBSD)</span><br><span class="line">	<span class="comment"># OpenBSD</span></span><br><span class="line">	FINAL_LIBS+= -lpthread</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(uname_S)</span>,FreeBSD)</span><br><span class="line">	<span class="comment"># FreeBSD</span></span><br><span class="line">	FINAL_LIBS+= -lpthread</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	<span class="comment"># 特别是对Linux的指定</span></span><br><span class="line">	<span class="comment"># All the other OSes (notably Linux)</span></span><br><span class="line">	<span class="comment"># -rdynamic将链接器将所有符号添加到动态符号表</span></span><br><span class="line">	FINAL_LDFLAGS+= -rdynamic</span><br><span class="line">	<span class="comment">#pthread库 用于多线程， dl是libdl 动态链接库</span></span><br><span class="line">	FINAL_LIBS+=-ldl -pthread</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"><span class="comment"># Include paths to dependencies</span></span><br><span class="line"><span class="comment"># -I 指定头文件的目录</span></span><br><span class="line">FINAL_CFLAGS+= -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src</span><br><span class="line"></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(MALLOC)</span>,tcmalloc)</span><br><span class="line">	FINAL_CFLAGS+= -DUSE_TCMALLOC</span><br><span class="line">	FINAL_LIBS+= -ltcmalloc</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(MALLOC)</span>,tcmalloc_minimal)</span><br><span class="line">	FINAL_CFLAGS+= -DUSE_TCMALLOC</span><br><span class="line">	FINAL_LIBS+= -ltcmalloc_minimal</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"><span class="comment">#使用jemalloc的话 链接 libjemalloc.a -I指定jemalloc的头文件目录</span></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(MALLOC)</span>,jemalloc)</span><br><span class="line">	DEPENDENCY_TARGETS+= jemalloc</span><br><span class="line">	FINAL_CFLAGS+= -DUSE_JEMALLOC -I../deps/jemalloc/<span class="keyword">include</span></span><br><span class="line">	FINAL_LIBS+= ../deps/jemalloc/lib/libjemalloc.a</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"><span class="comment">#redis 的gcc -c 选项</span></span><br><span class="line">REDIS_CC=<span class="variable">$(QUIET_CC)</span><span class="variable">$(CC)</span> <span class="variable">$(FINAL_CFLAGS)</span></span><br><span class="line"><span class="comment">#redis的gcc 链接选项</span></span><br><span class="line">REDIS_LD=<span class="variable">$(QUIET_LINK)</span><span class="variable">$(CC)</span> <span class="variable">$(FINAL_LDFLAGS)</span></span><br><span class="line"><span class="comment">#redis的安装选项</span></span><br><span class="line">REDIS_INSTALL=<span class="variable">$(QUIET_INSTALL)</span><span class="variable">$(INSTALL)</span></span><br><span class="line"></span><br><span class="line">CCCOLOR=<span class="string">"\033[34m"</span></span><br><span class="line">LINKCOLOR=<span class="string">"\033[34;1m"</span></span><br><span class="line">SRCCOLOR=<span class="string">"\033[33m"</span></span><br><span class="line">BINCOLOR=<span class="string">"\033[37;1m"</span></span><br><span class="line">MAKECOLOR=<span class="string">"\033[32;1m"</span></span><br><span class="line">ENDCOLOR=<span class="string">"\033[0m"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ifndef</span> V</span><br><span class="line">QUIET_CC = @printf '    %b %b\n' <span class="variable">$(CCCOLOR)</span>CC<span class="variable">$(ENDCOLOR)</span> <span class="variable">$(SRCCOLOR)</span><span class="variable">$@</span><span class="variable">$(ENDCOLOR)</span> 1&gt;&amp;2;</span><br><span class="line">QUIET_LINK = @printf '    %b %b\n' <span class="variable">$(LINKCOLOR)</span>LINK<span class="variable">$(ENDCOLOR)</span> <span class="variable">$(BINCOLOR)</span><span class="variable">$@</span><span class="variable">$(ENDCOLOR)</span> 1&gt;&amp;2;</span><br><span class="line">QUIET_INSTALL = @printf '    %b %b\n' <span class="variable">$(LINKCOLOR)</span>INSTALL<span class="variable">$(ENDCOLOR)</span> <span class="variable">$(BINCOLOR)</span><span class="variable">$@</span><span class="variable">$(ENDCOLOR)</span> 1&gt;&amp;2;</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line">REDIS_SERVER_NAME=redis-server</span><br><span class="line">REDIS_SENTINEL_NAME=redis-sentinel</span><br><span class="line"><span class="comment"># redis-server的需要使用的对象文件，也就是各个模块</span></span><br><span class="line">REDIS_SERVER_OBJ=adlist.o quicklist.o ae.o anet.o dict.o server.o sds.o zmalloc.o lzf_c.o lzf_d.o pqsort.o zipmap.o sha1.o ziplist.o release.o networking.o util.o object.o db.o replication.o rdb.o t_string.o t_list.o t_set.o t_zset.o t_hash.o config.o aof.o pubsub.o multi.o debug.o sort.o intset.o syncio.o cluster.o crc16.o endianconv.o slowlog.o scripting.o bio.o rio.o rand.o memtest.o crc64.o bitops.o sentinel.o notify.o setproctitle.o blocked.o hyperloglog.o latency.o sparkline.o redis-check-rdb.o redis-check-aof.o geo.o lazyfree.o module.o evict.o expire.o geohash.o geohash_helper.o childinfo.o defrag.o siphash.o rax.o</span><br><span class="line">REDIS_CLI_NAME=redis-cli</span><br><span class="line"><span class="comment">#redis-cli 需要使用的对象文件</span></span><br><span class="line">REDIS_CLI_OBJ=anet.o adlist.o redis-cli.o zmalloc.o release.o anet.o ae.o crc64.o</span><br><span class="line">REDIS_BENCHMARK_NAME=redis-benchmark</span><br><span class="line"><span class="comment">#redis-benchmark需要使用的对象文件</span></span><br><span class="line">REDIS_BENCHMARK_OBJ=ae.o anet.o redis-benchmark.o adlist.o zmalloc.o redis-benchmark.o</span><br><span class="line">REDIS_CHECK_RDB_NAME=redis-check-rdb</span><br><span class="line">REDIS_CHECK_AOF_NAME=redis-check-aof</span><br><span class="line"><span class="comment">#所有需要需要构建的对象，第一条规则也就是默认规则，不指定规则的话，从第一个规则执行</span></span><br><span class="line"><span class="section">all: <span class="variable">$(REDIS_SERVER_NAME)</span> <span class="variable">$(REDIS_SENTINEL_NAME)</span> <span class="variable">$(REDIS_CLI_NAME)</span> <span class="variable">$(REDIS_BENCHMARK_NAME)</span> <span class="variable">$(REDIS_CHECK_RDB_NAME)</span> <span class="variable">$(REDIS_CHECK_AOF_NAME)</span></span></span><br><span class="line">	@echo <span class="string">""</span></span><br><span class="line">	@echo <span class="string">"Hint: It's a good idea to run 'make test' ;)"</span></span><br><span class="line">	@echo <span class="string">""</span></span><br><span class="line"><span class="comment">#Makefil.dep 的生成</span></span><br><span class="line"><span class="section">Makefile.dep:</span></span><br><span class="line">	-<span class="variable">$(REDIS_CC)</span> -MM *.c &gt; Makefile.dep 2&gt; /dev/null || true</span><br><span class="line"></span><br><span class="line"><span class="keyword">ifeq</span> (0, <span class="variable">$(words $(<span class="built_in">findstring</span> <span class="variable">$(MAKECMDGOALS)</span>, <span class="variable">$(NODEPS)</span>)</span>))</span><br><span class="line"><span class="keyword">-include</span> Makefile.dep</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: all</span></span><br><span class="line"><span class="comment">#先清除所有编译的输出然后，  将所有设置持久化</span></span><br><span class="line"><span class="section">persist-settings: distclean</span></span><br><span class="line">	echo STD=<span class="variable">$(STD)</span> &gt;&gt; .make-settings</span><br><span class="line">	echo WARN=<span class="variable">$(WARN)</span> &gt;&gt; .make-settings</span><br><span class="line">	echo OPT=<span class="variable">$(OPT)</span> &gt;&gt; .make-settings</span><br><span class="line">	echo MALLOC=<span class="variable">$(MALLOC)</span> &gt;&gt; .make-settings</span><br><span class="line">	echo CFLAGS=<span class="variable">$(CFLAGS)</span> &gt;&gt; .make-settings</span><br><span class="line">	echo LDFLAGS=<span class="variable">$(LDFLAGS)</span> &gt;&gt; .make-settings</span><br><span class="line">	echo REDIS_CFLAGS=<span class="variable">$(REDIS_CFLAGS)</span> &gt;&gt; .make-settings</span><br><span class="line">	echo REDIS_LDFLAGS=<span class="variable">$(REDIS_LDFLAGS)</span> &gt;&gt; .make-settings</span><br><span class="line">	echo PREV_FINAL_CFLAGS=<span class="variable">$(FINAL_CFLAGS)</span> &gt;&gt; .make-settings</span><br><span class="line">	echo PREV_FINAL_LDFLAGS=<span class="variable">$(FINAL_LDFLAGS)</span> &gt;&gt; .make-settings</span><br><span class="line">	-(cd ../deps &amp;&amp; <span class="variable">$(MAKE)</span> <span class="variable">$(DEPENDENCY_TARGETS)</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: persist-settings</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># Prerequisites target</span></span><br><span class="line"><span class="section">.make-prerequisites:</span></span><br><span class="line">	@touch <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Clean everything, persist settings and build dependencies if anything changed</span></span><br><span class="line"><span class="comment">#当设置有变化的时候清除并重新持久化设置</span></span><br><span class="line"><span class="keyword">ifneq</span> (<span class="variable">$(<span class="built_in">strip</span> <span class="variable">$(PREV_FINAL_CFLAGS)</span>)</span>, <span class="variable">$(<span class="built_in">strip</span> <span class="variable">$(FINAL_CFLAGS)</span>)</span>)</span><br><span class="line"><span class="section">.make-prerequisites: persist-settings</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ifneq</span> (<span class="variable">$(<span class="built_in">strip</span> <span class="variable">$(PREV_FINAL_LDFLAGS)</span>)</span>, <span class="variable">$(<span class="built_in">strip</span> <span class="variable">$(FINAL_LDFLAGS)</span>)</span>)</span><br><span class="line"><span class="section">.make-prerequisites: persist-settings</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># redis-server</span></span><br><span class="line"><span class="comment">#redis-server可执行程序的链接，需要链接的静态链接文件包括hiredi和lua,还有final_libs</span></span><br><span class="line"><span class="variable">$(REDIS_SERVER_NAME)</span>: <span class="variable">$(REDIS_SERVER_OBJ)</span></span><br><span class="line">	<span class="variable">$(REDIS_LD)</span> -o <span class="variable">$@</span> <span class="variable">$^</span> ../deps/hiredis/libhiredis.a ../deps/lua/src/liblua.a <span class="variable">$(FINAL_LIBS)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># redis-sentinel</span></span><br><span class="line"><span class="comment">#redis-sentienl构建</span></span><br><span class="line"><span class="variable">$(REDIS_SENTINEL_NAME)</span>: <span class="variable">$(REDIS_SERVER_NAME)</span></span><br><span class="line">	<span class="variable">$(REDIS_INSTALL)</span> <span class="variable">$(REDIS_SERVER_NAME)</span> <span class="variable">$(REDIS_SENTINEL_NAME)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># redis-check-rdb</span></span><br><span class="line"><span class="comment">#redis-check-rdb的构建</span></span><br><span class="line"><span class="variable">$(REDIS_CHECK_RDB_NAME)</span>: <span class="variable">$(REDIS_SERVER_NAME)</span></span><br><span class="line">	<span class="variable">$(REDIS_INSTALL)</span> <span class="variable">$(REDIS_SERVER_NAME)</span> <span class="variable">$(REDIS_CHECK_RDB_NAME)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># redis-check-aof</span></span><br><span class="line"><span class="comment">#redis-check-aof的构建</span></span><br><span class="line"><span class="variable">$(REDIS_CHECK_AOF_NAME)</span>: <span class="variable">$(REDIS_SERVER_NAME)</span></span><br><span class="line">	<span class="variable">$(REDIS_INSTALL)</span> <span class="variable">$(REDIS_SERVER_NAME)</span> <span class="variable">$(REDIS_CHECK_AOF_NAME)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># redis-cli</span></span><br><span class="line"><span class="comment">#redis-cli的链接</span></span><br><span class="line"><span class="variable">$(REDIS_CLI_NAME)</span>: <span class="variable">$(REDIS_CLI_OBJ)</span></span><br><span class="line">	<span class="variable">$(REDIS_LD)</span> -o <span class="variable">$@</span> <span class="variable">$^</span> ../deps/hiredis/libhiredis.a ../deps/linenoise/linenoise.o <span class="variable">$(FINAL_LIBS)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># redis-benchmark</span></span><br><span class="line"><span class="comment">#redis-benchmark的链接</span></span><br><span class="line"><span class="variable">$(REDIS_BENCHMARK_NAME)</span>: <span class="variable">$(REDIS_BENCHMARK_OBJ)</span></span><br><span class="line">	<span class="variable">$(REDIS_LD)</span> -o <span class="variable">$@</span> <span class="variable">$^</span> ../deps/hiredis/libhiredis.a <span class="variable">$(FINAL_LIBS)</span></span><br><span class="line"></span><br><span class="line"><span class="section">dict-benchmark: dict.c zmalloc.c sds.c siphash.c</span></span><br><span class="line">	<span class="variable">$(REDIS_CC)</span> <span class="variable">$(FINAL_CFLAGS)</span> <span class="variable">$^</span> -D DICT_BENCHMARK_MAIN -o <span class="variable">$@</span> <span class="variable">$(FINAL_LIBS)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Because the jemalloc.h header is generated as a part of the jemalloc build,</span></span><br><span class="line"><span class="comment"># building it should complete before building any other object. Instead of</span></span><br><span class="line"><span class="comment"># depending on a single artifact, build all dependencies first.</span></span><br><span class="line"><span class="comment">#将所有点c文件编译成.o文件 自动完成file.c 到file.o的对应</span></span><br><span class="line"><span class="section">%.o: %.c .make-prerequisites</span></span><br><span class="line">	<span class="variable">$(REDIS_CC)</span> -c <span class="variable">$&lt;</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -rf <span class="variable">$(REDIS_SERVER_NAME)</span> <span class="variable">$(REDIS_SENTINEL_NAME)</span> <span class="variable">$(REDIS_CLI_NAME)</span> <span class="variable">$(REDIS_BENCHMARK_NAME)</span> <span class="variable">$(REDIS_CHECK_RDB_NAME)</span> <span class="variable">$(REDIS_CHECK_AOF_NAME)</span> *.o *.gcda *.gcno *.gcov redis.info lcov-html Makefile.dep dict-benchmark</span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: clean</span></span><br><span class="line"></span><br><span class="line"><span class="section">distclean: clean</span></span><br><span class="line">	-(cd ../deps &amp;&amp; <span class="variable">$(MAKE)</span> distclean)</span><br><span class="line">	-(rm -f .make-*)</span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: distclean</span></span><br><span class="line"></span><br><span class="line"><span class="section">test: <span class="variable">$(REDIS_SERVER_NAME)</span> <span class="variable">$(REDIS_CHECK_AOF_NAME)</span></span></span><br><span class="line">	@(cd ..; ./runtest)</span><br><span class="line"></span><br><span class="line"><span class="section">test-sentinel: <span class="variable">$(REDIS_SENTINEL_NAME)</span></span></span><br><span class="line">	@(cd ..; ./runtest-sentinel)</span><br><span class="line"></span><br><span class="line"><span class="section">check: test</span></span><br><span class="line"></span><br><span class="line"><span class="section">lcov:</span></span><br><span class="line">	<span class="variable">$(MAKE)</span> gcov</span><br><span class="line">	@(set -e; cd ..; ./runtest --clients 1)</span><br><span class="line">	@geninfo -o redis.info .</span><br><span class="line">	@genhtml --legend -o lcov-html redis.info</span><br><span class="line"></span><br><span class="line"><span class="section">test-sds: sds.c sds.h</span></span><br><span class="line">	<span class="variable">$(REDIS_CC)</span> sds.c zmalloc.c -DSDS_TEST_MAIN <span class="variable">$(FINAL_LIBS)</span> -o /tmp/sds_test</span><br><span class="line">	/tmp/sds_test</span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: lcov</span></span><br><span class="line"></span><br><span class="line"><span class="section">bench: <span class="variable">$(REDIS_BENCHMARK_NAME)</span></span></span><br><span class="line">	./<span class="variable">$(REDIS_BENCHMARK_NAME)</span></span><br><span class="line"></span><br><span class="line"><span class="section">32bit:</span></span><br><span class="line">	@echo <span class="string">""</span></span><br><span class="line">	@echo <span class="string">"WARNING: if it fails under Linux you probably need to install libc6-dev-i386"</span></span><br><span class="line">	@echo <span class="string">""</span></span><br><span class="line">	<span class="variable">$(MAKE)</span> CFLAGS=<span class="string">"-m32"</span> LDFLAGS=<span class="string">"-m32"</span></span><br><span class="line"></span><br><span class="line"><span class="section">gcov:</span></span><br><span class="line">	<span class="variable">$(MAKE)</span> REDIS_CFLAGS=<span class="string">"-fprofile-arcs -ftest-coverage -DCOVERAGE_TEST"</span> REDIS_LDFLAGS=<span class="string">"-fprofile-arcs -ftest-coverage"</span></span><br><span class="line"></span><br><span class="line"><span class="section">noopt:</span></span><br><span class="line">	<span class="variable">$(MAKE)</span> OPTIMIZATION=<span class="string">"-O0"</span></span><br><span class="line"></span><br><span class="line"><span class="section">valgrind:</span></span><br><span class="line">	<span class="variable">$(MAKE)</span> OPTIMIZATION=<span class="string">"-O0"</span> MALLOC=<span class="string">"libc"</span></span><br><span class="line"></span><br><span class="line"><span class="section">helgrind:</span></span><br><span class="line">	<span class="variable">$(MAKE)</span> OPTIMIZATION=<span class="string">"-O0"</span> MALLOC=<span class="string">"libc"</span> CFLAGS=<span class="string">"-D__ATOMIC_VAR_FORCE_SYNC_MACROS"</span></span><br><span class="line"></span><br><span class="line"><span class="section">src/help.h:</span></span><br><span class="line">	@../utils/generate-command-help.rb &gt; help.h</span><br><span class="line"><span class="comment">#将构建完成的可执行程序安装到指定的目录，-p选项自行创建多层目录</span></span><br><span class="line"><span class="section">install: all</span></span><br><span class="line">	@mkdir -p <span class="variable">$(INSTALL_BIN)</span></span><br><span class="line">	<span class="variable">$(REDIS_INSTALL)</span> <span class="variable">$(REDIS_SERVER_NAME)</span> <span class="variable">$(INSTALL_BIN)</span></span><br><span class="line">	<span class="variable">$(REDIS_INSTALL)</span> <span class="variable">$(REDIS_BENCHMARK_NAME)</span> <span class="variable">$(INSTALL_BIN)</span></span><br><span class="line">	<span class="variable">$(REDIS_INSTALL)</span> <span class="variable">$(REDIS_CLI_NAME)</span> <span class="variable">$(INSTALL_BIN)</span></span><br><span class="line">	<span class="variable">$(REDIS_INSTALL)</span> <span class="variable">$(REDIS_CHECK_RDB_NAME)</span> <span class="variable">$(INSTALL_BIN)</span></span><br><span class="line">	<span class="variable">$(REDIS_INSTALL)</span> <span class="variable">$(REDIS_CHECK_AOF_NAME)</span> <span class="variable">$(INSTALL_BIN)</span></span><br><span class="line">	@ln -sf <span class="variable">$(REDIS_SERVER_NAME)</span> <span class="variable">$(INSTALL_BIN)</span>/<span class="variable">$(REDIS_SENTINEL_NAME)</span></span><br></pre></td></tr></table></figure>
<p><code>uname_S := $(shell sh -c &#39;uname -s 2&gt;/dev/null || echo not&#39;)</code> 这一句-c让后面的字符串命令当成一个完成的命令来执行，从而避免向文件中写入东西的时候权限不够的问题。就算加上sudo也不行，因为里面的命令有&gt;,echo等很多个文件，所以只能用-c来当成一个整体来执行。<a href="https://blog.csdn.net/bobchill/article/details/84647575" target="_blank" rel="noopener">参考</a></p>
<h2 id="Makefile思路"><a href="#Makefile思路" class="headerlink" title="Makefile思路"></a>Makefile思路</h2><p>总结一下Redis Makefile的思路：</p>
<ol>
<li>在默认规则也就是第一条规则之前，通过变量设置好编译的相关选项：LDFLAGS，相应的对应关系REDIS_SERVER_OBJ，将规则的target用变量表示好（方便all规则里面用作前置条件），比如REDIS_SERVER_NAME。</li>
<li>在第一条默认规则 all规则里面指定需要构建的东西</li>
<li>在第一规则后面先完成链接，再完成编译的规则</li>
<li>其他功能性规则如clean和distclean</li>
</ol>
<p>也就是从上到下的结构是总-分。显示整个项目 ，然后是各个模块如redis-server，redis-cli的链接，然后是从源文件到obj文件的编译。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/bobchill/article/details/84647575" target="_blank" rel="noopener">https://blog.csdn.net/bobchill/article/details/84647575</a></p>
]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>Makefile</tag>
      </tags>
  </entry>
  <entry>
    <title>GCC的编译选项</title>
    <url>/2019-04-25-GCC%E7%9A%84%E7%BC%96%E8%AF%91%E9%80%89%E9%A1%B9.html</url>
    <content><![CDATA[<h1 id="GCC的编译选项"><a href="#GCC的编译选项" class="headerlink" title="GCC的编译选项"></a>GCC的编译选项</h1><p>Makefile 中的gcc的编译选项有很多，因此学习记录下。</p>
<a id="more"></a>
<p>这些选项在Makefile文件中常用CFLAGS（gcc 用在c语言的编译），CXXFLAGS（g++用在c++的编译）来表示。</p>
<h2 id="程序编译的过程"><a href="#程序编译的过程" class="headerlink" title="程序编译的过程"></a>程序编译的过程</h2><p>gcc 与 g++ 分别是 gnu 的 c &amp; c++ 编译器 gcc/g++ 在执行编译工作的时候，总共需要4步：</p>
<ul>
<li>1、预处理,生成 .i 的文件[预处理器cpp]</li>
<li>2、将预处理后的文件转换成汇编语言, 生成文件 .s [编译器egcs]</li>
<li>3、将汇编代码变为目标代码(机器代码)生成 .o 的obj文件[汇编器as]</li>
<li>4、连接目标代码, 生成可执行程序 [链接器ld]</li>
</ul>
<h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><div class="table-container">
<table>
<thead>
<tr>
<th>选项</th>
<th>释义</th>
</tr>
</thead>
<tbody>
<tr>
<td>-c</td>
<td>只激活预处理,编译,和汇编。只把程序做成obj文件，不是可执行文件（因为没有链接,有的程序中也没有main入口）</td>
</tr>
<tr>
<td>-S</td>
<td>只激活预处理和编译，就是只把文件编译成为汇编代码。生成.s的汇编代码</td>
</tr>
<tr>
<td>-E</td>
<td>只激活预处理,不生成文件,你需要把它重定向到一个输出文件里面 例子：gcc -E hello.c &gt; pianoapan.txt</td>
</tr>
<tr>
<td>-o</td>
<td>指定输出，缺省的时候,gcc 编译出来的文件是a.out</td>
</tr>
<tr>
<td>-Wall</td>
<td>显示所有警告信息</td>
</tr>
<tr>
<td>-w</td>
<td>不生成任何警告信息。</td>
</tr>
<tr>
<td>-Wextra</td>
<td>打印出更多的警告信息，比开启 -Wall 打印的还多</td>
</tr>
<tr>
<td>-ansi</td>
<td>关闭gnu c中与ansi c不兼容的特性,激活ansi c的专有特性(包括禁止一些asm inline typeof关键字,以及UNIX,vax等预处理宏</td>
</tr>
<tr>
<td>-include file</td>
<td>包含某个代码,简单来说,就是便于某个文件需要另一个文件的时候,就可以用它设<br>定,功能就相当于在代码中使用#include<filename></filename></td>
</tr>
<tr>
<td>-Idir</td>
<td>添加dir目录为头文件搜索路径，如-I./ 在当前目录查找头文件</td>
</tr>
<tr>
<td>-I-</td>
<td>取消前一个参数的功能,所以一般在-Idir之后使用</td>
</tr>
<tr>
<td>-llib</td>
<td>指定编译的时候使用的库，gcc -lcurses hello.c 使用库curses进行编译</td>
</tr>
<tr>
<td>-std=</td>
<td>编译的标准,包括GNU99，c++11,c99,等等</td>
</tr>
<tr>
<td>-O2</td>
<td>编译器的优化选项的4个级别，-O0表示没有优化,-O1为缺省值，-O3优化级别最高</td>
</tr>
<tr>
<td>-Ldir</td>
<td>链接的时候，搜索库的路径 -L./ 在当前目录搜说</td>
</tr>
<tr>
<td>-g</td>
<td>产生调试信息，可以使用gdb调试可执行文件</td>
</tr>
<tr>
<td>-ggdb</td>
<td>此选项将尽可能的生成gdb的可以使用的调试信息.</td>
</tr>
<tr>
<td>-static</td>
<td>禁止使用动态库，所以，编译出来的东西，一般都很大，也不需要什么</td>
</tr>
<tr>
<td>-share</td>
<td>此选项将尽量使用动态库，所以生成文件比较小，但是需要系统由动态库.</td>
</tr>
<tr>
<td>-shared</td>
<td>创建一个动态链接库（不指定的话输出的是obj文件）gcc -fPIC -shared func.c -o libfunc.s</td>
</tr>
<tr>
<td>-rdynamic</td>
<td>动态连接符号信息，用于动态连接功能。所有符号添加到动态符号表中（目的是能够通过使用 dlopen 来实现向后跟踪）</td>
</tr>
<tr>
<td>-pedantic</td>
<td>用于保证代码规范满足ISO C和ISO C++标准, 不允许使用任何扩展以及不满足ISO C和C++的代码, 遵守 -std 选项指定的标准</td>
</tr>
<tr>
<td>-pthread</td>
<td>支持多线程, 使用pthread库</td>
</tr>
<tr>
<td>-fPIC</td>
<td>PIC 是 position-independent code的意思, 此选项去除独立位置代码, 适合于动态链接</td>
</tr>
</tbody>
</table>
</div>
<p>ar -r libhello.a hello.o  #这里的ar相当于tar的作用，将多个目标打包。 makefile中用于创建静态链接库（就是把多个目标文件打包成一个）</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/navyhu/article/details/46788559" target="_blank" rel="noopener">https://blog.csdn.net/navyhu/article/details/46788559</a></p>
<p><a href="https://blog.csdn.net/woshinia/article/details/11060797&gt;" target="_blank" rel="noopener">https://blog.csdn.net/woshinia/article/details/11060797&gt;</a></p>
<p><a href="https://gcc.gnu.org/onlinedocs/" target="_blank" rel="noopener">https://gcc.gnu.org/onlinedocs/</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>gcc</tag>
        <tag>make</tag>
      </tags>
  </entry>
  <entry>
    <title>青蛙跳台阶问题</title>
    <url>/2019-04-17-%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6%E9%97%AE%E9%A2%98.html</url>
    <content><![CDATA[<h1 id="青蛙跳台阶问题"><a href="#青蛙跳台阶问题" class="headerlink" title="青蛙跳台阶问题"></a>青蛙跳台阶问题</h1><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。 公式不能在hexo上显示出来</p>
<a id="more"></a>
<p><a href="https://www.nowcoder.com/practice/8c82a5b80378478f9484d87d1c5f12a4?tpId=13&amp;tqId=11161&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">题目来源</a></p>
<p>解题思路：函数思想，把n阶台阶的跳法看成是关于n的函数 f(n)。当n&gt;2的时候：</p>
<p>假设第一次跳一个台阶，那么还剩n-1个台阶需要跳，也就是还有f(n-1)的跳法。</p>
<p>假设第一次跳两个台阶，那么还剩n-2个台阶需要跳，也就是还有f(n-2)的跳法</p>
<p>所以n阶的跳法总共有f(n-1) + f(n-2)  种，也就是 f(n) = f(n-1) +f(n-2)。</p>
<p>所以函数就是 ：</p>
<script type="math/tex; mode=display">
f(n)=
\begin{cases}
0& \text{n=0}\\
1& \text{n=1}\\
2& \text {n=2}\\
f(n-1)+f(n-2)& \text {n>2}
\end{cases}</script><p>也就是一个斐波那契数列，代码也就比较简单了。参考斐波那契数列的解法:</p>
<p><a href="https://github.com/BraveY/Coding/blob/master/%E5%89%91%E6%8C%87offer/Fibonacci.cc" target="_blank" rel="noopener">https://github.com/BraveY/Coding/blob/master/%E5%89%91%E6%8C%87offer/Fibonacci.cc</a></p>
<p>代码为：</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">jumpFloor</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result[<span class="number">3</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">        <span class="keyword">if</span>(number&lt;<span class="number">3</span>) <span class="keyword">return</span> result[number];</span><br><span class="line">        <span class="keyword">int</span> fib_one = result[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> fib_two = result[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> fib;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>; i&lt;=number; i++)&#123;</span><br><span class="line">            fib = fib_one + fib_two;</span><br><span class="line">            fib_one = fib_two;</span><br><span class="line">            fib_two = fib;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fib;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="变种题目："><a href="#变种题目：" class="headerlink" title="变种题目："></a>变种题目：</h2><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p>
<p>思路也是一样的：第一次跳1级台阶，则有f(n-1)的解法，第一次跳2级台阶，则有f(n-2)的解法，第一次跳n-1级台阶，则有f(2)的解法， 第一次跳n级台阶则还有一种解法。用f(0)表示第一次跳n级的情况,f(0)=1。</p>
<p>归纳成函数就是：</p>
<script type="math/tex; mode=display">
f(n)=
\begin{cases}
1& \text{n=0}\\
1& \text{n=1}\\
f(n-1)+f(n-2)...+f(1)+f(0)& \text {n>1}
\end{cases}</script><p>所以代码为：</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">jumpFloorII</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        result.push_back(<span class="number">1</span>); <span class="comment">// f(0) =1 ;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=number; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;i; j++)&#123; <span class="comment">// f(n)=f(n-1)+f(n-2)+...f(1)+f(0)</span></span><br><span class="line">                sum += result[j];</span><br><span class="line">            &#125;</span><br><span class="line">            result.push_back(sum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result[number];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>另一个斐波那契数列数列问题：</p>
<h2 id="矩形覆盖"><a href="#矩形覆盖" class="headerlink" title="矩形覆盖"></a>矩形覆盖</h2><p><a href="https://www.nowcoder.com/practice/72a5a919508a4251859fb2cfb987a0e6?tpId=13&amp;tqId=11163&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/72a5a919508a4251859fb2cfb987a0e6?tpId=13&amp;tqId=11163&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</a></p>
<p>我们可以用2<em>1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2</em>1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？</p>
<p>最开始的时候没有想清楚，以为不是斐波那契数列。</p>
<p>思路：</p>
<p>同样的方法为n的函数：f(n); 对于n=1的情况，只能竖着放：所以f(1)=1; n=2的时候，竖着放之后就变成了f(1)种方法，横着放的时候只有一种，总共有两种，所以f(2)=2;</p>
<p>所以函数为：</p>
<script type="math/tex; mode=display">
f(n)=
\begin{cases}
0& \text{n=0}\\
1& \text{n=1}\\
2& \text {n=2}\\
f(n-1)+f(n-2)& \text {n>2}
\end{cases}</script><p>因此代码也是同第一个青蛙跳台阶一样的。</p>
<p>代码：</p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//https://www.nowcoder.com/practice/72a5a919508a4251859fb2cfb987a0e6?tpId=13&amp;tqId=11163&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rectCover</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result[<span class="number">3</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">        <span class="keyword">if</span>(number&lt;<span class="number">3</span>) <span class="keyword">return</span> result[number];</span><br><span class="line">        <span class="keyword">int</span> fib_one = result[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> fib_two = result[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> fib;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>; i&lt;=number; i++)&#123;</span><br><span class="line">            fib = fib_one + fib_two;</span><br><span class="line">            fib_one = fib_two;</span><br><span class="line">            fib_two = fib;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">return</span> fib;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总结一下，对于斐波那契数列问题思路都是一样：</p>
<ul>
<li>输出是输入的函数， f(n)</li>
<li>考虑第一次是如何选择的，就可以把问题给切分出来了。</li>
</ul>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>牛客</tag>
        <tag>斐波拉契数列</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux shell脚本计算运行时间</title>
    <url>/2019-04-10-Linux-shell%E8%84%9A%E6%9C%AC%E8%AE%A1%E7%AE%97%E8%BF%90%E8%A1%8C%E6%97%B6%E9%97%B4.html</url>
    <content><![CDATA[<h1 id="Linux-shell脚本计算运行时间"><a href="#Linux-shell脚本计算运行时间" class="headerlink" title="Linux shell脚本计算运行时间"></a>Linux shell脚本计算运行时间</h1><p>这个功能经常用但是，总是现用现查，很麻烦。</p>
<a id="more"></a>
<p>代码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># filename: msec_diff.sh</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">timediff</span></span>() &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment"># time format:date +"%s.%N", such as 1502758855.907197692</span></span><br><span class="line">    start_time=<span class="variable">$1</span></span><br><span class="line">    end_time=<span class="variable">$2</span></span><br><span class="line">    </span><br><span class="line">    start_s=<span class="variable">$&#123;start_time%.*&#125;</span></span><br><span class="line">    start_nanos=<span class="variable">$&#123;start_time#*.&#125;</span></span><br><span class="line">    end_s=<span class="variable">$&#123;end_time%.*&#125;</span></span><br><span class="line">    end_nanos=<span class="variable">$&#123;end_time#*.&#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># end_nanos &gt; start_nanos? </span></span><br><span class="line">    <span class="comment"># Another way, the time part may start with 0, which means</span></span><br><span class="line">    <span class="comment"># it will be regarded as oct format, use "10#" to ensure</span></span><br><span class="line">    <span class="comment"># calculateing with decimal</span></span><br><span class="line">    <span class="keyword">if</span> [ <span class="string">"<span class="variable">$end_nanos</span>"</span> -lt <span class="string">"<span class="variable">$start_nanos</span>"</span> ];<span class="keyword">then</span></span><br><span class="line">        end_s=$(( 10<span class="comment">#$end_s - 1 ))</span></span><br><span class="line">        end_nanos=$(( 10<span class="comment">#$end_nanos + 10**9 ))</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># get timediff</span></span><br><span class="line">    time=$(( 10<span class="comment">#$end_s - 10#$start_s )).`printf "%03d\n" $(( (10#$end_nanos - 10#$start_nanos)/10**6 ))`</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$time</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#start=$(date +"%s.%N")</span></span><br><span class="line"><span class="comment"># Now exec some command</span></span><br><span class="line"><span class="comment">#end=$(date +"%s.%N")</span></span><br><span class="line"><span class="comment"># here give the values</span></span><br><span class="line">start=1502758855.907197692</span><br><span class="line">end=1502758865.066894173</span><br><span class="line"></span><br><span class="line">timediff <span class="variable">$start</span> <span class="variable">$end</span></span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/f-ck-need-u/p/7426987.html" target="_blank" rel="noopener">https://www.cnblogs.com/f-ck-need-u/p/7426987.html</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>gdb 调试</title>
    <url>/2019-04-03-gdb-%E8%B0%83%E8%AF%95.html</url>
    <content><![CDATA[<h1 id="gdb调试"><a href="#gdb调试" class="headerlink" title="gdb调试"></a>gdb调试</h1><p>以前学习过，用得少，又忘记了，现在刚好为了调试redis 的dict 模块，所以再次记录。</p>
<a id="more"></a>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>摘自参考<a href="&lt;https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/gdb.html">&lt;https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/gdb.html</a>&gt;。 主要是补充实例</p>
<p>对C/C++程序的调试，需要在编译前就加上-g选项:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$g++ -g hello.cpp -o hello</span><br></pre></td></tr></table></figure>
<p>自己的Makefile里面修改成：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dict-benchmark: dict.c sds.c siphash.c</span><br><span class="line">        $(CC) -g -o $@ $^</span><br></pre></td></tr></table></figure>
<p>但是好像没加之前也是可以直接就使用gdb  了？ 不知道为什么（可以使用但是出错不会显示所在的行，相当于没有调试）</p>
<p>调试可执行文件:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$gdb &lt;program&gt;</span><br></pre></td></tr></table></figure>
<p>program也就是你的执行文件，一般在当前目录下。</p>
<p>调试core文件(core是程序非法执行后core dump后产生的文件):</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$gdb &lt;program&gt; &lt;core dump file&gt;</span><br><span class="line">$gdb program core.11127</span><br></pre></td></tr></table></figure>
<p>调试服务程序:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$gdb &lt;program&gt; &lt;PID&gt;</span><br><span class="line">$gdb hello 11127</span><br></pre></td></tr></table></figure>
<p>如果你的程序是一个服务程序，那么你可以指定这个服务程序运行时的进程ID。gdb会自动attach上去，并调试他。program应该在PATH环境变量中搜索得到。</p>
<h2 id="gdb交互命令"><a href="#gdb交互命令" class="headerlink" title="gdb交互命令"></a>gdb交互命令</h2><p>启动gdb后，进入到交互模式，通过以下命令完成对程序的调试；注意高频使用的命令一般都会有缩写，熟练使用这些缩写命令能提高调试的效率；</p>
<h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><ul>
<li>run：简记为 r ，其作用是运行程序，当遇到断点后，程序会在断点处停止运行，等待用户输入下一步的命令。</li>
<li>continue （简写c ）：继续执行，到下一个断点处（或运行结束）</li>
<li>next：（简写 n），单步跟踪程序，当遇到函数调用时，也不进入此函数体；此命令同 step 的主要区别是，step 遇到用户自定义的函数，将步进到函数中去运行，而 next 则直接调用函数，不会进入到函数体内。</li>
<li>step （简写s）：单步调试如果有函数调用，则进入函数；与命令n不同，n是不进入调用的函数的</li>
<li>until：当你厌倦了在一个循环体内单步跟踪时，这个命令可以运行程序直到退出循环体。</li>
<li>until+行号： 运行至某行，不仅仅用来跳出循环</li>
<li>finish： 运行程序，直到当前函数完成返回，并打印函数返回时的堆栈地址和返回值及参数值等信息。</li>
<li>call 函数(参数)：调用程序中可见的函数，并传递“参数”，如：call gdb_test(55)</li>
<li>quit：简记为 q ，退出gdb</li>
</ul>
<h3 id="设置断点"><a href="#设置断点" class="headerlink" title="设置断点"></a>设置断点</h3><ul>
<li><p>break n （简写b n）:在第n行处设置断点</p>
<p>（可以带上代码路径和代码名称： b OAGUPDATE.cpp:578）</p>
</li>
<li><p>b fn1 if a＞b：条件断点设置</p>
</li>
<li><p>break func（break缩写为b）：在函数func()的入口处设置断点，如：break cb_button</p>
</li>
<li><p>delete 断点号n：删除第n个断点</p>
</li>
<li><p>disable 断点号n：暂停第n个断点</p>
</li>
<li><p>enable 断点号n：开启第n个断点</p>
</li>
<li><p>clear 行号n：清除第n行的断点</p>
</li>
<li><p>info b （info breakpoints） ：显示当前程序的断点设置情况</p>
</li>
<li><p>delete breakpoints：清除所有断点：</p>
</li>
</ul>
<h3 id="查看源代码"><a href="#查看源代码" class="headerlink" title="查看源代码"></a>查看源代码</h3><ul>
<li>list ：简记为 l ，其作用就是列出程序的源代码，默认每次显示10行。</li>
<li>list 行号：将显示当前文件以“行号”为中心的前后10行代码，如：list 12</li>
<li>list 函数名：将显示“函数名”所在函数的源代码，如：list main</li>
<li>list ：不带参数，将接着上一次 list 命令的，输出下边的内容。</li>
</ul>
<h3 id="打印表达式"><a href="#打印表达式" class="headerlink" title="打印表达式"></a>打印表达式</h3><ul>
<li>print 表达式：简记为 p ，其中“表达式”可以是任何当前正在被测试程序的有效表达式，比如当前正在调试C语言的程序，那么“表达式”可以是任何C语言的有效表达式，包括数字，变量甚至是函数调用。</li>
<li>print a：将显示整数 a 的值</li>
<li>print ++a：将把 a 中的值加1,并显示出来</li>
<li>print name：将显示字符串 name 的值</li>
<li>print gdb_test(22)：将以整数22作为参数调用 gdb_test() 函数</li>
<li>print gdb_test(a)：将以变量 a 作为参数调用 gdb_test() 函数</li>
<li>display 表达式：在单步运行时将非常有用，使用display命令设置一个表达式后，它将在每次单步进行指令后，紧接着输出被设置的表达式及值。如： display a</li>
<li>watch 表达式：设置一个监视点，一旦被监视的“表达式”的值改变，gdb将强行终止正在被调试的程序。如： watch a</li>
<li>whatis ：查询变量或函数</li>
<li>info function： 查询函数</li>
<li>扩展info locals： 显示当前堆栈页的所有变量</li>
</ul>
<h3 id="查询运行信息"><a href="#查询运行信息" class="headerlink" title="查询运行信息"></a>查询运行信息</h3><ul>
<li>where/bt ：当前运行的堆栈列表；</li>
<li>bt backtrace 显示当前调用堆栈</li>
<li>up/down 改变堆栈显示的深度</li>
<li>set args 参数:指定运行时的参数</li>
<li>show args：查看设置好的参数</li>
<li>info program： 来查看程序的是否在运行，进程号，被暂停的原因。</li>
</ul>
<h3 id="分割窗口"><a href="#分割窗口" class="headerlink" title="分割窗口"></a>分割窗口</h3><ul>
<li>layout：用于分割窗口，可以一边查看代码，一边测试：</li>
<li>layout src：显示源代码窗口</li>
<li>layout asm：显示反汇编窗口</li>
<li>layout regs：显示源代码/反汇编和CPU寄存器窗口</li>
<li>layout split：显示源代码和反汇编窗口</li>
<li>Ctrl + L：刷新窗口</li>
</ul>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>调试程序dict-benchmark</p>
<p>开始调试：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@hw103:/home/yky/test/redis_dict/dict-benchmark# gdb dict-benchmark </span><br><span class="line">GNU gdb (Ubuntu 7.11.1-0ubuntu1~16.5) 7.11.1</span><br><span class="line">Copyright (C) 2016 Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.  Type &quot;show copying&quot;</span><br><span class="line">and &quot;show warranty&quot; for details.</span><br><span class="line">This GDB was configured as &quot;x86_64-linux-gnu&quot;.</span><br><span class="line">Type &quot;show configuration&quot; for configuration details.</span><br><span class="line">For bug reporting instructions, please see:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/bugs/&gt;.</span><br><span class="line">Find the GDB manual and other documentation resources online at:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/documentation/&gt;.</span><br><span class="line">For help, type &quot;help&quot;.</span><br><span class="line">Type &quot;apropos word&quot; to search for commands related to &quot;word&quot;...</span><br><span class="line">Reading symbols from dict-benchmark...done.</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure>
<p>使用 r 运行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) r</span><br><span class="line">Starting program: /home/yky/test/redis_dict/dict-benchmark/dict-benchmark </span><br><span class="line">Add elements to dict</span><br><span class="line">Add ret0 is :0, ht[0].used:1, ht[0].size:4,ht[1].used:0, ht[1].size:0</span><br><span class="line">Add ret1 is :0, ht[0].used:2, ht[0].size:4,ht[1].used:0, ht[1].size:0</span><br><span class="line">Add ret2 is :0, ht[0].used:3, ht[0].size:4,ht[1].used:0, ht[1].size:0</span><br><span class="line"></span><br><span class="line">Program received signal SIGSEGV, Segmentation fault.</span><br><span class="line">0x000000000040288b in _dictKeyIndex (d=0x60a050, key=0x60a011, hash=3050426978, existing=0x0) at dict.c:975</span><br><span class="line">975                 if (key==he-&gt;key || dictCompareKeys(d, key, he-&gt;key)) &#123;</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure>
<p>在_dictKeyIndex ()函数也就是计算索引的时候出错。</p>
<p>l 列出代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) l</span><br><span class="line">970         for (table = 0; table &lt;= 1; table++) &#123;</span><br><span class="line">971             idx = hash &amp; d-&gt;ht[table].sizemask;</span><br><span class="line">972             /* Search if this slot does not already contain the given key */</span><br><span class="line">973             he = d-&gt;ht[table].table[idx];</span><br><span class="line">974             while(he) &#123;</span><br><span class="line">975                 if (key==he-&gt;key || dictCompareKeys(d, key, he-&gt;key)) &#123;</span><br><span class="line">976                     if (existing) *existing = he;</span><br><span class="line">977                     return -1;</span><br><span class="line">978                 &#125;</span><br><span class="line">979                 he = he-&gt;next;</span><br></pre></td></tr></table></figure>
<p>在975行加入断点  b n</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) b 975</span><br><span class="line">Breakpoint 2 at 0x402887: file dict.c, line 975.</span><br></pre></td></tr></table></figure>
<p>输出对应变量的值：print</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) print key </span><br><span class="line">$1 = (const void *) 0x60a011</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/gdb.html" target="_blank" rel="noopener">https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/gdb.html</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>gdb</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 学习</title>
    <url>/2019-04-01-Docker-%E5%AD%A6%E4%B9%A0.html</url>
    <content><![CDATA[<h1 id="Docker-学习"><a href="#Docker-学习" class="headerlink" title="Docker 学习"></a>Docker 学习</h1><p>之前一直听说容器可以免去配置环境的麻烦，但是一直没有机会接触，现在刚好有机会可以使用。</p>
<a id="more"></a>
<h2 id="三大基础"><a href="#三大基础" class="headerlink" title="三大基础"></a>三大基础</h2><p>镜像、容器、仓库</p>
<p>类比的话：镜像是类（iso），容器是实例（操作系统），仓库类似于git的仓库。</p>
<p>镜像的构建是一层层的继承而来的，镜像和容器都是文件，容器退出的时候容器文件依然存在。除非手动使用-rm指定，才会删除。</p>
<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p>加载镜像，进入一个新的容器：<code>docker run image:tag command</code></p>
<p>实例 摘自：<a href="https://yeasy.gitbooks.io/docker_practice/image/pull.html" target="_blank" rel="noopener">https://yeasy.gitbooks.io/docker_practice/image/pull.html</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -it --rm \</span><br><span class="line">    ubuntu:18.04 \</span><br><span class="line">    bash</span><br></pre></td></tr></table></figure>
<p><code>docker run</code> 就是运行容器的命令 从镜像中新建一个容器</p>
<ul>
<li><code>-it</code>：这是两个参数，一个是 <code>-i</code>：交互式操作，一个是 <code>-t</code> 终端。我们这里打算进入 <code>bash</code> 执行一些命令并查看返回结果，因此我们需要交互式终端。</li>
<li><code>--rm</code>：这个参数是说容器退出后随之将其删除。默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动 <code>docker rm</code>。我们这里只是随便执行个命令，看看结果，不需要排障和保留结果，因此使用 <code>--rm</code> 可以避免浪费空间。</li>
<li><code>ubuntu:18.04</code>：这是指用 <code>ubuntu:18.04</code> 镜像为基础来启动容器。</li>
<li><code>bash</code>：放在镜像名后的是<strong>命令</strong>，这里我们希望有个交互式 Shell，因此用的是 <code>bash</code>。</li>
</ul>
<p>退出: 在容器中<code>exit</code></p>
<p>进入容器：</p>
<p><code>docker exec</code>  进入一个已有的容器。 （容器需要已经运行）</p>
<p><code>dcoker cp</code>  容器的复制</p>
<p><code>docker ps</code> 列出启动容器 <code>docker ps -a</code> 列出所有容器包括关闭的。</p>
<p>启动之前关闭的容器： <code>docker start container-name</code> ， </p>
<p>需要先启动容器，才能执行<code>docker exec  container-name</code></p>
<h2 id="端口映射"><a href="#端口映射" class="headerlink" title="端口映射"></a>端口映射</h2><p><a href="https://blog.csdn.net/wanglei_storage/article/details/48471753" target="_blank" rel="noopener">https://blog.csdn.net/wanglei_storage/article/details/48471753</a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.im/entry/5b19e350e51d45069f5e1d66" target="_blank" rel="noopener">https://juejin.im/entry/5b19e350e51d45069f5e1d66</a></p>
<p><a href="https://yeasy.gitbooks.io/docker_practice/basic_concept/container.html" target="_blank" rel="noopener">https://yeasy.gitbooks.io/docker_practice/basic_concept/container.html</a></p>
<p><a href="https://blog.csdn.net/u010246789/article/details/53958662" target="_blank" rel="noopener">https://blog.csdn.net/u010246789/article/details/53958662</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>容器</tag>
      </tags>
  </entry>
  <entry>
    <title>计算Linux系统的CPU利用率</title>
    <url>/2019-03-31-%E8%AE%A1%E7%AE%97Linux%E7%B3%BB%E7%BB%9F%E7%9A%84CPU%E5%88%A9%E7%94%A8%E7%8E%87.html</url>
    <content><![CDATA[<h1 id="计算Linux系统的CPU利用率"><a href="#计算Linux系统的CPU利用率" class="headerlink" title="计算Linux系统的CPU利用率"></a>计算Linux系统的CPU利用率</h1><p>通过读取系统的/proc/stat 信息来计算CPU的利用率</p>
<a id="more"></a>
<h2 id="cpu-信息的读取"><a href="#cpu-信息的读取" class="headerlink" title="cpu 信息的读取"></a>cpu 信息的读取</h2><p>摘自参考博客：<a href="https://blog.csdn.net/x_i_y_u_e/article/details/50684508" target="_blank" rel="noopener">https://blog.csdn.net/x_i_y_u_e/article/details/50684508</a></p>
<p>在Linux/Unix下，CPU利用率分为用户态，系统态和空闲态，分别表示CPU处于用户态执行的时间，系统内核执行的时间，和空闲系统进程执行的时间。平时所说的CPU利用率是指：CPU执行非系统空闲进程的时间 / CPU总的执行时间。</p>
<p>在Linux的内核中，有一个全局变量：Jiffies。 Jiffies代表时间。它的单位随硬件平台的不同而不同。系统里定义了一个常数HZ，代表每秒种最小时间间隔的数目。这样jiffies的单位就是1/HZ。Intel平台jiffies的单位是1/100秒，这就是系统所能分辨的最小时间间隔了。每个CPU时间片，Jiffies都要加1。 CPU的利用率就是用执行用户态+系统态的Jiffies除以总的Jifffies来表示。</p>
<p>在Linux系统中，可以用/proc/stat文件来计算cpu的利用率(详细的解释可参考：<a href="http://www.linuxhowtos.org/System/procstat.htm" target="_blank" rel="noopener">http://www.linuxhowtos.org/System/procstat.htm</a>)。这个文件包含了所有CPU活动的信息，该文件中的所有值都是从系统启动开始累计到当前时刻。</p>
<p>在本机上的信息如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> root@hw103:/home/yky# cat/proc/stat </span><br><span class="line">cpu  7283854 35392 293546 204419077 75835 0 8385 0 0 0</span><br><span class="line">cpu0 365010 48 18204 8453603 767 0 4306 0 0 0</span><br><span class="line">cpu1 292817 9 14990 8526563 1358 0 2114 0 0 0</span><br><span class="line">cpu2 286689 0 11880 8538662 1033 0 752 0 0 0</span><br><span class="line">cpu3 287106 14624 12945 8523209 641 0 320 0 0 0</span><br><span class="line">cpu4 293293 0 11784 8532282 604 0 147 0 0 0</span><br><span class="line">cpu5 371312 2824 13669 8408187 40794 0 406 0 0 0</span><br><span class="line">cpu6 358116 10934 14014 8453775 1230 0 68 0 0 0</span><br><span class="line">cpu7 313971 6281 12243 8504303 1575 0 28 0 0 0</span><br><span class="line">cpu8 318084 0 11598 8506770 2036 0 15 0 0 0</span><br><span class="line">cpu9 294503 0 11137 8530318 2185 0 10 0 0 0</span><br><span class="line">cpu10 307922 144 12434 8516570 1177 0 15 0 0 0</span><br><span class="line">cpu11 291752 0 11502 8533957 1128 0 4 0 0 0</span><br><span class="line">cpu12 315096 0 15927 8503001 3528 0 3 0 0 0</span><br><span class="line">cpu13 375976 0 17927 8442873 2041 0 1 0 0 0</span><br><span class="line">cpu14 299344 0 10140 8523716 2818 0 1 0 0 0</span><br><span class="line">cpu15 288470 3 10146 8538685 1240 0 0 0 0 0</span><br><span class="line">cpu16 301148 0 10681 8523612 2185 0 0 0 0 0</span><br><span class="line">cpu17 263183 4 9149 8565345 771 0 0 0 0 0</span><br><span class="line">cpu18 262518 370 10343 8562955 2105 0 11 0 0 0</span><br><span class="line">cpu19 280230 3 10399 8546414 1227 0 6 0 0 0</span><br><span class="line">cpu20 278962 0 10346 8547585 1221 0 9 0 0 0</span><br><span class="line">cpu21 277042 143 11502 8547940 1048 0 2 0 0 0</span><br><span class="line">cpu22 275560 0 9458 8549093 1271 0 153 0 0 0</span><br><span class="line">cpu23 285740 0 11118 8539648 1838 0 6 0 0 0</span><br><span class="line">intr 91288599 43 2 0 0 0 0 0 0 1 0 0 0 4 0 0 0 41 0 2 0 0 0 0 0 0 0 334158 0 1 2473208 45518 96917 44876 138077 45263 45258 54441 0 0 44198 44198 44198 44198 44198 44198 441</span><br><span class="line">98 44198 0 0 44198 44198 44198 44198 44198 44198 44198 44198 0 0 44199 44199 44199 44199 44199 44199 44199 44199 0 0 44199 44199 44199 44199 44199 44199 44199 44199 0 0 44198 44198 44198 44198 44198 44198 44198 44198 0 0 44198 44198 44198 44198 44198 44198 44198 44198 0 0 44199 44199 44199 44199 44199 44199 44199 44199 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0ctxt 42731429</span><br><span class="line">btime 1553933982</span><br><span class="line">processes 190449</span><br><span class="line">procs_running 5</span><br><span class="line">procs_blocked 0</span><br><span class="line">softirq 57291816 8 26401645 17536 5419485 334063 0 1044 10019160 0 15098875</span><br></pre></td></tr></table></figure>
<p>第一行cpu是总的cpu信息，其他的cpu0-cpu23 是24个核的信息。</p>
<p>计算cpu利用率只用到前7个参数， 对应的参数解释为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	 user	 nice  system idle      iowait   irq  softirq</span><br><span class="line">cpu  7283854 35392 293546 204419077 75835    0    8385</span><br></pre></td></tr></table></figure>
<p>user (7283854) 从系统启动开始累计到当前时刻，用户态的CPU时间（单位：jiffies） ，不包含 nice值为负进程。1jiffies=0.01秒<br>nice (35392) 从系统启动开始累计到当前时刻，nice值为负的进程所占用的CPU时间（单位：jiffies）<br>system (293546) 从系统启动开始累计到当前时刻，核心时间（单位：jiffies）<br>idle (204419077) 从系统启动开始累计到当前时刻，除硬盘IO等待时间以外其它等待时间（单位：jiffies）<br>iowait (75835) 从系统启动开始累计到当前时刻，硬盘IO等待时间（单位：jiffies） ，<br>irq (0) 从系统启动开始累计到当前时刻，硬中断时间（单位：jiffies）<br>softirq (8385) 从系统启动开始累计到当前时刻，软中断时间（单位：jiffies）</p>
<p>CPU时间=user+system+nice+idle+iowait+irq+softirq</p>
<p>“intr”这行给出中断的信息，第一个为自系统启动以来，发生的所有的中断的次数；然后每个数对应一个特定的中断自系统启动以来所发生的次数。<br>“ctxt”给出了自系统启动以来CPU发生的上下文交换的次数。<br>“btime”给出了从系统启动到现在为止的时间，单位为秒。<br>“processes (total_forks) 自系统启动以来所创建的任务的个数目。<br>“procs_running”：当前运行队列的任务的数目。<br>“procs_blocked”：当前被阻塞的任务的数目。</p>
<p>计算cpu利用率的方法就是计算出在一段时间里面，cpu工作的时间/总得时间</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cpu usage=(idle2-idle1)/(cpu2-cpu1)*100</span><br><span class="line">cpu usage=[(user_2 +sys_2+nice_2) - (user_1 + sys_1+nice_1)]/(total_2 - total_1)*100</span><br></pre></td></tr></table></figure>
<p>第二中方法只把user+sys+nice 这三个时间看作cpu的工作时间，因为其他的几个比较小。</p>
<h2 id="shell脚本"><a href="#shell脚本" class="headerlink" title="shell脚本"></a>shell脚本</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#echo user nice system idle iowait irq softirq</span></span></span><br><span class="line"></span><br><span class="line">cpulog_start=$(cat /proc/stat | grep 'cpu'| awk 'NR==1&#123;print $2 "\t" $3 "\t" $4 "\t" $5 "\t" $6 "\t" $7 "\t" $8&#125;' )</span><br><span class="line">cpu_use_start=$(echo $cpulog_start | awk '&#123;print $1+$2+$3&#125;')</span><br><span class="line">cpu_iowait_start=$(echo $cpulog_start | awk '&#123;print $5&#125;')</span><br><span class="line">cpu_total_start=$(echo $cpulog_start | awk '&#123;print $1+$2+$3+$4+$5+$6+$7&#125;')</span><br><span class="line"></span><br><span class="line">sleep 10</span><br><span class="line"></span><br><span class="line">cpulog_end=$(cat /proc/stat | grep 'cpu'| awk 'NR==1&#123;print $2 "\t" $3 "\t" $4 "\t" $5 "\t" $6 "\t" $7 "\t" $8&#125;' )</span><br><span class="line">cpu_use_end=$(echo $cpulog_end | awk '&#123;print $1+$2+$3&#125;')</span><br><span class="line">cpu_iowait_end=$(echo $cpulog_end | awk '&#123;print $5&#125;')</span><br><span class="line">cpu_total_end=$(echo $cpulog_end | awk '&#123;print $1+$2+$3+$4+$5+$6+$7&#125;')</span><br><span class="line"></span><br><span class="line">cpu_use_diff=`expr $cpu_use_end - $cpu_use_start`</span><br><span class="line">cpu_iowait_diff=`expr $cpu_iowait_end - $cpu_iowait_start`</span><br><span class="line">cpu_total_diff=`expr $cpu_total_end - $cpu_total_start`</span><br><span class="line"></span><br><span class="line">cpu_use_rate=`expr $cpu_use_diff/$cpu_total_diff*100 | bc -l`</span><br><span class="line">cpu_iowait_rate=`expr $cpu_iowait_diff/$cpu_total_diff*100 | bc -l`</span><br><span class="line"></span><br><span class="line">echo "---------------cpuinfo----------------------"</span><br><span class="line">echo "cpu_usage_rate (%) : $cpu_use_rate"</span><br><span class="line">echo "cpu_iowait_rate (%): $cpu_iowait_rate"</span><br></pre></td></tr></table></figure>
<p>主要的知识点讲解：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cpulog_start=$(cat /proc/stat | grep 'cpu'| awk 'NR==1&#123;print $2 "\t" $3 "\t" $4 "\t" $5 "\t" $6 "\t" $7 "\t" $8&#125;' )</span><br></pre></td></tr></table></figure>
<p>这一句先将/proc/stat文件的信息读取出来然后用管道| 传递给grep 命令 ,grep 将包含cpu的信息给提取出来</p>
<p><code>cat /proc/stat | grep &#39;cpu&#39;</code> 输出为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@hw103:/home/yky<span class="comment"># cat /proc/stat | grep 'cpu'</span></span><br><span class="line">cpu  7645369 35392 318219 206250476 80895 0 9870 0 0 0</span><br><span class="line">cpu0 365256 48 18792 8544685 767 0 5678 0 0 0</span><br><span class="line">cpu1 292983 9 15427 8618292 1389 0 2206 0 0 0</span><br><span class="line">cpu2 287020 0 12884 8629895 1033 0 760 0 0 0</span><br><span class="line">cpu3 288372 14624 13910 8613386 681 0 320 0 0 0</span><br><span class="line">cpu4 293707 0 13074 8623117 646 0 147 0 0 0</span><br><span class="line">cpu5 390012 2824 15130 8477387 44027 0 418 0 0 0</span><br><span class="line">cpu6 362140 10934 15217 8541127 1233 0 69 0 0 0</span><br><span class="line">cpu7 377620 6281 12915 8532734 1700 0 28 0 0 0</span><br><span class="line">cpu8 333520 0 12524 8582987 2100 0 15 0 0 0</span><br><span class="line">cpu9 348913 0 12619 8567005 2453 0 10 0 0 0</span><br><span class="line">cpu10 333584 144 14002 8581939 1297 0 15 0 0 0</span><br><span class="line">cpu11 292980 0 12966 8623861 1137 0 4 0 0 0</span><br><span class="line">cpu12 350188 0 16793 8559301 4017 0 3 0 0 0</span><br><span class="line">cpu13 430200 0 19278 8479849 2344 0 1 0 0 0</span><br><span class="line">cpu14 312421 0 11483 8601843 2906 0 1 0 0 0</span><br><span class="line">cpu15 343656 3 10768 8575706 1268 0 0 0 0 0</span><br><span class="line">cpu16 302673 0 12190 8613170 2190 0 0 0 0 0</span><br><span class="line">cpu17 263473 4 9906 8656857 771 0 0 0 0 0</span><br><span class="line">cpu18 263094 370 11278 8653940 2165 0 11 0 0 0</span><br><span class="line">cpu19 281216 3 11166 8637253 1280 0 6 0 0 0</span><br><span class="line">cpu20 280412 0 11645 8637433 1221 0 9 0 0 0</span><br><span class="line">cpu21 277219 143 11967 8639929 1048 0 2 0 0 0</span><br><span class="line">cpu22 275894 0 10291 8640508 1271 0 153 0 0 0</span><br><span class="line">cpu23 298806 0 11985 8618261 1939 0 6 0 0 0</span><br></pre></td></tr></table></figure>
<h3 id="awk-命令"><a href="#awk-命令" class="headerlink" title="awk 命令"></a>awk 命令</h3><p>之后使用awk命令再次进行操作。这个命令之前用的很少，参考《鸟哥的Linux私房菜》介绍：</p>
<p>sed常用于一整行的处理，awk则倾向于将一行分成数个“字段”来处理，awk适合处理小型的数据。</p>
<p>用法为：</p>
<p><code>awk &#39;条件类型1{操作1} 条件类型1{操作2}...&#39;  filename</code></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>变量名称</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>NF</td>
<td>每一行（$0） 拥有的字段总数</td>
</tr>
<tr>
<td>NR</td>
<td>awk当前处理的第几行数据</td>
</tr>
<tr>
<td>FS</td>
<td>目前的分割符，默认空格键</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cpulog_start=$(cat /proc/stat | grep 'cpu'| awk 'NR==1&#123;print $2 "\t" $3 "\t" $4 "\t" $5 "\t" $6 "\t" $7 "\t" $8&#125;' )</span><br></pre></td></tr></table></figure>
<p><code>NR==1</code> 限定条件为第一行，因为第一行的数据才是cpu的总信息，{}里面的操作是输出字段，$N 就是第N个字段。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> $1	$2		$3		$4	  $5		$6		 $7	  $8</span><br><span class="line">     user	 nice  system idle      iowait   irq  softirq</span><br><span class="line">cpu  7283854 35392 293546 204419077 75835    0    8385</span><br></pre></td></tr></table></figure>
<h3 id="expr"><a href="#expr" class="headerlink" title="expr"></a>expr</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cpu_use_diff=`expr <span class="variable">$cpu_use_end</span> - <span class="variable">$cpu_use_start</span>`</span><br></pre></td></tr></table></figure>
<p>使用expr 执行变量计算，然后是`` 进行反引用将值赋值给cpu_use_diff</p>
<p>注意shell 脚本中= 不能用空格分开 需要直接相邻</p>
<h3 id="bc-命令"><a href="#bc-命令" class="headerlink" title="bc 命令"></a>bc 命令</h3><p>bc 命令是任意精度计算器语言，通常在linux下当计算器用。</p>
<p>简单的描述参考：<a href="http://www.runoob.com/linux/linux-comm-bc.html" target="_blank" rel="noopener">http://www.runoob.com/linux/linux-comm-bc.html</a></p>
<p>而expr命令不支持小数运算，所以需要使用bc进行计算。</p>
<p>语法为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bc(选项)(参数)</span><br></pre></td></tr></table></figure>
<p><strong>选项值</strong></p>
<ul>
<li>-i：强制进入交互式模式；</li>
<li>-l：定义使用的标准数学库</li>
<li>； -w：对POSIX bc的扩展给出警告信息；</li>
<li>-q：不打印正常的GNU bc环境信息；</li>
<li>-v：显示指令版本信息；</li>
<li>-h：显示指令的帮助信息。</li>
</ul>
<p><strong>参数</strong></p>
<p>文件：指定包含计算任务的文件。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/x_i_y_u_e/article/details/50684508" target="_blank" rel="noopener">https://blog.csdn.net/x_i_y_u_e/article/details/50684508</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>shell</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis设计与实现读书笔记——第8章 对象</title>
    <url>/2019-03-29-Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E7%AC%AC8%E7%AB%A0-%E5%AF%B9%E8%B1%A1.html</url>
    <content><![CDATA[<h1 id="Redis设计与实现读书笔记——第8章-对象"><a href="#Redis设计与实现读书笔记——第8章-对象" class="headerlink" title="Redis设计与实现读书笔记——第8章 对象"></a>Redis设计与实现读书笔记——第8章 对象</h1><p>Redis 并没有直接使用sds、dict等数据结构来实现键值对数据库， 而是基于这些数据结构创建了一个对象系统， 这个系统包含字符串对象、列表对象、哈希对象、集合对象和有序集合对象这五种类型的对象， 每种对象都用到了至少一种前面所介绍的数据结构。</p>
<a id="more"></a>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>对象的好处：</p>
<ul>
<li>根据对象的类型来判断是否可以执行给定的命令。</li>
<li>针对不同的使用场景， 为对象设置多种不同的数据结构实现， 从而优化对象在不同场景下的使用效率。</li>
</ul>
<p>对象的特性：</p>
<ul>
<li>基于引用计数技术的内存回收机制（和java的是否原理相似）</li>
<li>通过引用计数技术实现对象共享机制，多个键共享同一个对象来节约内存</li>
<li>带有访问时间记录信息，可以用来删除空转时长较大的键</li>
</ul>
<h2 id="8-1-对象的类型与编码"><a href="#8-1-对象的类型与编码" class="headerlink" title="8.1 对象的类型与编码"></a>8.1 对象的类型与编码</h2><p>Redis 使用对象来表示数据库中的键和值，创建一个新的键值对的时候，至少包含两个对象：1. 键对象 2. 值对象</p>
<p>对象都由一个 <code>redisObject</code> 结构表示，保存数据相关的属性</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="comment">// 对象类型</span></span><br><span class="line">    <span class="keyword">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line">    <span class="comment">// 编码</span></span><br><span class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line">    <span class="comment">//lru 时钟 记录最后被访问的时间，也就是空转时长</span></span><br><span class="line">    <span class="keyword">unsigned</span> lru:LRU_BITS; <span class="comment">/* LRU time (relative to global lru_clock) or</span></span><br><span class="line"><span class="comment">                            * LFU data (least significant 8 bits frequency</span></span><br><span class="line"><span class="comment">                            * and most significant 16 bits decreas time). */</span></span><br><span class="line">    <span class="comment">// 引用计数 实现内存自动回收等。</span></span><br><span class="line">    <span class="keyword">int</span> refcount;</span><br><span class="line">    <span class="comment">// 指向底层实现数据结构的指针</span></span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure>
<p>ptr指向的就是之前的sds，dict这些数据结构的内存地址。</p>
<p>变量申明加冒号的用法： 是C语言的位域的用法。<code>:</code>后面的数字用来限定成员变量占用的位数。冒号后面的数字说明只会用到对应多少个bit位。type只会用到4个bit，encoding 也只会用的4个bit。变量占用的内存不再是有类型决定，而是位域。</p>
<h3 id="8-1-1-类型"><a href="#8-1-1-类型" class="headerlink" title="8.1.1 类型"></a>8.1.1 类型</h3><p>type属性的值包括5种：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">类型常量</th>
<th style="text-align:left">对象的名称</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>REDIS_STRING</code></td>
<td style="text-align:left">字符串对象</td>
</tr>
<tr>
<td style="text-align:left"><code>REDIS_LIST</code></td>
<td style="text-align:left">列表对象</td>
</tr>
<tr>
<td style="text-align:left"><code>REDIS_HASH</code></td>
<td style="text-align:left">哈希对象</td>
</tr>
<tr>
<td style="text-align:left"><code>REDIS_SET</code></td>
<td style="text-align:left">集合对象</td>
</tr>
<tr>
<td style="text-align:left"><code>REDIS_ZSET</code></td>
<td style="text-align:left">有序集合对象</td>
</tr>
</tbody>
</table>
</div>
<p>键对象只能是字符串对象，而值对象则5种之一。所以执行TYPE命令返回的是键值对中值对象的类型。</p>
<p>type命令的</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">对象</th>
<th style="text-align:left">对象 <code>type</code> 属性的值</th>
<th style="text-align:left">TYPE 命令的输出</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">字符串对象</td>
<td style="text-align:left"><code>REDIS_STRING</code></td>
<td style="text-align:left"><code>&quot;string&quot;</code></td>
</tr>
<tr>
<td style="text-align:left">列表对象</td>
<td style="text-align:left"><code>REDIS_LIST</code></td>
<td style="text-align:left"><code>&quot;list&quot;</code></td>
</tr>
<tr>
<td style="text-align:left">哈希对象</td>
<td style="text-align:left"><code>REDIS_HASH</code></td>
<td style="text-align:left"><code>&quot;hash&quot;</code></td>
</tr>
<tr>
<td style="text-align:left">集合对象</td>
<td style="text-align:left"><code>REDIS_SET</code></td>
<td style="text-align:left"><code>&quot;set&quot;</code></td>
</tr>
<tr>
<td style="text-align:left">有序集合对象</td>
<td style="text-align:left"><code>REDIS_ZSET</code></td>
<td style="text-align:left"><code>&quot;zset&quot;</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="8-2-编码和底层实现"><a href="#8-2-编码和底层实现" class="headerlink" title="8.2 编码和底层实现"></a>8.2 编码和底层实现</h3><p>ptr指向底层数据结构，而encoding则决定了具体应该指向什么样的数据结构实现。之所以不能用type来决定指向的具体数据结构，是因为同一种对象，但是底层实现会有不同的数据结构。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">编码常量</th>
<th style="text-align:left">编码所对应的底层数据结构</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>REDIS_ENCODING_INT</code></td>
<td style="text-align:left"><code>long</code> 类型的整数</td>
</tr>
<tr>
<td style="text-align:left"><code>REDIS_ENCODING_EMBSTR</code></td>
<td style="text-align:left"><code>embstr</code> 编码的简单动态字符串</td>
</tr>
<tr>
<td style="text-align:left"><code>REDIS_ENCODING_RAW</code></td>
<td style="text-align:left">简单动态字符串</td>
</tr>
<tr>
<td style="text-align:left"><code>REDIS_ENCODING_HT</code></td>
<td style="text-align:left">字典</td>
</tr>
<tr>
<td style="text-align:left"><code>REDIS_ENCODING_LINKEDLIST</code></td>
<td style="text-align:left">双端链表</td>
</tr>
<tr>
<td style="text-align:left"><code>REDIS_ENCODING_ZIPLIST</code></td>
<td style="text-align:left">压缩列表</td>
</tr>
<tr>
<td style="text-align:left"><code>REDIS_ENCODING_INTSET</code></td>
<td style="text-align:left">整数集合</td>
</tr>
<tr>
<td style="text-align:left"><code>REDIS_ENCODING_SKIPLIST</code></td>
<td style="text-align:left">跳跃表和字典</td>
</tr>
</tbody>
</table>
</div>
<p>每种类型的对象都至少使用了两种不同的编码，对应关系为：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">类型</th>
<th style="text-align:left">编码</th>
<th style="text-align:left">对象</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>REDIS_STRING</code></td>
<td style="text-align:left"><code>REDIS_ENCODING_INT</code></td>
<td style="text-align:left">使用整数值实现的字符串对象。</td>
</tr>
<tr>
<td style="text-align:left"><code>REDIS_STRING</code></td>
<td style="text-align:left"><code>REDIS_ENCODING_EMBSTR</code></td>
<td style="text-align:left">使用 <code>embstr</code> 编码的简单动态字符串实现的字符串对象。</td>
</tr>
<tr>
<td style="text-align:left"><code>REDIS_STRING</code></td>
<td style="text-align:left"><code>REDIS_ENCODING_RAW</code></td>
<td style="text-align:left">使用简单动态字符串实现的字符串对象。</td>
</tr>
<tr>
<td style="text-align:left"><code>REDIS_LIST</code></td>
<td style="text-align:left"><code>REDIS_ENCODING_ZIPLIST</code></td>
<td style="text-align:left">使用压缩列表实现的列表对象。</td>
</tr>
<tr>
<td style="text-align:left"><code>REDIS_LIST</code></td>
<td style="text-align:left"><code>REDIS_ENCODING_LINKEDLIST</code></td>
<td style="text-align:left">使用双端链表实现的列表对象。</td>
</tr>
<tr>
<td style="text-align:left"><code>REDIS_HASH</code></td>
<td style="text-align:left"><code>REDIS_ENCODING_ZIPLIST</code></td>
<td style="text-align:left">使用压缩列表实现的哈希对象。</td>
</tr>
<tr>
<td style="text-align:left"><code>REDIS_HASH</code></td>
<td style="text-align:left"><code>REDIS_ENCODING_HT</code></td>
<td style="text-align:left">使用字典实现的哈希对象。</td>
</tr>
<tr>
<td style="text-align:left"><code>REDIS_SET</code></td>
<td style="text-align:left"><code>REDIS_ENCODING_INTSET</code></td>
<td style="text-align:left">使用整数集合实现的集合对象。</td>
</tr>
<tr>
<td style="text-align:left"><code>REDIS_SET</code></td>
<td style="text-align:left"><code>REDIS_ENCODING_HT</code></td>
<td style="text-align:left">使用字典实现的集合对象。</td>
</tr>
<tr>
<td style="text-align:left"><code>REDIS_ZSET</code></td>
<td style="text-align:left"><code>REDIS_ENCODING_ZIPLIST</code></td>
<td style="text-align:left">使用压缩列表实现的有序集合对象。</td>
</tr>
<tr>
<td style="text-align:left"><code>REDIS_ZSET</code></td>
<td style="text-align:left"><code>REDIS_ENCODING_SKIPLIST</code></td>
<td style="text-align:left">使用跳跃表和字典实现的有序集合对象。</td>
</tr>
</tbody>
</table>
</div>
<p>使用 OBJECT ENCODING 命令可以查看一个数据库键的值对象的编码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis&gt; SET msg &quot;hello wrold&quot;</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; OBJECT ENCODING msg</span><br><span class="line">&quot;embstr&quot;</span><br></pre></td></tr></table></figure>
<p>不同编码的对象所对应的OBJECT ENCODING输出：</p>
<p>表 8-5 OBJECT ENCODING 对不同编码的输出</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">对象所使用的底层数据结构</th>
<th style="text-align:left">编码常量</th>
<th style="text-align:left">OBJECT ENCODING 命令输出</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">整数</td>
<td style="text-align:left"><code>REDIS_ENCODING_INT</code></td>
<td style="text-align:left"><code>&quot;int&quot;</code></td>
</tr>
<tr>
<td style="text-align:left"><code>embstr</code> 编码的简单动态字符串（SDS）</td>
<td style="text-align:left"><code>REDIS_ENCODING_EMBSTR</code></td>
<td style="text-align:left"><code>&quot;embstr&quot;</code></td>
</tr>
<tr>
<td style="text-align:left">简单动态字符串</td>
<td style="text-align:left"><code>REDIS_ENCODING_RAW</code></td>
<td style="text-align:left"><code>&quot;raw&quot;</code></td>
</tr>
<tr>
<td style="text-align:left">字典</td>
<td style="text-align:left"><code>REDIS_ENCODING_HT</code></td>
<td style="text-align:left"><code>&quot;hashtable&quot;</code></td>
</tr>
<tr>
<td style="text-align:left">双端链表</td>
<td style="text-align:left"><code>REDIS_ENCODING_LINKEDLIST</code></td>
<td style="text-align:left"><code>&quot;linkedlist&quot;</code></td>
</tr>
<tr>
<td style="text-align:left">压缩列表</td>
<td style="text-align:left"><code>REDIS_ENCODING_ZIPLIST</code></td>
<td style="text-align:left"><code>&quot;ziplist&quot;</code></td>
</tr>
<tr>
<td style="text-align:left">整数集合</td>
<td style="text-align:left"><code>REDIS_ENCODING_INTSET</code></td>
<td style="text-align:left"><code>&quot;intset&quot;</code></td>
</tr>
<tr>
<td style="text-align:left">跳跃表和字典</td>
<td style="text-align:left"><code>REDIS_ENCODING_SKIPLIST</code></td>
<td style="text-align:left"><code>&quot;skiplist&quot;</code></td>
</tr>
</tbody>
</table>
</div>
<p>使用encoding属性来设定对象指向的具体数据结构实现的好处：灵活与效率。根据不同场景来给同一种对象设置不同的数据结构实现。</p>
<p>举个例子， 在列表对象包含的元素比较少时， Redis 使用压缩列表作为列表对象的底层实现：</p>
<ul>
<li>因为压缩列表比双端链表更节约内存， 并且在元素数量较少时， 在内存中以连续块方式保存的压缩列表比起双端链表可以更快被载入到缓存中；</li>
<li>随着列表对象包含的元素越来越多， 使用压缩列表来保存元素的优势逐渐消失时， 对象就会将底层实现从压缩列表转向功能更强、也更适合保存大量元素的双端链表上面；</li>
</ul>
<p>是不是也可以理解成多态呢？</p>
<h2 id="8-2-字符串对象"><a href="#8-2-字符串对象" class="headerlink" title="8.2 字符串对象"></a>8.2 字符串对象</h2><p>字符串对象的编码可以是 <code>int</code> 、 <code>raw</code> 或者 <code>embstr</code> 。</p>
<ol>
<li>保存的对象是整数，而且可以用long类型表示：ptr指针指向一个long类型的内存地址。（是不是不用指向sdshdr了），然后将encoding 设置为REDIS_ENCODING_INT (应该在源码中有个宏定义)</li>
<li>保存的对象是字符串值，长度小于44字节（书上的39字节，但是先版本已经更新）。这种短字符串对象，直接<strong>只调用一次内存分配</strong>函数来分配一块<strong>连续的空间</strong>  依次包含redisObject和sdshdr两个结构。</li>
<li>字符串长度大于等于44字节的时候使用raw编码。会调用两次内存分配函数来创建redisObject结构和sdshdr结构。</li>
</ol>
<p>embstr编码的好处：</p>
<ul>
<li>只用分配一次内存，raw编码需要两次</li>
<li>释放embstr的sds也只需要一次内存释放函数，raw两次</li>
<li>embstr的所有数据（对象结构，字符串结构）在连续的一块内存里面，从而可以更好地利用缓存带来的优势</li>
</ul>
<p>embstr和raw的示意图，摘自书上，但是注意sds的结构稍有变化。</p>
<p>raw编码：</p>
<p><img src="http://redisbook.com/_images/graphviz-8731210637d0567af28d3a9d4089d5f864d29950.png" alt=""></p>
<p>embstr编码：</p>
<p><img src="http://redisbook.com/_images/graphviz-900c13b23ce79372939259603be936c955ccaa62.png" alt=""></p>
<p>注意：</p>
<p>long double类型的浮点数是转换成字符串值来保存的。执行的时候取出字符串再转换成long double 类型。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">值</th>
<th style="text-align:left">编码</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">可以用 <code>long</code> 类型保存的整数。</td>
<td style="text-align:left"><code>int</code></td>
</tr>
<tr>
<td style="text-align:left">可以用 <code>long double</code> 类型保存的浮点数。</td>
<td style="text-align:left"><code>embstr</code> 或者 <code>raw</code></td>
</tr>
<tr>
<td style="text-align:left">字符串值， 或者因为长度太大而没办法用 <code>long</code> 类型表示的整数， 又或者因为长度太大而没办法用 <code>long double</code> 类型表示的浮点数。</td>
<td style="text-align:left"><code>embstr</code> 或者 <code>raw</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="8-2-1-编码的转换"><a href="#8-2-1-编码的转换" class="headerlink" title="8.2.1 编码的转换"></a>8.2.1 编码的转换</h3><p>当保存的值发生变化的时候会进行转换，比如保存的整数值变成了字符串，那么编码从int 变成raw或者embstr。</p>
<p><strong>注意</strong>： Redis 没有为embstr编写任何修改程序，只有int和raw编码的字符串对象有这些程序，所以embstr编码的对象是只读，因此发生修改的话会从embstr变成raw。</p>
<p>发生修改的源码中应该是将原来的ptr指向的数据结构内存释放掉后，重新指向新创建的对象。</p>
<h3 id="8-2-2-字符串命令的实现"><a href="#8-2-2-字符串命令的实现" class="headerlink" title="8.2.2 字符串命令的实现"></a>8.2.2 字符串命令的实现</h3><p>所有命令都是针对字符串对象的。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">命令</th>
<th style="text-align:left"><code>int</code> 编码的实现方法</th>
<th style="text-align:left"><code>embstr</code> 编码的实现方法</th>
<th style="text-align:left"><code>raw</code> 编码的实现方法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">SET</td>
<td style="text-align:left">使用 <code>int</code> 编码保存值。</td>
<td style="text-align:left">使用 <code>embstr</code> 编码保存值。</td>
<td style="text-align:left">使用 <code>raw</code> 编码保存值。</td>
</tr>
<tr>
<td style="text-align:left">GET</td>
<td style="text-align:left">拷贝对象所保存的整数值， 将这个拷贝转换成字符串值， 然后向客户端返回这个字符串值。</td>
<td style="text-align:left">直接向客户端返回字符串值。</td>
<td style="text-align:left">直接向客户端返回字符串值。</td>
</tr>
<tr>
<td style="text-align:left">APPEND</td>
<td style="text-align:left">将对象转换成 <code>raw</code> 编码， 然后按 <code>raw</code>编码的方式执行此操作。</td>
<td style="text-align:left">将对象转换成 <code>raw</code> 编码， 然后按 <code>raw</code>编码的方式执行此操作。</td>
<td style="text-align:left">调用 <code>sdscatlen</code> 函数， 将给定字符串追加到现有字符串的末尾。</td>
</tr>
<tr>
<td style="text-align:left">INCRBYFLOAT</td>
<td style="text-align:left">取出整数值并将其转换成 <code>longdouble</code> 类型的浮点数， 对这个浮点数进行加法计算， 然后将得出的浮点数结果保存起来。</td>
<td style="text-align:left">取出字符串值并尝试将其转换成<code>long double</code> 类型的浮点数， 对这个浮点数进行加法计算， 然后将得出的浮点数结果保存起来。 如果字符串值不能被转换成浮点数， 那么向客户端返回一个错误。</td>
<td style="text-align:left">取出字符串值并尝试将其转换成 <code>longdouble</code> 类型的浮点数， 对这个浮点数进行加法计算， 然后将得出的浮点数结果保存起来。 如果字符串值不能被转换成浮点数， 那么向客户端返回一个错误。</td>
</tr>
<tr>
<td style="text-align:left">INCRBY</td>
<td style="text-align:left">对整数值进行加法计算， 得出的计算结果会作为整数被保存起来。</td>
<td style="text-align:left"><code>embstr</code> 编码不能执行此命令， 向客户端返回一个错误。</td>
<td style="text-align:left"><code>raw</code> 编码不能执行此命令， 向客户端返回一个错误。</td>
</tr>
<tr>
<td style="text-align:left">DECRBY</td>
<td style="text-align:left">对整数值进行减法计算， 得出的计算结果会作为整数被保存起来。</td>
<td style="text-align:left"><code>embstr</code> 编码不能执行此命令， 向客户端返回一个错误。</td>
<td style="text-align:left"><code>raw</code> 编码不能执行此命令， 向客户端返回一个错误。</td>
</tr>
<tr>
<td style="text-align:left">STRLEN</td>
<td style="text-align:left">拷贝对象所保存的整数值， 将这个拷贝转换成字符串值， 计算并返回这个字符串值的长度。</td>
<td style="text-align:left">调用 <code>sdslen</code> 函数， 返回字符串的长度。</td>
<td style="text-align:left">调用 <code>sdslen</code> 函数， 返回字符串的长度。</td>
</tr>
<tr>
<td style="text-align:left">SETRANGE</td>
<td style="text-align:left">将对象转换成 <code>raw</code> 编码， 然后按 <code>raw</code>编码的方式执行此命令。</td>
<td style="text-align:left">将对象转换成 <code>raw</code> 编码， 然后按 <code>raw</code>编码的方式执行此命令。</td>
<td style="text-align:left">将字符串特定索引上的值设置为给定的字符。</td>
</tr>
<tr>
<td style="text-align:left">GETRANGE</td>
<td style="text-align:left">拷贝对象所保存的整数值， 将这个拷贝转换成字符串值， 然后取出并返回字符串指定索引上的字符。</td>
<td style="text-align:left">直接取出并返回字符串指定索引上的字符。</td>
<td style="text-align:left">直接取出并返回字符串指定索引上的字符。</td>
</tr>
</tbody>
</table>
</div>
<h2 id="8-8-内存回收"><a href="#8-8-内存回收" class="headerlink" title="8.8 内存回收"></a>8.8 内存回收</h2><p>Redis通过跟踪对象的引用计数信息，在适当的时候自动释放对象并进行内存回收。</p>
<p>计数信息由 <code>redisObject</code> 结构的 <code>refcount</code> 属性记录</p>
<ul>
<li>在创建一个新对象时， 引用计数的值会被初始化为 <code>1</code> ；</li>
<li>当对象被一个新程序使用时， 它的引用计数值会被增一；</li>
<li>当对象不再被一个程序使用时， 它的引用计数值会被减一；</li>
<li>当对象的引用计数值变为 <code>0</code> 时， 对象所占用的内存会被释放。</li>
</ul>
<p>对应的API：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">函数</th>
<th style="text-align:left">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>incrRefCount</code></td>
<td style="text-align:left">将对象的引用计数值增一。</td>
</tr>
<tr>
<td style="text-align:left"><code>decrRefCount</code></td>
<td style="text-align:left">将对象的引用计数值减一， 当对象的引用计数值等于 <code>0</code> 时， 释放对象。</td>
</tr>
<tr>
<td style="text-align:left"><code>resetRefCount</code></td>
<td style="text-align:left">将对象的引用计数值设置为 <code>0</code> ， 但并不释放对象， 这个函数通常在需要重新设置对象的引用计数值时使用。</td>
</tr>
</tbody>
</table>
</div>
<p>对象生命周期可以划分为创建对象、操作对象、释放对象三个阶段</p>
<p>一个字符串对象从创建到释放的整个过程：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个字符串对象 s ，对象的引用计数为 1</span></span><br><span class="line">robj *s = createStringObject(...)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象 s 执行各种操作 ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将对象 s 的引用计数减一，使得对象的引用计数变为 0</span></span><br><span class="line"><span class="comment">// 导致对象 s 被释放</span></span><br><span class="line">decrRefCount(s)</span><br></pre></td></tr></table></figure>
<p>是不是通过计算指向对象这块内存的指针数量来实现的？</p>
<h3 id="8-9-对象共享"><a href="#8-9-对象共享" class="headerlink" title="8.9 对象共享"></a>8.9 对象共享</h3><p>对于整数值的字符串对象（int编码），在新创建一个字符串对象的时候如果有这个值的字符串对象存在，就不再为新键创建字符串对象，而是将这个新键指向之前已经存在了的字符串对象。然后将这个字符串对象的引用+1。主要目的是节约内存。</p>
<p>Redis初始化服务器的时候创建一万个字符串对象， 这些对象包含了从 <code>0</code> 到 <code>9999</code> 的所有整数值， 当服务器需要用到值为 <code>0</code>到 <code>9999</code> 的字符串对象时， 服务器就会使用这些共享对象， 而不是新创建对象。</p>
<p>创建共享字符串对象的数量可以通过修改 <code>redis.h/REDIS_SHARED_INTEGERS</code> 常量来修改。</p>
<p><strong>为什么 Redis 不共享包含字符串的对象？</strong></p>
<p>当服务器考虑将一个共享对象设置为键的值对象时， 程序需要先检查给定的共享对象和键想创建的目标对象是否完全相同， 只有在共享对象和目标对象完全相同的情况下， 程序才会将共享对象用作键的值对象， 而一个共享对象保存的值越复杂， 验证共享对象和目标对象是否相同所需的复杂度就会越高， 消耗的 CPU 时间也会越多：</p>
<ul>
<li>如果共享对象是保存整数值的字符串对象， 那么验证操作的复杂度为 O(1) ；</li>
<li>如果共享对象是保存字符串值的字符串对象， 那么验证操作的复杂度为 O(N) ；</li>
<li>如果共享对象是包含了多个值（或者对象的）对象， 比如列表对象或者哈希对象， 那么验证操作的复杂度将会是 O(N^2) 。</li>
</ul>
<p>因此， 尽管共享更复杂的对象可以节约更多的内存， 但受到 CPU 时间的限制， Redis 只对包含整数值的字符串对象进行共享。 （时刻在空间与时间上做权衡）</p>
<h2 id="8-9-对象的空转时长"><a href="#8-9-对象的空转时长" class="headerlink" title="8.9 对象的空转时长"></a>8.9 对象的空转时长</h2><p><code>lru</code> 属性， 该属性记录了对象最后一次被<strong>命令程序访问</strong>的时间。</p>
<p>OBJECT IDLETIME 命令可以打印出给定键的空转时长， 这一空转时长就是通过将当前时间减去键的值对象的 <code>lru</code> 时间计算得出的。</p>
<p>OBJECT IDLETIME 命令的实现是特殊的， 这个命令在访问键的值对象时， 不会修改值对象的 <code>lru</code> 属性。</p>
<p>lru的主要作用就是配合maxmemory选项，淘汰不常用的键值对。</p>
<p>如果服务器打开了 <code>maxmemory</code> 选项， 并且服务器用于回收内存的算法为 <code>volatile-lru</code> 或者 <code>allkeys-lru</code> ， 那么当服务器占用的内存数超过了 <code>maxmemory</code> 选项所设置的上限值时， 空转时长较高的那部分键会优先被服务器释放， 从而回收内存。</p>
<h2 id="疑惑"><a href="#疑惑" class="headerlink" title="疑惑"></a>疑惑</h2><ol>
<li>为什么在一块连续的内存里面可以更好地利用缓存带来的优势？</li>
<li>引用计数的程序怎么定义？是指线程吗？</li>
<li>引用计数的具体实现？</li>
<li>对象共享的时候怎么去判断存不存在已经创建了这个整数值的对象？对整个数据库遍历吗？</li>
</ol>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>object</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer 读书笔记——第2章</title>
    <url>/2019-03-27-%E5%89%91%E6%8C%87offer-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E7%AC%AC2%E7%AB%A0.html</url>
    <content><![CDATA[<h1 id="剑指offer-读书笔记——第2章"><a href="#剑指offer-读书笔记——第2章" class="headerlink" title="剑指offer 读书笔记——第2章"></a>剑指offer 读书笔记——第2章</h1><p>感觉自己的代码能力还在很弱，所以又第二遍仔细的阅读剑指offer了</p>
<p>第二章 面试需要的基础知识</p>
<a id="more"></a>
<h2 id="面试题1-赋值运算函数"><a href="#面试题1-赋值运算函数" class="headerlink" title="面试题1 赋值运算函数"></a>面试题1 赋值运算函数</h2><p>所谓赋值运算函数就是对=这个操作符进行重载，从而使等号能够直接用于两个实例之间的赋值。这个C++课上学过，不过现在忘完了，只记得学过。</p>
<h3 id="经典解法"><a href="#经典解法" class="headerlink" title="经典解法"></a>经典解法</h3><p>需要考虑的点</p>
<ol>
<li><strong>返回值的类型</strong>声明为该类型的引用，在函数结束前返回实例自身的引用(<strong>*this</strong>)。只有返回一个引用，才可以连续赋值。<code>object1=object2=object3</code>就是连续赋值。赋值采用右结合律，从最右边开始计算。不然的话当首先执行完<code>object2=object3</code> 后，<code>object2</code> 虽然自己的成员已经得到了更改，但是它不能再作为<code>object1=object2</code> 这个等号的右值，因为在前一个=的执行中，它没有获得返回值。而返回对象的话，就需要重新执行新建一个对象和销毁对象的构造与析构操作，增加不必要开销，降低赋值函数的效率。</li>
<li>传入的参数申明为<strong>常量引用</strong></li>
<li><strong>释放</strong>实例自身已有的<strong>内存</strong></li>
<li><strong>判断</strong>传入参数是否和当前的<strong>实例相同</strong>，相同的话不进行赋值操作，直接返回实例。</li>
</ol>
<p>代码：初级版</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">CMyString&amp; CMyString::<span class="keyword">operator</span> = (<span class="keyword">const</span> CMyString&amp; str)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> == &amp;str)</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> []m_pData;</span><br><span class="line">    m_pData = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    m_pData = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str.m_pData) + <span class="number">1</span>]; <span class="comment">//给strcpy复制的字符串申请空间</span></span><br><span class="line">    <span class="built_in">strcpy</span>(m_pData, str.m_pData);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码：高级版</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">CMyString&amp; CMyString::<span class="keyword">operator</span> = (<span class="keyword">const</span> CMyString&amp; str)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> != &amp;str)&#123;</span><br><span class="line">    	CMyString strTemp(str);   <span class="comment">// 新建一个实例 </span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">char</span> *pTemp=strTemp.m_pData;   <span class="comment">// 新建一个临时指针保存数据</span></span><br><span class="line">        strTemp.m_pData = m_pData; 		<span class="comment">// 交换</span></span><br><span class="line">        m_pData = pTemp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初级版在使用new分配内存的时候，已经把原来的数据给清楚了（<code>delete []m_pData;</code>）,这时在新分配内存的时候，如果内存不足会导致new char抛出异常，使得m_pData 变成一个空指针，这样很容易导致程序崩溃。因为在抛出异常之后，原来的CMyString实例因为数据被delete了，所以不再保持有效的状态，违背了异常安全性的原则。 （可以先将原来的数据备份，等new 成功了，再将原来的数据delete给释放掉）</p>
<p>代码思路：新建一个实例，新建一个临时指针从而用于数据交换。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tmp    tmp</span><br><span class="line">^       |</span><br><span class="line">|       </span><br><span class="line">str&lt;--this </span><br><span class="line">先将str的值备份到tmp中，然后将str的值更新为this的值，然后在把this的值更新为tmp的值</span><br><span class="line">两个数据的交换必然需要新建第三个变量来存放其中一个变量的值。</span><br></pre></td></tr></table></figure>
<p>之所以需要新建一个实例是因为实例是个临时变量，所以完成操作后会自动释放掉他的数据，也就是原来的数据。</p>
<p>指针与引用的异同</p>
<p>常量指针与常量引用。</p>
<p>对于引用只有两种描述：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 对常量类型的引用  </span><br><span class="line">const type &amp;ref = type a;</span><br><span class="line">//对变量类型的引用</span><br><span class="line">type &amp;ref = type a;</span><br></pre></td></tr></table></figure>
<p>对常量类型的引用  实际上既可以对常量类型引用，也可以对变量类型引用，但是不能通过引用来修改它引用的对象。</p>
<p>对于指针的修饰有4种：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 普通的指针 poi is a pointer point to a type  ，</span><br><span class="line">//指针的值（指向的地址，可以改变），被指向的变量的值也可以改变</span><br><span class="line">type *poi;</span><br><span class="line"></span><br><span class="line">//常量指针 poi is a const pointer point to a type </span><br><span class="line">//指针的值（指向的地址）不能改变，被指向的变量的值可以改变</span><br><span class="line">type *const poi;</span><br><span class="line"></span><br><span class="line">// poi is a pointer point to a const type</span><br><span class="line">//指针的值（指向的地址）可以改变，所以指针可以指向其他变量，</span><br><span class="line">//被指向的变量的值不可以改变，所以指针不能修改指向的变量的值，</span><br><span class="line">const type *poi;</span><br><span class="line"></span><br><span class="line">// poi is a const pointer point to a const type</span><br><span class="line">// 指针的值（指向的地址）不能改变，所以指针不能指向其他变量，</span><br><span class="line">//被指向的变量的不可以改变，所以指针不能修改指向的变量的值</span><br><span class="line">const type *const poi;</span><br></pre></td></tr></table></figure>
<p>以* &amp;作为分割符进行读取，const作为前缀修饰的对象,对象存储的值不变。</p>
<p>对于指向const type 的指针或者引用而言，指向的（引用的）变量类型不一定是常量，但是无法通过指针或者引用来修改其指向的（引用的）变量的值。《C++primer》中所说：所谓指向常量的指针或引用，不过是指针自以为自己指向了一个常量，所以自觉地不去改变所指对象的值。</p>
<h2 id="疑惑"><a href="#疑惑" class="headerlink" title="疑惑"></a>疑惑</h2><ol>
<li>为什么申明的返回值是引用，而返回的却是指针？<ul>
<li>引用是地址的别名,但是不分配内存空间。 <code>CMyString &amp;A= *this</code>   这里<em>this是指向CMyString这个类的实例的地址，而A是CMyString的一个实例的引用，是引用就需要与这个实例的内存地址相关联，所以可以传入 </em>this ，也就是实例的地址。 本来 =号用于赋值的时候，左值是地址，右值是变量地址上的数据也就是变量的值，但是引用的=号的右值是变量的地址。所以可以传入地址，也就是指针。</li>
</ul>
</li>
<li>传入的参数是个常量引用，为什么不使用常量指针： <code>const CMyString *str</code><ul>
<li>虽然<code>const CMyString *str</code> 和<code>congst CMyString &amp;str</code> 都不能去修改实参的值了，但是引用不是对象，是不分配内存的啊，使用指针的话，肯定会占用内存，然后不用的时候销毁内存，所以效率会降低。而且引用是一定不会空的，所以不用考虑所指的对象是否为空。（提升效率的关键，可以不申请内存就不申请内存，因为不管是自己去释放，还是系统自动回收，分配和回收都会带来效率的下降。所以能用指针就用指针，能用引用就用引用，最坏的情况才是值拷贝。）（ <strong>对象</strong>是指一块能存储数据并具有某种类型的内存空间）</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>coding</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 设计与实现读书笔记——第四章 字典</title>
    <url>/2019-03-27-Redis-%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%AD%97%E5%85%B8.html</url>
    <content><![CDATA[<h1 id="Redis-设计与实现读书笔记——第四章-字典"><a href="#Redis-设计与实现读书笔记——第四章-字典" class="headerlink" title="Redis 设计与实现读书笔记——第四章 字典"></a>Redis 设计与实现读书笔记——第四章 字典</h1><p>字典在Redis中应用很广泛，Redis的数据库就是用字典作为底层实现的，对数据库的增删改查操作也是构建在对字典的操作之上的。</p>
<a id="more"></a>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>作用：</p>
<ul>
<li>数据库底层实现</li>
<li>哈希键底层实现<ul>
<li>哈希键包含的键值对比较多，或者键值对中的元素都是比较长的字符串时，使用字典来实现。</li>
</ul>
</li>
<li>其他功能</li>
</ul>
<h2 id="4-1-字典的实现"><a href="#4-1-字典的实现" class="headerlink" title="4.1 字典的实现"></a>4.1 字典的实现</h2><p>字典使用哈希表实现，一个哈希表里面可以有多个哈希表节点，一个哈希表节点就保存了字典中的一个键值对。（python的dict也是使用哈希表实现的）。</p>
<p>哈希的本质就是预留内存空间，将需要存储的元素计算索引值(通过哈希函数)来确定对应的存储位置。当需要访问的时候可以通过哈希函数直接获得对应的地址。（编译器将变量名与地址做了映射，变量名是地址的别名，哈希则是将键与地址做了映射（通过哈希函数），大大提高了访问的效率。访问任何元素都是O（1），感觉是两个层面的映射，有点相似的感觉）。</p>
<h3 id="4-1-1-哈希表"><a href="#4-1-1-哈希表" class="headerlink" title="4.1.1 哈希表"></a>4.1.1 哈希表</h3><p>Redis使用的哈希表由dict.h/dictht 结构定义。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">    <span class="comment">//哈希表数组</span></span><br><span class="line">    dictEntry **table;</span><br><span class="line">    <span class="comment">// 哈希表大小</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size;</span><br><span class="line">    <span class="comment">//哈希表大小掩码，用于计算索引值</span></span><br><span class="line">    <span class="comment">//总是等于size-1</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;</span><br><span class="line">    <span class="comment">//该哈希表已有节点的数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used;</span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure>
<p><code>typedef Oldname newname</code> 所以这里是<code>typedef struct dictht dictht</code> 将struct dictht 取了个别名dictht。</p>
<p><code>dictEntry **table;</code> 书上解释的是table是数组，但是最直接的说法是table是一个指向（指向dictEntry类型的指针）的指针，是指向指针的指针。   </p>
<p>数组获得内存是连续的，而指针不是，所以书中说是table数组，应该是分配内存的时候给指针分配了连续的内存，但是代码没找到。</p>
<p>关于指针和数组的异同《C专家编程》一书有讲解（第四章、第九章、第十章）。</p>
<ul>
<li>主要的不同：指针存放的是地址，所以需要经过两次取地址的内容。（取指针的地址中的数据（变量的地址），取变量地址的数据）。而数组是直接存储数组的首元素的数据，所以只用一次取地址中的数据</li>
<li>数组与指针相同<ul>
<li>表达式中的数组名就是指针</li>
<li>C语言把数组下标作为指针的偏移量。a是数组，a[6]就是首地址偏移6。b是指针，b[6]也是指针存储的地址向后偏移6.</li>
<li>作为函数参数的数组名等同于指针。只是把首地址传入给了参数，并没有把数组所有的内存区域都传入。所以传入数组，就是传入指针。</li>
</ul>
</li>
</ul>
<p>sizemask和哈希值一起决定一个键应该被放到table数组的那个索引上面。</p>
<p><img src="http://redisbook.com/_images/graphviz-bd3eecd927a4d8fc33b4a1c7f5957c52d67c5021.png" alt="一个空的哈希表"></p>
<h3 id="4-1-2-哈希表节点"><a href="#4-1-2-哈希表节点" class="headerlink" title="4.1.2 哈希表节点"></a>4.1.2 哈希表节点</h3><p>使用dictEntry结构体表示节点，每一个dictEntry结构都保存着一个键值对。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">    <span class="comment">// 键</span></span><br><span class="line">    <span class="keyword">void</span> *key;	</span><br><span class="line">    <span class="comment">// 值</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> *val;</span><br><span class="line">        <span class="keyword">uint64_t</span> u64;</span><br><span class="line">        <span class="keyword">int64_t</span> s64;</span><br><span class="line">        <span class="keyword">double</span> d;</span><br><span class="line">    &#125; v;</span><br><span class="line">    <span class="comment">//指向下一个哈希表节点   </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure>
<p>key指向键值对中的键，而v则保存键值对中的值，值可以是一个指针，或者uint64_t整数，或者有符号的int64_t整数,或者是double类型（double也占8byte无论32还是64位）。</p>
<p><code>union</code> 是c中的共用体（联合体），和结构体非常类似。和结构体的区别是</p>
<ul>
<li>结构体的各个成员会占用不同的内存，互相之间没有影响；而共用体的所有成员占用同一段内存，修改一个成员会影响其余所有成员。</li>
<li>结构体占用的内存大于等于所有成员占用的内存的总和（成员之间可能会存在缝隙），共用体占用的内存等于最长的成员占用的内存。共用体使用了内存覆盖技术，同一时刻只能保存一个成员的值，如果对新的成员赋值，就会把原来成员的值覆盖掉。 所以这里面v占用8byte内存，但是属性却可以有4中。</li>
</ul>
<p>next指针可以将多个哈希值相同的键值对链接在一起，用来解决哈希键冲突(索引相同)的问题。链式的方法。</p>
<p><img src="http://redisbook.com/_images/graphviz-d2641d962325fd58bf15d9fffb4208f70251a999.png" alt=""></p>
<h3 id="4-1-3-字典"><a href="#4-1-3-字典" class="headerlink" title="4.1.3 字典"></a>4.1.3 字典</h3><p>Redis中字典由dict.h/dict 结构体表示。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    <span class="comment">//类型特定函数</span></span><br><span class="line">    dictType *type;</span><br><span class="line">    <span class="comment">// 私有数据</span></span><br><span class="line">    <span class="keyword">void</span> *privdata;</span><br><span class="line">    <span class="comment">// 哈希表</span></span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line">    <span class="comment">//rehash 索引</span></span><br><span class="line">    <span class="comment">//当rehash不在进行是值为-1。用来记录是否在rehash</span></span><br><span class="line">    <span class="keyword">long</span> rehashidx; <span class="comment">/* rehashing not in progress if rehashidx == -1 */</span></span><br><span class="line">    <span class="comment">//当前迭代的个数</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> iterators; <span class="comment">/* number of iterators currently running */</span></span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure>
<p>type 和private属性是针对不同类型的键值对（redis支持5中数据类型），为创建多态字典而设置的。</p>
<ul>
<li>type指向dictType结构，dictType结构保存了一簇用于操作特定类型键值对的函数，Redis为不同用途的字典设置了不同的类型的特定函数。（多态的表现。）</li>
<li>privadata属性保存了需要传给哪些类型特点函数的可选参数。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictType</span> &#123;</span></span><br><span class="line">    <span class="comment">// 计算哈希值的函数</span></span><br><span class="line">    <span class="keyword">uint64_t</span> (*hashFunction)(<span class="keyword">const</span> <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="comment">// 复制键的函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*keyDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="comment">// 复制值的函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*valDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *obj);</span><br><span class="line">    <span class="comment">// 对比键的函数</span></span><br><span class="line">    <span class="keyword">int</span> (*keyCompare)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key1, <span class="keyword">const</span> <span class="keyword">void</span> *key2);</span><br><span class="line">    <span class="comment">// 销毁键的函数</span></span><br><span class="line">    <span class="keyword">void</span> (*keyDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="comment">// 销毁值的函数</span></span><br><span class="line">    <span class="keyword">void</span> (*valDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *obj);</span><br><span class="line">&#125; dictType;</span><br></pre></td></tr></table></figure>
<p>ht是长度为2的数组，而数组的元素就是哈希表dictht。一般情况只会使用ht[0],ht[1]只会在ht[0]空间不够的时候进行rehash的时候使用。</p>
<p>rehashidx 用来标识是否在 rehash，没有的话值为-1,有的话rehasidx用来记录rehash的进度。</p>
<p><img src="http://redisbook.com/_images/graphviz-e73003b166b90094c8c4b7abbc8d59f691f91e27.png" alt=""></p>
<h2 id="4-2-哈希算法"><a href="#4-2-哈希算法" class="headerlink" title="4.2 哈希算法"></a>4.2 哈希算法</h2><p>添加一个新的键值对的时候，</p>
<pre><code> 1. 需要先根据键值使用hash函数计算哈希值
    2. 哈希值和sizemask并运算求得索引值
    3. 再根据索引值将包含键值对的哈希表节点放到哈希表数组table上的对应索引值上。
</code></pre><p>Redis 计算哈希值和索引值的方法为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 使用字典设置的哈希函数，计算键 key 的哈希值</span><br><span class="line">hash = dict-&gt;type-&gt;hashFunction(key);</span><br><span class="line"></span><br><span class="line"># 使用哈希表的 sizemask 属性和哈希值，计算出索引值</span><br><span class="line"># 根据情况不同， ht[x] 可以是 ht[0] 或者 ht[1]</span><br><span class="line">index = hash &amp; dict-&gt;ht[x].sizemask;</span><br></pre></td></tr></table></figure>
<p>哈希值用hashFunction计算，index用hash值和sizemask进行并操作。</p>
<p>对应在源码中为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//dict.h 中：</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictHashKey(d, key) (d)-&gt;type-&gt;hashFunction(key) <span class="comment">//计算哈希值</span></span></span><br><span class="line"><span class="comment">//dict.c 中</span></span><br><span class="line">idx = hash &amp; d-&gt;ht[table].sizemask;</span><br><span class="line">h = dictHashKey(d, de-&gt;key) &amp; d-&gt;ht[<span class="number">1</span>].sizemask;</span><br></pre></td></tr></table></figure>
<p>插入一个键值对<k0,v0>到字典中的过程为：</k0,v0></p>
<p><img src="http://redisbook.com/_images/graphviz-ca9c88ba1713cb595c4e0e4a17ef2042b0008621.png" alt=""></p>
<p>先使用语句</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hash = dict-&gt;type-&gt;hashFunction(k0);</span><br></pre></td></tr></table></figure>
<p>计算键 <code>k0</code> 的哈希值。</p>
<p>假设计算得出的哈希值为 <code>8</code> ， 那么程序会继续使用语句</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">index = hash &amp; dict-&gt;ht[0].sizemask = 8 &amp; 3 = 0;</span><br></pre></td></tr></table></figure>
<p>计算出键 <code>k0</code> 的索引值 <code>0</code> ， 这表示包含键值对 <code>k0</code> 和 <code>v0</code> 的节点应该被放置到哈希表数组的索引 <code>0</code> 位置上。</p>
<p><img src="http://redisbook.com/_images/graphviz-2369cb08288f5e59548355042c4c40cc4339e339.png" alt=""></p>
<p>当字典被用作数据库的底层实现， 或者哈希键的底层实现时， Redis 使用 MurmurHash2 算法来计算键的哈希值。算法的优点</p>
<ul>
<li>即使输入的键是有规律的， 算法仍能给出一个很好的随机分布性， 并且算法的计算速度也非常快。</li>
</ul>
<p>MurmurHash 算法目前的最新版本为 MurmurHash3 ， 而 Redis 使用的是 MurmurHash2 ， 关于 MurmurHash 算法的更多信息可以参考该算法的主页： <a href="http://code.google.com/p/smhasher/" target="_blank" rel="noopener">http://code.google.com/p/smhasher/</a> 。</p>
<p>暂时没有找到hashFunction的源码。</p>
<h3 id="4-3-键冲突"><a href="#4-3-键冲突" class="headerlink" title="4.3 键冲突"></a>4.3 键冲突</h3><p>两个以上的键分配到了同一个索引就产生了冲突。</p>
<p>使用链地址法解决，相同索引上面的节点可以用next指针来链接，这样同一个索引就可以存放多个哈希表节点了。</p>
<p>哈希表节点没有指向链表链尾的节点，所以不能迅速的知道哪个节点是尾节点，（只能通过遍历才能找到指向null的尾节点O(N)）,所以为了速度考虑总是将新节点插入到最前面（dictht-&gt;table指针指向的第一个节点就是最前面的节点。）</p>
<p>直接使用书上的图：</p>
<p>还未发生键冲突</p>
<p><img src="http://redisbook.com/_images/graphviz-db40aa6d0f1265d74f1c1d12b8fa074c0bcda12a.png" alt=""></p>
<p>键冲突发生后：新键值对<k2,v2> 插入到<k1,v1>前面。</k1,v1></k2,v2></p>
<p><img src="http://redisbook.com/_images/graphviz-4b52dcf6eb0768750e1c15480be3326ca37e05b3.png" alt=""></p>
<h2 id="4-4-rehash"><a href="#4-4-rehash" class="headerlink" title="4.4  rehash"></a>4.4  rehash</h2><p>哈希表保存的键值对会增多或者减少，需要让负载因子（负载因子(load factor)，它用来衡量哈希表的 <strong>空/满</strong> 程度，一定程度上也可以体现查询的效率）维持在合理的范围，所以哈希节点太多的时候需要扩容（不然冲突太多，降低效率），这些哈希表的空间动态扩容或者缩容通过rehash操作来实现。</p>
<p>步骤为：</p>
<ol>
<li>为ht[1]分配空间<ol>
<li>扩容时ht[1].size = 大于等于ht[0].used*2的第一个2^n。</li>
<li>收缩时ht[1].size = 大于等于ht[0].used的第一个2^n。</li>
</ol>
</li>
<li>迁移：将ht[0]上面的哈希节点重新计算哈希值与索引值并放到ht[1]哈希表上面。</li>
<li>迁移完成后释放ht[0],把ht[1]设置成ht[0],并在ht[1]新创建一个空白哈希表，等待下一次rehash。</li>
</ol>
<p>注意：不管是扩容还是收缩，新分配的空间都会比原来用到的(used)大。设置ht[1]为ht[0] 的时候只需要简单的将原来ht[0]上面的指针指向ht[1]就好，但是需要把原来指向的哈希表的内存给释放掉。（指针是真的强，每次指针变换指向的地址的时候，都需要考虑下之前指向的地址是否还需要，不需要就要释放，不然会造成内存泄漏）。ht[1]则重新新建个哈希表结构体，然后把ht[1]的指针指过来就好了。</p>
<p>rehash的过程图解参考书中的图讲的很详细。</p>
<p><img src="http://redisbook.com/_images/graphviz-93608325578e8e45848938ef420115bf2227639e.png" alt=""></p>
<p>假设程序要对图 4-8 所示字典的 <code>ht[0]</code> 进行扩展操作。</p>
<ol>
<li><code>ht[0].used</code> 当前的值为 <code>4</code> ， <code>4 * 2 = 8</code> ， 而 <code>8</code> （2^3）恰好是第一个大于等于 <code>4</code> 的 <code>2</code> 的 <code>n</code> 次方， 所以程序会将 <code>ht[1]</code> 哈希表的大小设置为 <code>8</code> 。图 4-9 展示了 <code>ht[1]</code> 在分配空间之后， 字典的样子：</li>
</ol>
<p><img src="http://redisbook.com/_images/graphviz-b68acb4d868ec7d79a44935ce08a159746ca58da.png" alt=""></p>
<ol>
<li>将 <code>ht[0]</code> 包含的四个键值对都 rehash 到 <code>ht[1]</code> ， 如图 4-10 所示。</li>
</ol>
<p><img src="http://redisbook.com/_images/graphviz-92dc47e4329eabae941cddfd727b736ef738e8cf.png" alt=""></p>
<ol>
<li>释放 <code>ht[0]</code> ，并将 <code>ht[1]</code> 设置为 <code>ht[0]</code> ，然后为 <code>ht[1]</code> 分配一个空白哈希表，如图 4-11 所示。</li>
</ol>
<p><img src="http://redisbook.com/_images/graphviz-fa28d986a72f1f48b83c7f959ea217b1f9527d3c.png" alt=""></p>
<p>哈希表的扩展与收缩（源码还没找到）</p>
<p>当以下条件中的任意一个被满足时， 程序会自动开始对哈希表执行扩展操作：</p>
<ol>
<li>服务器目前没有在执行 BGSAVE 命令或者 BGREWRITEAOF 命令， 并且哈希表的负载因子大于等于 <code>1</code> ；</li>
<li>服务器目前正在执行 BGSAVE 命令或者 BGREWRITEAOF 命令， 并且哈希表的负载因子大于等于 <code>5</code> ；</li>
</ol>
<p>其中哈希表的负载因子可以通过公式得到。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 负载因子 = 哈希表已保存节点数量 / 哈希表大小</span><br><span class="line">load_factor = ht[0].used / ht[0].size</span><br></pre></td></tr></table></figure>
<h2 id="4-5-渐进式rehash"><a href="#4-5-渐进式rehash" class="headerlink" title="4.5 渐进式rehash"></a>4.5 渐进式rehash</h2><p>考虑到redis数据库中存储的键值对很多的情况，如果一次性就rehash完，庞大的计算量可能会导致服务器性能急剧下降，甚至一段时间的停止服务，（经济学中的休克时疗法？）所以rehash这个过程需要渐进式的（软着陆）。</p>
<p>步骤：</p>
<ol>
<li>为 <code>ht[1]</code> 分配空间， 让字典同时持有 <code>ht[0]</code> 和 <code>ht[1]</code> 两个哈希表。</li>
<li>在dict中维持一个索引计数器变量 <code>rehashidx</code> ， 并将它的值设置为 <code>0</code> ， 表示 rehash 工作正式开始。</li>
<li>在 rehash 进行期间， 每次对字典执行添加、删除、查找或者更新操作时， 程序除了执行指定的操作以外， 还会顺带将 <code>ht[0]</code> 哈希表在 <code>rehashidx</code> 索引上的所有键值对 rehash 到 <code>ht[1]</code> ， 当 rehash 工作完成之后， 程序将 <code>rehashidx</code> 属性的值增一。</li>
<li>随着字典操作的不断执行， 最终在某个时间点上， <code>ht[0]</code> 的所有键值对都会被 rehash 至 <code>ht[1]</code> ， 这时程序将 <code>rehashidx</code> 属性的值设为 <code>-1</code> ， 表示 rehash 操作已完成。</li>
</ol>
<p>注意：</p>
<ul>
<li>rehashidx的范围是从-1到ht[0].size-1 ，也就是对应的哈希表的索引，不是之前理解的记录哈希节点的个数。</li>
<li>迁移的过程不是拷贝，而是哈希表存储的哈希指针重新指向哈希节点的过程（指针对地址的操作）。</li>
</ul>
<p>rehash 键值对所需的计算工作均滩到对字典的每个添加、删除、查找和更新操作上， 从而避免了集中式 rehash 而带来的庞大计算量。</p>
<p>过程图解依然copy自redis设计与实现的电子书。</p>
<p><img src="http://redisbook.com/_images/graphviz-4c43eaf38cbca10d8d368a5144db6f3c69ab3d84.png" alt=""></p>
<p><img src="http://redisbook.com/_images/graphviz-b91705b0d7a6c7fd5e37332a930534e0e136ae73.png" alt=""></p>
<p><img src="http://redisbook.com/_images/graphviz-9e2996e6ca9665776062470cdac346e8fc255374.png" alt=""></p>
<p><img src="http://redisbook.com/_images/graphviz-c871b5de1a7910aea237ca9dc86508b48da94769.png" alt=""></p>
<p><img src="http://redisbook.com/_images/graphviz-3b31e4e08cc3e212f986039eb08ae77224cdeec9.png" alt=""></p>
<p><img src="http://redisbook.com/_images/graphviz-86f810ac65c4e6ee58b17105dfeaa06973d8dd16.png" alt=""></p>
<h3 id="渐进式rehash期间的哈希表操作"><a href="#渐进式rehash期间的哈希表操作" class="headerlink" title="渐进式rehash期间的哈希表操作"></a>渐进式rehash期间的哈希表操作</h3><p>增删改查在两个表上操作，但是添加的新键只添加到ht[1]上，确保ht[0]最终变成空表。</p>
<h2 id="4-6-字典API"><a href="#4-6-字典API" class="headerlink" title="4.6 字典API"></a>4.6 字典API</h2><h2 id="疑惑"><a href="#疑惑" class="headerlink" title="疑惑"></a>疑惑</h2><ul>
<li><p>为什么不直接用<code>dictEntry *table[]</code> 来表示，却要用指针？应该是指针更加灵活些？</p>
<ul>
<li>因为dict有两个哈希表，而其中有个哈希表ht[1] 是只有在rehash的时候才会使用的，因此使用指针的的话，在不需要的时候将table直接指向null就可以简单的完成释放空间的操作，如果用数组的话,在分配内存的时候，就必须要为两个dictht都分配size个byte的内存存储空间，当rehash的时候size会变化，结构体中的数组就需要重新分配内存空间，而结构体的内存是相邻连续的，所以这时候要变化空间，只能重新再给这个结构体分配空间，这样效率肯定就很低了。所以使用指针的原因就是rehash的时候数组的大小会变化，如果用数组来记录就很麻烦和效率低了。</li>
<li>所以在dict中可以使用数组来存储dictht,因为ht这个数组是不会变化的。</li>
</ul>
</li>
<li><p>既然在rehash过程中会有增删改查的操作，那么这些操作是在哪个哈希表上进行的呢？</p>
<ul>
<li>两个哈希表上面都会进行，但是增加的键值对会在ht[1] 上，不然ht[0]在减少的时候又新增键值对，不是在做无用之功吗。</li>
</ul>
</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://redisbook.com/preview/dict/hash_algorithm.html" target="_blank" rel="noopener">http://redisbook.com/preview/dict/hash_algorithm.html</a></p>
<p><a href="https://blog.csdn.net/yangbodong22011/article/details/78467583" target="_blank" rel="noopener">https://blog.csdn.net/yangbodong22011/article/details/78467583</a></p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>dict</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Travis-CI自动部署博客</title>
    <url>/2019-03-26-%E4%BD%BF%E7%94%A8Travis-CI%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%E5%8D%9A%E5%AE%A2.html</url>
    <content><![CDATA[<h1 id="使用Travis-CI自动部署博客"><a href="#使用Travis-CI自动部署博客" class="headerlink" title="使用Travis-CI自动部署博客"></a>使用Travis-CI自动部署博客</h1><p>因为在github上面存储的是编译好的html代码，不是hexo博客中的博客源文件，所以如果没有备份源文件的话，丢失了源文件（包括md,一堆配置文件）后就不能继续更新博客了，而且也不能多端部署Hexo。网上看到可以使用Travis-CI来自动部署，同时解决了博客源文件的备份问题。</p>
<a id="more"></a>
<h2 id="新建hexo分支来保存源文件"><a href="#新建hexo分支来保存源文件" class="headerlink" title="新建hexo分支来保存源文件"></a>新建hexo分支来保存源文件</h2><h3 id="新建分支"><a href="#新建分支" class="headerlink" title="新建分支"></a>新建分支</h3><p>直接在对应的github.io项目上的branch 按钮处点击新建分支 hexo。</p>
<p>官方文档<a href="https://help.github.com/en/articles/setting-the-default-branch" target="_blank" rel="noopener">https://help.github.com/en/articles/setting-the-default-branch</a> </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 克隆项目到本地</span><br><span class="line">&gt; git clone https://github.com/BraveY/BraveY.github.io.git</span><br></pre></td></tr></table></figure>
<h3 id="设置默认分支"><a href="#设置默认分支" class="headerlink" title="设置默认分支"></a>设置默认分支</h3><p>参照官方文档设置<a href="https://help.github.com/en/articles/setting-the-default-branch" target="_blank" rel="noopener">https://help.github.com/en/articles/setting-the-default-branch</a></p>
<h3 id="修改推送hexo分支"><a href="#修改推送hexo分支" class="headerlink" title="修改推送hexo分支"></a>修改推送hexo分支</h3><p>现将原来的文件BraveY.github.io 修改为BraveY.github.io.bak 避免拷贝的时候出现文件夹重名，同时将原来的hexo 目录blog文件也修改为blog.bak</p>
<p>直接克隆到 本地</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 克隆项目到本地</span><br><span class="line">&gt; git clone https://github.com/BraveY/BraveY.github.io.git</span><br></pre></td></tr></table></figure>
<p>这时拷贝的项目已经是hexo分支下面的，因为之前是设置了hexo分支作为默认分支的。</p>
<p>将克隆的BraveY.github.io文件夹重命名为blog</p>
<p>在克隆的文件夹里面删除除了.git的所有文件</p>
<p><strong>注意</strong> ：因为主题的next也是个git仓库，所以需要先把next目录下的.git删除</p>
<p>然后先把theme/next 目录下的.git 给删除掉，不然的话next这个主题本来就是个git仓库，里面的个性化配置是无法上传到自己的项目中的，而且以后也无法克隆。</p>
<p>从blog.bak文件中把所有hexo的源码文件拷过来。</p>
<p>在博客目录下初始化git仓库并将所有文件提交。</p>
<p>添加到远程仓库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add . </span><br><span class="line">git commit -m&quot;description&quot;</span><br><span class="line">git push origin</span><br></pre></td></tr></table></figure>
<p>现在hexo分支已经是存放了hexo的源文件了。</p>
<h2 id="设置Travis-CI"><a href="#设置Travis-CI" class="headerlink" title="设置Travis CI"></a>设置Travis CI</h2><p>主要参考下面的三个博客，</p>
<h3 id="Travis-CI-官网登陆"><a href="#Travis-CI-官网登陆" class="headerlink" title="Travis CI 官网登陆"></a>Travis CI 官网登陆</h3><p>使用github账号登陆<a href="https://travis-ci.org/" target="_blank" rel="noopener">Travis CI官网</a>  ，选择博客项目启动。然后进行设置。</p>
<p>没有文章中说的<code>Build only if .travis.yml is present</code> 选项，但好像没有影响，采用默认的选项。</p>
<h3 id="github生成Access-Token"><a href="#github生成Access-Token" class="headerlink" title="github生成Access Token"></a>github生成Access Token</h3><p>参考博客，不赘述。</p>
<h2 id="Travis-CI"><a href="#Travis-CI" class="headerlink" title="Travis CI"></a>Travis CI</h2><h3 id="配置travis-yml"><a href="#配置travis-yml" class="headerlink" title="配置travis.yml"></a>配置travis.yml</h3><p>在blog根目录下设置travis配置文件。</p>
<p>.travis.yml 文件的配置为：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">language:</span> <span class="string">node_js</span> <span class="comment"># 设置语言</span></span><br><span class="line"><span class="attr">node_js:</span> <span class="string">stable</span> <span class="comment"># 设置相应版本</span></span><br><span class="line"><span class="attr">cache:</span></span><br><span class="line"><span class="attr">  apt:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  directories:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">node_modules</span>  <span class="comment"># 缓存不经常更改的内容</span></span><br><span class="line"><span class="attr">before_install:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">export</span> <span class="string">TZ='Asia/Shanghai'</span> <span class="comment"># 更改时区</span></span><br><span class="line"><span class="attr">install:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">npm</span> <span class="string">install</span></span><br><span class="line"><span class="attr">script:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">hexo</span> <span class="string">clean</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">hexo</span> <span class="string">g</span> </span><br><span class="line"><span class="attr">after_script:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">git</span> <span class="string">clone</span> <span class="attr">https://$&#123;GH_REF&#125;</span> <span class="string">.deploy_git</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">cd</span> <span class="string">.deploy_git</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">git</span> <span class="string">checkout</span> <span class="string">master</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">cd</span> <span class="string">../</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">mv</span> <span class="string">.deploy_git/.git/</span> <span class="string">./public/</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">cd</span> <span class="string">./public</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">git</span> <span class="string">config</span> <span class="string">user.name</span> <span class="string">"BraveY"</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">git</span> <span class="string">config</span> <span class="string">user.email</span> <span class="string">"lsz_yky@163.com"</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">git</span> <span class="string">add</span> <span class="string">.</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">git</span> <span class="string">commit</span> <span class="bullet">-m</span> <span class="string">"Travis CI Auto Builder at `date +"</span><span class="string">%Y-%m-%d</span> <span class="string">%H:%M"`"</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">git</span> <span class="string">push</span> <span class="bullet">--force</span> <span class="bullet">--quiet</span> <span class="string">"https://$&#123;github_blog@$&#123;GH_REF&#125;"</span> <span class="attr">master:master</span></span><br><span class="line"><span class="attr">branches:</span></span><br><span class="line"><span class="attr">  only:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">hexo</span></span><br><span class="line"><span class="attr">env:</span></span><br><span class="line"><span class="attr">  global:</span></span><br><span class="line"><span class="attr">  - GH_REF:</span> <span class="string">github.com/BraveY/BraveY.github.io.git</span></span><br><span class="line"><span class="attr">notifications:</span></span><br><span class="line"><span class="attr">  email:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">lsz_yky@163.com</span></span><br><span class="line"><span class="attr">  on_success:</span> <span class="string">change</span></span><br><span class="line"><span class="attr">  on_failure:</span> <span class="string">always</span></span><br></pre></td></tr></table></figure>
<h3 id="新增文章到-posts"><a href="#新增文章到-posts" class="headerlink" title="新增文章到_posts"></a>新增文章到_posts</h3><p>增减文章后，使用git push 命令即可，自动部署。</p>
<p>可以看到 Travis CI 上面构建的一系列输出，但是博客并没有更新，而且github上的master分支也没有更改过。查看Travis CI 上的输出信息，发现在执行</p>
<p><code>git push --force --quiet &quot;https://${github_blog@${GH_REF}&quot; master:master</code> 这句后报错：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/home/travis/.travis/functions: eval: line 104: unexpected EOF while looking for matching `&quot;&apos;</span><br><span class="line">/home/travis/.travis/functions: eval: line 105: syntax error: unexpected end of file</span><br></pre></td></tr></table></figure>
<p>然后发现<code>${github_blog@${GH_REF}</code> 这句花括号没有对齐匹配，无语。加上漏掉的右边花括号} 重新执行操作。一切正常。</p>
<h2 id="博客更新操作"><a href="#博客更新操作" class="headerlink" title="博客更新操作"></a>博客更新操作</h2><p>后面就不用自己<code>hexo g -d</code> 了</p>
<p>在_posts目录下增加文章后</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m&quot;&quot;</span><br><span class="line">git push origin</span><br></pre></td></tr></table></figure>
<p>感觉可以写个脚本</p>
<p>命名为git_script.ps1  以后直接用powershell运行这个脚本就可以了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">$date = get-date -uformat &quot;%Y-%m-%d %H:%M:%S&quot;</span><br><span class="line">git commit -m&quot;new post $date&quot;</span><br><span class="line">git push origin</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.itfanr.cc/2017/08/09/using-travis-ci-automatic-deploy-hexo-blogs/" target="_blank" rel="noopener">https://www.itfanr.cc/2017/08/09/using-travis-ci-automatic-deploy-hexo-blogs/</a></p>
<p><a href="http://www.dxjia.cn/2016/01/27/hexo-write-everywhere/" target="_blank" rel="noopener">http://www.dxjia.cn/2016/01/27/hexo-write-everywhere/</a></p>
<p><a href="http://www.yanglangjing.com/2018/08/28/travis_ci_auto_deploy_hexo_to_vps/" target="_blank" rel="noopener">http://www.yanglangjing.com/2018/08/28/travis_ci_auto_deploy_hexo_to_vps/</a></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Travis-CI</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis源码阅读——SDS</title>
    <url>/Redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E2%80%94%E2%80%94SDS/2019-03-22-Redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E2%80%94%E2%80%94SDS.html</url>
    <content><![CDATA[<h1 id="Redis源码阅读——SDS"><a href="#Redis源码阅读——SDS" class="headerlink" title="Redis源码阅读——SDS"></a>Redis源码阅读——SDS</h1><p>参考Redis设计与实现 以及网上博客阅读Redis源码。</p>
<a id="more"></a>
<p>SDS相关知识点见读书笔记。</p>
<h2 id="创建和销毁"><a href="#创建和销毁" class="headerlink" title="创建和销毁"></a>创建和销毁</h2><p>为了能够对sds进行相关API的测试，因此把sds模块单独提出来。阅读Redis的Makefile发现，编译sds模块需要的源文件包括<code>sds.c</code>, <code>sds.h</code> <code>zmalloc.c</code> </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">test-sds: sds.c sds.h</span><br><span class="line">        $(REDIS_CC) sds.c zmalloc.c -DSDS_TEST_MAIN $(FINAL_LIBS) -o /tmp/sds_test</span><br><span class="line">        /tmp/sds_test</span><br></pre></td></tr></table></figure>
<p>但是实际编译后会发现会报很多函数未定义的错。原因是redis源码里面sds的内存分配、释放、重分配这些函数是封装成zmalloc,zfee这些函数的，只单纯的把zmalloc.c提取出来是远远不够的。后面发现redis的作者已经把sds给单独提出来了。包括三个源文件<code>sds.c</code>,<code>sds.h</code>,<code>sdsalloc.h</code> 因此执行如下操作即可单独把redis的sds模块提取出来。</p>
<h3 id="提取sds模块"><a href="#提取sds模块" class="headerlink" title="提取sds模块"></a>提取sds模块</h3><ol>
<li><p>新建redis_sds测试目录</p>
<p>选择合适的目录下新建</p>
<p><code>mkdir redis_sds</code></p>
</li>
<li><p>复制源文件至redis_sds目录下</p>
<p>在redis源码的src目录下执行：</p>
<p><code>cp sds.c ~/redis_sds/</code></p>
<p><code>cp sds.h ~/redis_sds/</code></p>
<p><code>cp sdsalloc.h ~/redis_sds/</code></p>
</li>
<li><p>修改sdsalloc.h </p>
<p>复制过来的sdsalloc.h 将sds模块的内存函数封装为使用zmalloc函数。为了简化处理直接使用libc的malloc函数来进行内存管理，同时将zmalloc.h给注释掉。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//#include "zmalloc.h"</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> s_malloc malloc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> s_realloc realloc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> s_free free</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>新建主函数</p>
<p>新建主函数sds_test.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sds.c"</span></span></span><br><span class="line"><span class="comment">//#include "sds.h"</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    sds s = sdsnew(<span class="string">"Hello World!"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Length:%d, Type:%d\n"</span>, sdslen(s), sdsReqType(sdslen(s)));</span><br><span class="line"></span><br><span class="line">    s = sdscat(s, <span class="string">"The length of this sentence is greater than 32 bytes"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Length:%d, Type:%d\n"</span>, sdslen(s), sdsReqType(sdslen(s)));</span><br><span class="line"></span><br><span class="line">    sdsfree(s);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接include sds.c 即可，因为如果#include “sds.h” 的话，sdsReqType这个函数并没有在sds.h里面声明，而且因为sdsReqType的申明是：</p>
<p><code>static inline char sdsReqType(size_t string_size) {</code>  有static限制所以不能在sds.h中先声明，所以为了简单就直接#include 了sds.c了</p>
</li>
<li><p>编译  </p>
<p>为了方便重复编译，所以写了个简单的Makefile。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">test : sds_test.c sds.h sds.c sdsalloc.h</span><br><span class="line">        gcc -o sdstest sds_test.c</span><br></pre></td></tr></table></figure>
<p>只需要编译sds_test.c 即可。因为sds_test.c 里面是直接#include sds.c 了所以再</p>
<p><code>gcc -o sdstest sds_test.c sds.c</code> 会将sds.c 里面的函数重复编译两次，造成Multiple definition 问题。</p>
<p>之后只需要执行make命令就可以生成可执行文件sdstest。</p>
<p>执行后输出为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./sdstest </span><br><span class="line">Length:12, Type:0</span><br><span class="line">Length:64, Type:1</span><br></pre></td></tr></table></figure>
<h3 id="sds的创建"><a href="#sds的创建" class="headerlink" title="sds的创建"></a>sds的创建</h3><p>通过<code>sdsnew</code> 来创建了一个sds。sdsnew源码为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Create a new sds string starting from a null terminated C string. */</span></span><br><span class="line"><span class="function">sds <span class="title">sdsnew</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *init)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//使用？条件判断符来简化if语句对NULL的判断，直接使用strlen来返回字符指针的长度。</span></span><br><span class="line">    <span class="keyword">size_t</span> initlen = (init == <span class="literal">NULL</span>) ? <span class="number">0</span> : <span class="built_in">strlen</span>(init); </span><br><span class="line">    <span class="keyword">return</span> sdsnewlen(init, initlen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是字符数组和字符指针是有区别的：字符指针的数据是存放在进程的虚拟地址空间的程序代码和数据段，是只读的不能修改。字符数组存放的字符串数据是存放在用户栈的，是可以更改的。且字符指针的数据没有”\0”这个结束符。</p>
<p>参考博客讲的很好：<a href="https://blog.csdn.net/on_1y/article/details/13030439" target="_blank" rel="noopener">https://blog.csdn.net/on_1y/article/details/13030439</a></p>
<p><code>sdsnew</code> 通过把字符串长度和字符串传递给<code>sdsnewlen</code>，来完成创建。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* Create a new sds string with the content specified by the 'init' pointer</span></span><br><span class="line"><span class="comment"> * and 'initlen'.</span></span><br><span class="line"><span class="comment"> * If NULL is used for 'init' the string is initialized with zero bytes.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The string is always null-termined (all the sds strings are, always) so</span></span><br><span class="line"><span class="comment"> * even if you create an sds string with:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * mystring = n("abc",3);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * You can print the string with printf() as there is an implicit \0 at the</span></span><br><span class="line"><span class="comment"> * end of the string. However the string is binary safe and can contain</span></span><br><span class="line"><span class="comment"> * \0 characters in the middle, as the length is stored in the sds header. */</span></span><br><span class="line"><span class="function">sds <span class="title">sdsnewlen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *init, <span class="keyword">size_t</span> initlen)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *sh;</span><br><span class="line">    sds s;</span><br><span class="line">    <span class="keyword">char</span> type = sdsReqType(initlen);  <span class="comment">//返回字符串对应的type</span></span><br><span class="line">    <span class="comment">/* Empty strings are usually created in order to append. Use type 8</span></span><br><span class="line"><span class="comment">     * since type 5 is not good at this. */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    空字符串使用sdshdr8来存储，而不是sdshdr5,（虽然长度小于32），因为sdshdr5不适合扩容。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (type == SDS_TYPE_5 &amp;&amp; initlen == <span class="number">0</span>) type = SDS_TYPE_8;</span><br><span class="line">    <span class="keyword">int</span> hdrlen = sdsHdrSize(type); <span class="comment">// 返回对应类型的sdsheader长度。</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *fp; <span class="comment">/* flags pointer. */</span></span><br><span class="line"></span><br><span class="line">    sh = s_malloc(hdrlen+initlen+<span class="number">1</span>); <span class="comment">// 申请头部+字符串+NULL的大小。(单位为byte)</span></span><br><span class="line">    <span class="keyword">if</span> (!init)</span><br><span class="line">        <span class="built_in">memset</span>(sh, <span class="number">0</span>, hdrlen+initlen+<span class="number">1</span>); <span class="comment">// 将sh后面对应大小的字节全部置为0；</span></span><br><span class="line">    <span class="keyword">if</span> (sh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    s = (<span class="keyword">char</span>*)sh+hdrlen; <span class="comment">//s指针指向字符串的首字节。</span></span><br><span class="line">    fp = ((<span class="keyword">unsigned</span> <span class="keyword">char</span>*)s)<span class="number">-1</span>; <span class="comment">// fp指针指向flag</span></span><br><span class="line">    <span class="keyword">switch</span>(type) &#123;  <span class="comment">// 初始化sdshdr</span></span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_5: &#123;</span><br><span class="line">            *fp = type | (initlen &lt;&lt; SDS_TYPE_BITS);<span class="comment">// 设置flag这个字节的具体值</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_8: &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">8</span>,s); <span class="comment">// 获取header指针sh</span></span><br><span class="line">            sh-&gt;len = initlen; <span class="comment">//header中len的初始</span></span><br><span class="line">            sh-&gt;alloc = initlen; <span class="comment">//header 中alloc的初试</span></span><br><span class="line">            *fp = type;  <span class="comment">//flag 的初始。</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_16: &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">16</span>,s);</span><br><span class="line">            sh-&gt;len = initlen;</span><br><span class="line">            sh-&gt;alloc = initlen;</span><br><span class="line">            *fp = type; </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_32: &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">32</span>,s);</span><br><span class="line">            sh-&gt;len = initlen;</span><br><span class="line">            sh-&gt;alloc = initlen;</span><br><span class="line">            *fp = type;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_64: &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">64</span>,s);</span><br><span class="line">            sh-&gt;len = initlen;</span><br><span class="line">            sh-&gt;alloc = initlen;</span><br><span class="line">            *fp = type;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (initlen &amp;&amp; init)</span><br><span class="line">        <span class="built_in">memcpy</span>(s, init, initlen); <span class="comment">// 将字符串拷贝到s(也就是buf数组)</span></span><br><span class="line">    s[initlen] = <span class="string">'\0'</span>; <span class="comment">//在字符串后面添加终止符</span></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>char type = sdsReqType(initlen);</code> 获取sds类型，源码分析在读书笔记里面有记录。源码为</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">sdsReqType</span><span class="params">(<span class="keyword">size_t</span> string_size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (string_size &lt; <span class="number">1</span>&lt;&lt;<span class="number">5</span>) <span class="comment">// string_size &lt; 2^5</span></span><br><span class="line">        <span class="keyword">return</span> SDS_TYPE_5;</span><br><span class="line">    <span class="keyword">if</span> (string_size &lt; <span class="number">1</span>&lt;&lt;<span class="number">8</span>)  <span class="comment">//string_size &lt; 2^8</span></span><br><span class="line">        <span class="keyword">return</span> SDS_TYPE_8;</span><br><span class="line">    <span class="keyword">if</span> (string_size &lt; <span class="number">1</span>&lt;&lt;<span class="number">16</span>)	<span class="comment">//string_size &lt; 2^16</span></span><br><span class="line">        <span class="keyword">return</span> SDS_TYPE_16;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (LONG_MAX == LLONG_MAX)</span></span><br><span class="line">    <span class="keyword">if</span> (string_size &lt; <span class="number">1l</span>l&lt;&lt;<span class="number">32</span>)  <span class="comment">//string_size &lt; 2^32</span></span><br><span class="line">        <span class="keyword">return</span> SDS_TYPE_32;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> SDS_TYPE_64; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>采用左移来计算对应多少位的范围，而不是用2^5 这样的乘法。<strong>直接移位比使用幂来计算快很多</strong>。</p>
<p><code>1&lt;&lt;5</code>   计算出来就是2^5 次方。1是int型，4byte32位。最低8bit位的二进制为：00000001 左移5位后变成了：00100000 对应的十进制既是32。</p>
<p>计算n个bit位的最大值：(1&lt;&lt;n) -1</p>
<p>但是需要注意位数不够的情况。因为1是int型，只有32个bit。所以在左移32个bit时，需要使用long long int型。用1ll来表示，此时1ll为64个bit。</p>
<p>还得考虑机器是否为64位机器，在32位机器上LONG_MAX = 2147483647L，64位机器上LONG_MAX = 9223372036854775807L 。不论32位机器还是64位机器上 LLONG_MAX 都是9223372036854775807L 。所以当LONG_MAX == LLONG_MAX 说明字长为64bit。加上条件编译，说明在32位机器上不使用sdshdr32而直接跳到了sdshdr64，仅仅在64位机器上使用sdshdr32。原因是什么？还没想通</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">sdsHdrSize</span><span class="params">(<span class="keyword">char</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(type&amp;SDS_TYPE_MASK) &#123;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_5:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">sizeof</span>(struct sdshdr5);</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_8:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">sizeof</span>(struct sdshdr8);</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_16:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">sizeof</span>(struct sdshdr16);</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_32:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">sizeof</span>(struct sdshdr32);</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_64:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">sizeof</span>(struct sdshdr64);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为struct里面的buf数组是柔性数组，计算结构体的大小的时候不会计算在内。</p>
<p><code>memset(sh, 0, hdrlen+initlen+1);</code>  memset函数会将sh中当前位置后面的<code>hdrlen+initlen+1</code>个字节全部置于0。 注意sh指向的是<code>hdrlen+initlen+1</code> 个字节的首个字节。（sh指针存储的地址就是首个字节的地址。） </p>
<p>memset源码为：<a href="https://github.com/gcc-mirror/gcc/blob/master/libgcc/memset.c" target="_blank" rel="noopener">https://github.com/gcc-mirror/gcc/blob/master/libgcc/memset.c</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Public domain.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stddef.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *</span><br><span class="line"><span class="built_in">memset</span> (<span class="keyword">void</span> *dest, <span class="keyword">int</span> val, <span class="keyword">size_t</span> len)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> *ptr = dest; <span class="comment">// 用char来限定每次指针+1只移动一个字节。</span></span><br><span class="line">  <span class="keyword">while</span> (len-- &gt; <span class="number">0</span>)</span><br><span class="line">    *ptr++ = val;</span><br><span class="line">  <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设<code>hdrlen+initlen+1</code> 为8 ，经过memset后，从sh首字节开始共有8个字节都被置为0。</p>
<p><img src="https://res.cloudinary.com/bravey/image/upload/v1553525055/blog/memset.png" alt=""></p>
<p>指针的类型时用来确定指针需要从首地址寻址（偏移）多少个字节。比如int * 指针说明指针存储的地址朝后面偏移3个字节才是这个int类型的所有数据。即指针存储的地址时起点，而终点是由类型来确定的。此外，类型也是指针加减的步长，比如char类型的步长就是1byte，而uint_16类型的指针步长就是2byte。</p>
<p>随后用switch语句对不同类型的sdshdr设置初始值。</p>
<p>首先是sdshdr5</p>
<p> <code>*fp = type | (initlen &lt;&lt; SDS_TYPE_BITS)</code> 使用移位和或操作的方式来对8个bit位赋值。(不得不感慨这些操作真的是太巧妙了)</p>
<p>假设initlen为3。则initlen的二进制为0000 0011（应该是8byte（64位机器）或者4byte（32位机器），为了简单用1byte的二进制表示）而SDS_TYPE_BITS 为3。所以先将initlen 左移3个bit 变成0000 0001 1000(共有8byte或者4byte)。再与type进行或运算。type为0000 0000 进行或运算后，得到的内容是8bit的，因为type是char类型，即0001 1000 。</p>
<p>其他sdshdr类型的设置都差不多，详解下sdshdr8.</p>
<p><code>SDS_HDR_VAR(8,s)</code>  <code>SDS_HDR_VAR</code> 是个宏定义的函数</p>
<p><code>#define SDS_HDR_VAR(T,s) struct sdshdr##T *sh = (void*)((s)-(sizeof(struct sdshdr##T)));</code></p>
<p>采用宏定义函数的好处是</p>
<ol>
<li>能够减少额外的开销 因为如果写成普通函数的话，函数的调用会在用户栈开辟空间，形参压栈，返回时还需要释放栈，可想而知的开销。使用宏定义函数则在代码规模和速度方面都比函数更胜一筹。宏定义的本质就是替换，所以在使用宏定义函数的地方，执行的时候相当于是在直接执行<code>struct sdshdr##T *sh = (void*)((s)-(sizeof(struct sdshdr##T)))</code> 这句代码</li>
<li>函数的参数必须被声明为一种特定的类型，所以它只能在类型合适的表达式上使用。而宏定义则可以用于整形、长整形、单浮点型、双浮点型以及其他任何可以用“&gt;”操作符比较值大小的类型，也就是说，宏是与类型无关的。（有点C++模版类的感觉）</li>
</ol>
<p>宏定义函数中的## 是（token-pasting）<strong>符号连接操作符</strong> 直接将形参T链接到sdshdr上面。也就是sdshdrT。</p>
<p>所以这句代码也就很简单了，将字符串指针s向后移动header的大小，也就得到了header的指针。（不过有个疑问是为什么还要重新获取headr的地址，最开始不就是指向了header吗？，难道memset是直接对sh进行操作的？测试过了，memset不会修改sh的地址，所以应该是为了再次确保sh一定指向header）</p>
<p>解释一下：SDS_HDR_VAR 的作用是将sh的类型修改为结构体指针，因为之前sh 一直都是空指针，(虽然指针的指向地址是headr，但是没有限定它类型)不然后面没法用sh-&gt;len, sh-&gt;alloc 来访问对应的结构体成员。</p>
<p>最开始创建的时候alloc 和len是一样大的，没有分配多余空间）</p>
<p><code>memcpy(s, init, initlen);</code> 函数将init的前initlen个字符拷贝给s。</p>
<p>memcpy源码为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/* Public domain.  */</span><br><span class="line">#include &lt;stddef.h&gt;</span><br><span class="line"></span><br><span class="line">void *</span><br><span class="line">memcpy (void *dest, const void *src, size_t len)</span><br><span class="line">&#123;</span><br><span class="line">  char *d = dest;</span><br><span class="line">  const char *s = src;</span><br><span class="line">  while (len--)</span><br><span class="line">    *d++ = *s++;</span><br><span class="line">  return dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整个过程中的三个指针sh,s,fp对应关系如下图</p>
<p><img src="https://res.cloudinary.com/bravey/image/upload/v1553525055/blog/sds.png" alt=""></p>
</li>
</ol>
<h2 id="销毁"><a href="#销毁" class="headerlink" title="销毁"></a>销毁</h2><p>销毁使用sdsfree来实现</p>
<p>源码为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Free an sds string. No operation is performed if 's' is NULL. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsfree</span><span class="params">(sds s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    s_free((<span class="keyword">char</span>*)s-sdsHdrSize(s[<span class="number">-1</span>]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>s[-1],就是指针s向后移动移位，也就是flag的位置。将s移动到sh的位置，释放sh指针也就释放了整个sds内存。</p>
<p>疑惑：sh指针在sdsnewlen函数中是个局部变量，在sdsnewlen函数中是自动释放的，这里并没有传递sh指针为什么也可以释放对应的空间？</p>
<p>自己想了下：malloc 函数传递的参数是需要分配的内存大小(len)，返回的是指针也就是地址。free()函数只用将malloc函数返回的指针(地址)作为参数传入，就可以释放之前该地址分配到的内存空间。而地址只是首地址，总共的偏移量（大小），应该是由操作系统在内存分配的时候就记录了的。</p>
<p>博客中记录：申请的时候实际上占用的内存要比申请的大。因为超出的空间是用来记录对这块内存的管理信息。额外的空间用来记录管理信息——分配块的长度，指向下一个分配块的指针等等。果然malloc的时候用来一个struct来记录分配的信息。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mem_control_block</span> &#123;</span> </span><br><span class="line">  <span class="keyword">int</span> is_available;    <span class="comment">//一般来说应该是一个可用空间的首地址，但这里英文单词却显示出空间是否可用的一个标记</span></span><br><span class="line">  <span class="keyword">int</span> size;            <span class="comment">//这是实际空间的大小 </span></span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
<p><a href="http://www.cnblogs.com/hanyonglu/archive/2011/04/28/2031271.html" target="_blank" rel="noopener">http://www.cnblogs.com/hanyonglu/archive/2011/04/28/2031271.html</a></p>
<p>free()就是根据这个结构体的信息来释放malloc()申请的空间</p>
<p>另外的疑惑：释放完空间后，s 指针不用把它指向null吗？  </p>
<p>暂时就只是创建和销毁的源码把，看了两天，阅读源码真的是酣畅淋漓，收获良多。学到了很多奇妙的C技巧，还对操作系统的知识有了更具象的理解。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>阅读sdsfromlonglong部分的源码：</p>
<p>sdsfromlonglong 函数用于将一个long long 类型的整形数字转换为字符数组。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Create an sds string from a long long value. It is much faster than:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * sdscatprintf(sdsempty(),"%lld\n", value);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">sds <span class="title">sdsfromlonglong</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[SDS_LLSTR_SIZE];  <span class="comment">// 给buf数组分配最小的空间，21的长度</span></span><br><span class="line">    <span class="keyword">int</span> len = sdsll2str(buf,value); <span class="comment">//将long long 转为字符数组存储在buf中，并返回字符串的长度</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sdsnewlen(buf,len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到主要的转换操作在sdsll2str这个函数中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Helper for sdscatlonglong() doing the actual number -&gt; string</span></span><br><span class="line"><span class="comment"> * conversion. 's' must point to a string with room for at least</span></span><br><span class="line"><span class="comment"> * SDS_LLSTR_SIZE bytes.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The function returns the length of the null-terminated string</span></span><br><span class="line"><span class="comment"> * representation stored at 's'. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_LLSTR_SIZE 21</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sdsll2str</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">long</span> <span class="keyword">long</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *p, aux;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> v; </span><br><span class="line">    <span class="keyword">size_t</span> l;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Generate the string representation, this method produces</span></span><br><span class="line"><span class="comment">     * an reversed string. */</span></span><br><span class="line">    v = (value &lt; <span class="number">0</span>) ? -value : value;  <span class="comment">//判断是否为负数</span></span><br><span class="line">    p = s;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        *p++ = <span class="string">'0'</span>+(v%<span class="number">10</span>); <span class="comment">// 除以10取余数</span></span><br><span class="line">        v /= <span class="number">10</span>;     <span class="comment">//去除个位</span></span><br><span class="line">    &#125; <span class="keyword">while</span>(v);</span><br><span class="line">    <span class="keyword">if</span> (value &lt; <span class="number">0</span>) *p++ = <span class="string">'-'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Compute length and add null term. */</span></span><br><span class="line">    l = p-s;   <span class="comment">// 计算出字符串的长度 不含终止符</span></span><br><span class="line">    *p = <span class="string">'\0'</span>; <span class="comment">// 首地址填终止符。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Reverse the string. */</span></span><br><span class="line">    p--;</span><br><span class="line">    <span class="keyword">while</span>(s &lt; p) &#123;</span><br><span class="line">        aux = *s;</span><br><span class="line">        *s = *p;</span><br><span class="line">        *p = aux;</span><br><span class="line">        s++;</span><br><span class="line">        p--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    *p++ = <span class="string">'0'</span>+(v%<span class="number">10</span>); <span class="comment">// 除以10取余数</span></span><br><span class="line">    v /= <span class="number">10</span>;     <span class="comment">//去除个位</span></span><br><span class="line">&#125; <span class="keyword">while</span>(v);</span><br></pre></td></tr></table></figure>
<p>假设v是352，变成字符串是将每一个对应的10进制上面的3,5,2这三个个位、十位、百位的数字给单独变成字符。</p>
<p><code>*p++ = &#39;0&#39;+(v%10);</code> p 指针是字符数组buf的首地址，而将整型变成字符型的操作就是与字符’0’ 相加，这样就可以对应的数字变成字符类型。同时p相应的加1来指向下一个byte用来存储下一个被转换的char。</p>
<p>char类型存储的是对应字符的ascii值，ASCII表为：<a href="https://baike.baidu.com/item/ASCII/309296" target="_blank" rel="noopener">https://baike.baidu.com/item/ASCII/309296</a> ，所以字符的运算实际上是对应的ASCII的值的运算。<br>v%10是除以10取余数，352%10 =2； 35%10=5，所以也就是取得v值的10进制上面的个位数。<br>所以在while循环里面每次对v除以10并取余，就可以得到对应long long 型的字符串。<br>但是因为每次得到的字符都是最后面的个位数，所以352，所输出的字符串数组为：‘2’， ‘3’， ‘5’ 是一个倒序的，因此还需要再反转一次。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Reverse the string. */</span> </span><br><span class="line">p--;</span><br><span class="line"><span class="keyword">while</span>(s &lt; p) &#123;</span><br><span class="line">    aux = *s;</span><br><span class="line">    *s = *p;</span><br><span class="line">    *p = aux;</span><br><span class="line">    s++;</span><br><span class="line">    p--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>字符串反转，首尾各有一个指针，当首指针小于尾指针的时候，交换数字，并同时向中间移动</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/yangbodong22011/article/details/78419966" target="_blank" rel="noopener">https://blog.csdn.net/yangbodong22011/article/details/78419966</a></p>
]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>源码阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis设计与实现读书笔记——第二章SDS</title>
    <url>/2019-03-20-Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.html</url>
    <content><![CDATA[<h1 id="Redis设计与实现读书笔记——第二章"><a href="#Redis设计与实现读书笔记——第二章" class="headerlink" title="Redis设计与实现读书笔记——第二章"></a>Redis设计与实现读书笔记——第二章</h1><p>为了做Redis相关实验，在网上粗略看了Redis设计与实现的电子版，感觉收获很多，但是因为是旧版，所以买了第二版，重读第二次。</p>
<a id="more"></a>
<h2 id="第二章-简单动态字符串"><a href="#第二章-简单动态字符串" class="headerlink" title="第二章 简单动态字符串"></a>第二章 简单动态字符串</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ol>
<li>字符串值的键值对在底层都是由SDS实现的。</li>
<li>sds的功能：<ol>
<li>存储字符串值</li>
<li>用作缓冲区<ol>
<li>AOF模块缓冲区</li>
<li>客户端状态的输入缓冲区</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="2-1-SDS的定义"><a href="#2-1-SDS的定义" class="headerlink" title="2.1 SDS的定义"></a>2.1 SDS的定义</h3><p>文件：sds.h/sdshdr 结构体 </p>
<p>书中的为3.0版本，4.0版本有较大改动。</p>
<p>version: redis-4.02 </p>
<p>参考：<a href="https://www.cnblogs.com/chenpingzhao/p/7292182.html" target="_blank" rel="noopener">https://www.cnblogs.com/chenpingzhao/p/7292182.html</a></p>
<p><a href="https://www.codesheep.cn/2018/08/09/Redis%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%E5%86%85%E9%83%A8%E7%BC%96%E7%A0%81%E5%89%96%E6%9E%90/" target="_blank" rel="noopener">https://www.codesheep.cn/2018/08/09/Redis%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%E5%86%85%E9%83%A8%E7%BC%96%E7%A0%81%E5%89%96%E6%9E%90/</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> *sds;  <span class="comment">//注意，sds其实不是一个结构体类型，而是被typedef的char*</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Note: sdshdr5 is never used, we just access the flags byte directly.</span></span><br><span class="line"><span class="comment"> * However is here to document the layout of type 5 SDS strings. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr5</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, and 5 msb of string length */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr8</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr16</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint16_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr32</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr64</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="keyword">uint64_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>除了结构体字段对len和alloc的数据类型的不同(<code>unit8, unit16， unit32, unit64</code>)，  其字段含义相差无几。其中header记录<code>len, alloc, flags</code> 信息。不同的header的目的是节省内存。<strong>header与buf数组在内存地址上前后相邻。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+--------+-------------------------------+-----------+</span><br><span class="line">| Header | Binary safe C alike string... | Null term |</span><br><span class="line">+--------+-------------------------------+-----------+</span><br><span class="line">         |</span><br><span class="line">         `-&gt; Pointer returned to the user.</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">len: 记录buf数组中已使用的字节数量 等于保存的字符串的长度 （不算结尾的\0 标识符）</span><br><span class="line">alloc: 字符串最大的容量。（除开header和最后的null终止符） </span><br><span class="line">flags: 总是会占用一个字节 8bit，加上unsigned是因为flags都是非负数 ，其中的最低3个bit用来表示header的类型还有 5个bit没有使用。</span><br><span class="line">buf: 字符数组，用于保存字符串。  柔性数组</span><br></pre></td></tr></table></figure>
<p>buf的大小=alloc+1；</p>
<p>header类型定义中，注意的地方：</p>
<ul>
<li><p>在各个header的定义中使用了<strong>attribute</strong> ((packed))，是为了让<strong>编译器以紧凑模式来分配内存</strong>，取消字节对齐。</p>
<ul>
<li>结构体的成员内存是’”连续”的，但是这个连续是以对齐的单位而言的。比如说A成员的内存是3个字节，假设对齐单位是4个字节，会给A成员多分配一个字节。A成员后面才又紧接B成员的内存。</li>
<li>如果没有这个属性，编译器可能会为struct的字段做优化对齐，在其中填充空字节。那样的话，就不能保证header和sds的数据部分紧紧前后相邻，也不能按照固定向低地址方向偏移1个字节的方式来获取flags字段了。</li>
</ul>
</li>
<li><p>在各个header的定义中最后有一个char buf[]。我们注意到这是一个没有指明长度的字符数组，这是C语言中定义字符数组的一种特殊写法，称为<strong>柔性数组</strong>（<a href="https://en.wikipedia.org/wiki/Flexible_array_member" target="_blank" rel="noopener">flexible array member</a>），只能定义在一个结构体的最后一个字段上。它在这里只是起到一个标记的作用，表示在flags字段后面就是一个字符数组，或者说，它指明了紧跟在flags字段后面的这个字符数组在结构体中的偏移位置。而程序在为header分配的内存的时候，它并不占用内存空间。如果计算sizeof(struct sdshdr16)的值，那么结果是5个字节，其中没有buf字段。</p>
</li>
<li><p>sdshdr5与其它几个header结构不同，它不包含alloc字段，而长度使用flags的高5位来存储。因此，它不能为字符串分配空余空间。如果字符串需要动态增长，那么它就必然要重新分配内存才行。所以说，这种类型的sds字符串更适合存储静态的短字符串（长度小于32）。 因为长度的范围是5个bit来存储的</p>
<script type="math/tex; mode=display">
2^5-1 = 31</script></li>
</ul>
<p>sds字符串的header，其实隐藏在真正的字符串数据的前面（低地址方向）。这样的一个定义，有如下几个好处</p>
<ul>
<li>header和数据相邻，而不用分成两块内存空间来单独分配。这有利于减少内存碎片，提高存储效率（memory efficiency）。</li>
<li>虽然header有多个类型，但sds可以用统一的char *来表达。且它与传统的C语言字符串保持类型兼容。如果一个sds里面存储的是可打印字符串，那么我们可以直接把它传给C函数，比如使用strcmp比较字符串大小，或者使用printf进行打印。<h3 id="2-2-SDS与C字符串的区别"><a href="#2-2-SDS与C字符串的区别" class="headerlink" title="2.2 SDS与C字符串的区别"></a>2.2 SDS与C字符串的区别</h3></li>
</ul>
<p>c语言使用N+1长度的字符数组来表示长度为N的字符串，因为需要增加一个<code>\0</code> 字符终止</p>
<h4 id="2-2-1-常数复杂度获取字符串长度"><a href="#2-2-1-常数复杂度获取字符串长度" class="headerlink" title="2.2.1  常数复杂度获取字符串长度"></a>2.2.1  常数复杂度获取字符串长度</h4><p>因为c语言要知道字符串的长度只能遍历数组，所以复杂度为O(N)。 </p>
<p>而获取sds的字符串长度，只需要返回len的值就可以了复杂度为O(1)。这样对一个非常长的字符串键反复执行STRLEN命令，也不会对系统性能造成任何影响。</p>
<h4 id="2-2-2-杜绝缓冲区溢出"><a href="#2-2-2-杜绝缓冲区溢出" class="headerlink" title="2.2.2 杜绝缓冲区溢出"></a>2.2.2 杜绝缓冲区溢出</h4><p>C字符串不记录自身长度会带来易造成缓冲区溢出的问题。 比如使用strcat函数拼接两个字符串，被拼接的字符串要是没有提前分配空间，就会造成缓冲区溢出。（溢出的字节会导致这个字符串内存紧邻的其他字符串的内容被修改）</p>
<p>而SDS的空间分配策略完全杜绝了发生缓冲区溢出的可能，SDS的API需要修改SDS时，会先检查空间alloc是否满足修改所需的要求。不满足的话会先将空间扩展至修改所需的大小，再执行修改。</p>
<h4 id="2-2-3-减少修改字符串时带来的内存重分配次数"><a href="#2-2-3-减少修改字符串时带来的内存重分配次数" class="headerlink" title="2.2.3 减少修改字符串时带来的内存重分配次数"></a>2.2.3 减少修改字符串时带来的内存重分配次数</h4><p>C语言字符串用N+1个字节长的数组来保存N个字节的字符串，因为这个关联性所以每次每次增长或者缩短一个C字符串，都要对这个字符串进行一次内存重分配操作。</p>
<ul>
<li>执行增长操作 比如append，需要首先通过内存重分配来扩展底层数组的空间大小，否则产生缓冲区溢出</li>
<li>执行所动操作比如截断操作trime，需要首先通过内存重分配来释放字符串不再使用的空间，否则造成内存泄漏。</li>
</ul>
<p>内存重分配涉及复杂的算法，并且可能需要执行系统调用，所以通常是一个比较耗时的操作。这对Redis经常用于速度要求严苛，数据被频繁修改的场合来说，是不可接受的。</p>
<p>因此SDS通过未使用空间解除了字符串长度和底层数组长度之间的关联：buf的长度可以大于len的长度。 <strong>（4.0版本的源码还未找到对应的函数，所以可能和书上说的有变化了）</strong></p>
<ol>
<li><p>空间预分配 ——减少连续执行字符串增长操作所需的内存重分配次数。</p>
<ul>
<li><p>用于优化字符串<strong>增长</strong>操作。</p>
<p>当需要对SDS的空间进行空间扩展时，不仅会对SDS分配修改所必需的空间，还会额外分配未使用空间。</p>
<p>当len &lt; 1Mb时 alloc = 2*len; 当len &gt;= 1 mb时 alloc= len +1Mb。</p>
</li>
</ul>
<p>源码分析</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Enlarge the free space at the end of the sds string so that the caller</span></span><br><span class="line"><span class="comment"> * is sure that after calling this function can overwrite up to addlen</span></span><br><span class="line"><span class="comment"> * bytes after the end of the string, plus one more byte for nul term.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note: this does not change the *length* of the sds string as returned</span></span><br><span class="line"><span class="comment"> * by sdslen(), but only the free buffer space we have. */</span></span><br><span class="line"><span class="function">sds <span class="title">sdsMakeRoomFor</span><span class="params">(sds s, <span class="keyword">size_t</span> addlen)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *sh, *newsh;</span><br><span class="line">    <span class="keyword">size_t</span> avail = sdsavail(s);</span><br><span class="line">    <span class="keyword">size_t</span> len, newlen;</span><br><span class="line">    <span class="keyword">char</span> type, oldtype = s[<span class="number">-1</span>] &amp; SDS_TYPE_MASK;</span><br><span class="line">    <span class="keyword">int</span> hdrlen;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Return ASAP if there is enough space left. */</span></span><br><span class="line">    <span class="keyword">if</span> (avail &gt;= addlen) <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">    len = sdslen(s);</span><br><span class="line">    sh = (<span class="keyword">char</span>*)s-sdsHdrSize(oldtype);</span><br><span class="line">    newlen = (len+addlen);  <span class="comment">// 预分配</span></span><br><span class="line">    <span class="keyword">if</span> (newlen &lt; SDS_MAX_PREALLOC)</span><br><span class="line">        newlen *= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        newlen += SDS_MAX_PREALLOC;</span><br><span class="line"></span><br><span class="line">    type = sdsReqType(newlen);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Don't use type 5: the user is appending to the string and type 5 is</span></span><br><span class="line"><span class="comment">     * not able to remember empty space, so sdsMakeRoomFor() must be called</span></span><br><span class="line"><span class="comment">     * at every appending operation. */</span></span><br><span class="line">    <span class="keyword">if</span> (type == SDS_TYPE_5) type = SDS_TYPE_8;</span><br><span class="line"></span><br><span class="line">    hdrlen = sdsHdrSize(type);</span><br><span class="line">    <span class="keyword">if</span> (oldtype==type) &#123;</span><br><span class="line">        newsh = s_realloc(sh, hdrlen+newlen+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (newsh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        s = (<span class="keyword">char</span>*)newsh+hdrlen;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Since the header size changes, need to move the string forward,</span></span><br><span class="line"><span class="comment">         * and can't use realloc */</span></span><br><span class="line">        newsh = s_malloc(hdrlen+newlen+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (newsh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">memcpy</span>((<span class="keyword">char</span>*)newsh+hdrlen, s, len+<span class="number">1</span>);</span><br><span class="line">        s_free(sh);</span><br><span class="line">        s = (<span class="keyword">char</span>*)newsh+hdrlen;</span><br><span class="line">        s[<span class="number">-1</span>] = type;</span><br><span class="line">        sdssetlen(s, len);</span><br><span class="line">    &#125;</span><br><span class="line">    sdssetalloc(s, newlen);</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>惰性空间释放</p>
<ul>
<li><p>用于优化SDS的字符串<strong>缩短</strong>操作</p>
<p>缩短SDS保存的字符串时，并不立即使用内存重分配来回收缩短后多出来的字节，而是使用free属性，将这些字节的数量记录起来，并等待将来使用。</p>
</li>
</ul>
</li>
</ol>
<h4 id="2-2-4-二进制安全"><a href="#2-2-4-二进制安全" class="headerlink" title="2.2.4 二进制安全"></a>2.2.4 二进制安全</h4><p>C字符串中的字符必须符合某种编码（如ASCII），除了末尾字符串中间不能有<code>\0</code> 这个空字符，否则最先被程序读取的空字符将被认为是结尾，导致C字符串只能保存文本数据，而不能保存图片、音频、视频、压缩文件这样的二进制数据。</p>
<p>所谓二进制安全：以处理二进制的方式来处理SDS存放在buf数组里的数据，程序不会对其中的数据做任何限制、过滤、或者假设，数据在写入时是什么样的，被读取是就是什么样的。因为SDS使用len来判断字符串是否结束。</p>
<p>所以buf是字节数组，而不是字符数组。</p>
<h4 id="2-2-5-兼容部分C字符串函数"><a href="#2-2-5-兼容部分C字符串函数" class="headerlink" title="2.2.5 兼容部分C字符串函数"></a>2.2.5 兼容部分C字符串函数</h4><p>因为遵循C字符串以<code>\0</code>结尾的惯例，所以可以兼容<code>&lt;string.h&gt;/strcasecmp</code> ,<code>&lt;stdio.h&gt;/printf</code> 这些函数。但是是否是书上的使用结构体指针还是博客说的可以直接使用sds来调用？还需验证。</p>
<p>书：<code>printf(&quot;%s&quot;, sds-&gt;buf)</code>  sds是指向结构体的指针。</p>
<p>博客：<a href="https://blog.csdn.net/yangbodong22011/article/details/78419966" target="_blank" rel="noopener">https://blog.csdn.net/yangbodong22011/article/details/78419966</a>   :<code>printf(%s, sds)</code></p>
<p>源码中是直接使用sds</p>
<h4 id="2-2-6-总结"><a href="#2-2-6-总结" class="headerlink" title="2.2.6 总结"></a>2.2.6 总结</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">C字符串</th>
<th style="text-align:center">SDS</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">获取字符串长度复杂度为O(N)</td>
<td style="text-align:center">获取字符串长度复杂度为O(1)</td>
</tr>
<tr>
<td style="text-align:center">API不安全，可能造成缓冲区溢出</td>
<td style="text-align:center">API安全，不会造成缓冲区溢出</td>
</tr>
<tr>
<td style="text-align:center">修改字符串长度N次必然执行N次内存重分配</td>
<td style="text-align:center">最多执行N次内存重分配</td>
</tr>
<tr>
<td style="text-align:center">只能保存文本数据</td>
<td style="text-align:center">二进制安全文本与二进制数据皆可</td>
</tr>
<tr>
<td style="text-align:center">可使用<code>&lt;string.h&gt;</code>库中所有函数</td>
<td style="text-align:center">部分使用<code>&lt;string.h&gt;</code>库中函数</td>
</tr>
</tbody>
</table>
</div>
<h3 id="2-3-SDSAPI"><a href="#2-3-SDSAPI" class="headerlink" title="2.3 SDSAPI"></a>2.3 SDSAPI</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">函数</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">sdslen(const sds s)</td>
<td style="text-align:center">获取sds字符串长度 O（1）</td>
</tr>
<tr>
<td style="text-align:center">sdssetlen(sds s, size_t newlen)</td>
<td style="text-align:center">设置sds字符串长度</td>
</tr>
<tr>
<td style="text-align:center">sdsinclen(sds s, size_t inc)</td>
<td style="text-align:center">增加sds字符串长度</td>
</tr>
<tr>
<td style="text-align:center">sdsalloc(const sds s)</td>
<td style="text-align:center">获取sds字符串容量</td>
</tr>
<tr>
<td style="text-align:center">sdssetalloc(sds s, size_t newlen)</td>
<td style="text-align:center">设置sds字符串容量。</td>
</tr>
<tr>
<td style="text-align:center">sdsavail(const sds s)</td>
<td style="text-align:center">获取sds字符串空余空间（即alloc - len）</td>
</tr>
<tr>
<td style="text-align:center">sdsHdrSize(char type)</td>
<td style="text-align:center">根据header类型得到header大小</td>
</tr>
<tr>
<td style="text-align:center">sdsReqType(size_t string_size)</td>
<td style="text-align:center">根据字符串数据长度计算所需要的header类型。</td>
</tr>
</tbody>
</table>
</div>
<h4 id="sdsReqType函数源码分析"><a href="#sdsReqType函数源码分析" class="headerlink" title="sdsReqType函数源码分析"></a>sdsReqType函数源码分析</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">sdsReqType</span><span class="params">(<span class="keyword">size_t</span> string_size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (string_size &lt; <span class="number">1</span>&lt;&lt;<span class="number">5</span>) <span class="comment">// string_size &lt; 2^5</span></span><br><span class="line">        <span class="keyword">return</span> SDS_TYPE_5;</span><br><span class="line">    <span class="keyword">if</span> (string_size &lt; <span class="number">1</span>&lt;&lt;<span class="number">8</span>)  <span class="comment">//string_size &lt; 2^8</span></span><br><span class="line">        <span class="keyword">return</span> SDS_TYPE_8;</span><br><span class="line">    <span class="keyword">if</span> (string_size &lt; <span class="number">1</span>&lt;&lt;<span class="number">16</span>)	<span class="comment">//string_size &lt; 2^16</span></span><br><span class="line">        <span class="keyword">return</span> SDS_TYPE_16;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (LONG_MAX == LLONG_MAX)</span></span><br><span class="line">    <span class="keyword">if</span> (string_size &lt; <span class="number">1l</span>l&lt;&lt;<span class="number">32</span>)  <span class="comment">//string_size &lt; 2^32</span></span><br><span class="line">        <span class="keyword">return</span> SDS_TYPE_32;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> SDS_TYPE_64; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>采用左移来计算对应多少位的范围，而不是用2^5 这样的乘法。<strong>直接移位比使用幂来计算快很多</strong>。</p>
<p><code>1&lt;&lt;5</code>   计算出来就是2^5 次方。1是int型，4byte32位。最低8bit位的二进制为：00000001 左移5位后变成了：00100000 对应的十进制既是32。</p>
<p>计算n个bit位的最大值：(1&lt;&lt;n) -1</p>
<p>但是需要注意位数不够的情况。因为1是int型，只有32个bit。所以在左移32个bit时，需要使用long long int型。用1ll来表示，此时1ll为64个bit。</p>
<p>还得考虑机器是否为64位机器，在32位机器上LONG_MAX = 2147483647L，64位机器上LONG_MAX = 9223372036854775807L 。不论32位机器还是64位机器上 LLONG_MAX 都是9223372036854775807L 。所以当LONG_MAX == LLONG_MAX 说明字长为64bit。加上条件编译，说明在32位机器上不使用sdshdr32而直接跳到了sdshdr64，仅仅在64位机器上使用sdshdr32。原因是什么？还没想通</p>
<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><ol>
<li>为什么Redis需要自己实现字符串功能，而不直接使用c语言的传统字符串？<ul>
<li>见第二节。</li>
</ul>
</li>
<li>执行SET 与GET命令的过程。</li>
<li><code>char buf[]</code> 为什么没有指定大小？一个数组占用的内存大小<ul>
<li>在各个header的定义中最后有一个char buf[]。我们注意到这是一个没有指明长度的字符数组，这是C语言中定义字符数组的一种特殊写法，称为柔性数组（<a href="https://en.wikipedia.org/wiki/Flexible_array_member" target="_blank" rel="noopener">flexible array member</a>），只能定义在一个结构体的最后一个字段上。它在这里只是起到一个标记的作用，表示在flags字段后面就是一个字符数组，或者说，它指明了紧跟在flags字段后面的这个字符数组在结构体中的偏移位置。而程序在为header分配的内存的时候，它并不占用内存空间。如果计算sizeof(struct sdshdr16)的值，那么结果是5个字节，其中没有buf字段。</li>
<li>数组内存大小为分配的的长度*数组类型的内存大小</li>
</ul>
</li>
<li>为什么redis 在32位机器上不使用sdshdr32？ </li>
</ol>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>源码阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>ping 无法连接外网</title>
    <url>/ping%20%E9%97%AE%E9%A2%98.html</url>
    <content><![CDATA[<h2 id="ping-无法连接外网"><a href="#ping-无法连接外网" class="headerlink" title="ping 无法连接外网"></a>ping 无法连接外网</h2><a id="more"></a>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>ping外网ping不通</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yky@hw076:~/tmux&gt; ping www.baidu.com</span><br><span class="line">ping: unknown host www.baidu.com</span><br><span class="line">yky@hw076:~/tmux&gt; ping 8.8.8.8</span><br><span class="line">connect: Network is unreachable</span><br></pre></td></tr></table></figure>
<p>ping内网可以ping通</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hw076:~ # ping 172.18.11.114</span><br><span class="line">PING 172.18.11.114 (172.18.11.114) 56(84) bytes of data.</span><br><span class="line">64 bytes from 172.18.11.114: icmp_seq=1 ttl=64 time=0.193 ms</span><br><span class="line">64 bytes from 172.18.11.114: icmp_seq=2 ttl=64 time=0.216 ms</span><br><span class="line">64 bytes from 172.18.11.114: icmp_seq=3 ttl=64 time=0.207 ms</span><br><span class="line">64 bytes from 172.18.11.114: icmp_seq=4 ttl=64 time=0.200 ms</span><br><span class="line">^C</span><br><span class="line">--- 172.18.11.114 ping statistics ---</span><br><span class="line">4 packets transmitted, 4 received, 0% packet loss, time 2999ms</span><br><span class="line">rtt min/avg/max/mdev = 0.193/0.204/0.216/0.008 ms</span><br></pre></td></tr></table></figure>
<p>ifconfig信息为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hw076:~ # ifconfig </span><br><span class="line">eth0      Link encap:Ethernet  HWaddr 90:E2:BA:15:C9:C4  </span><br><span class="line">          inet addr:172.18.11.76  Bcast:192.168.1.255  Mask:255.255.0.0</span><br><span class="line">          inet6 addr: fe80::92e2:baff:fe15:c9c4/64 Scope:Link</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:9725797 errors:0 dropped:506 overruns:0 frame:0</span><br><span class="line">          TX packets:21023 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1000 </span><br><span class="line">          RX bytes:598731249 (570.9 Mb)  TX bytes:2767270 (2.6 Mb)</span><br><span class="line">          Memory:fb480000-fb500000 </span><br><span class="line"></span><br><span class="line">lo        Link encap:Local Loopback  </span><br><span class="line">          inet addr:127.0.0.1  Mask:255.0.0.0</span><br><span class="line">          inet6 addr: ::1/128 Scope:Host</span><br><span class="line">          UP LOOPBACK RUNNING  MTU:65536  Metric:1</span><br><span class="line">          RX packets:276 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:276 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:0 </span><br><span class="line">          RX bytes:25088 (24.5 Kb)  TX bytes:25088 (24.5 Kb)</span><br></pre></td></tr></table></figure>
<p>route显示路由信息如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hw076:/etc/netconfig.d # route</span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">default         *               0.0.0.0         UG    0      0        0 eth0</span><br><span class="line">loopback        *               255.0.0.0       U     0      0        0 lo</span><br><span class="line">link-local      *               255.255.0.0     U     0      0        0 eth0</span><br><span class="line">172.18.0.0      *               255.255.0.0     U     0      0        0 eth0</span><br></pre></td></tr></table></figure>
<p>原因是route没有配置网关，gateway是空着的。</p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>通过查看其他可以正常访问的节点的路由信息，得知网关节点为：172.18.0.254。因此增加默认网关节点配置。</p>
<p>执行命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">route add default  gw 172.18.0.254</span><br></pre></td></tr></table></figure>
<p>再次查看路由信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hw076:~ # route</span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">default         172.18.0.254    0.0.0.0         UG    0      0        0 eth0</span><br><span class="line">loopback        *               255.0.0.0       U     0      0        0 lo</span><br><span class="line">link-local      *               255.255.0.0     U     0      0        0 eth0</span><br><span class="line">172.18.0.0      *               255.255.0.0     U     0      0        0 eth0</span><br></pre></td></tr></table></figure>
<p>再次ping8.8.8.8显示正常，问题解决。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>运维</tag>
        <tag>网络问题</tag>
      </tags>
  </entry>
  <entry>
    <title>shell 脚本遍历redis数据库</title>
    <url>/%E4%BD%BF%E7%94%A8shell%E8%84%9A%E6%9C%AC%E9%81%8D%E5%8E%86redis%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89kv%E5%AF%B9.html</url>
    <content><![CDATA[<h2 id="使用shell脚本遍历redis数据库中的所有kv对"><a href="#使用shell脚本遍历redis数据库中的所有kv对" class="headerlink" title="使用shell脚本遍历redis数据库中的所有kv对"></a>使用shell脚本遍历redis数据库中的所有kv对</h2><p>记录下如何使用shell通过redis-cli 命令来操作redis数据库，因为直接在命令行中输入</p>
<p><code>redis-cli command</code> 的话command必须是单个单词，不能像是<code>KEYS *</code> 这种.</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">filename=&apos;redis&apos;`date +%Y-%m-%d_%H:%M`</span><br><span class="line">work_path=$(dirname &quot;$0&quot;) </span><br><span class="line">echo &quot;实例化redis数据文件为:$work_path/$filename&quot;</span><br><span class="line">echo &quot;keys *&quot; | redis-cli &gt; key_db.txt</span><br><span class="line">echo &quot;将所有key保存到:$work_path/key_db.txt&quot;</span><br><span class="line">for line in `cat key_db.txt`</span><br><span class="line">do</span><br><span class="line">        echo &quot;key:$line &quot; &gt;&gt;$work_path/$filename.txt</span><br><span class="line">        echo &quot;key-value:&quot; &gt;&gt;$work_path/$filename.txt</span><br><span class="line">        echo &quot;hgetall $line&quot; | redis-cli &gt;&gt;$work_path/$filename.txt</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>使用echo 来把命令输出到管道然后再传递给redis-cli。在循环里面也是使用echo来把字符串输入到文件中。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>使用YCSB 评测redis性能</title>
    <url>/%E4%BD%BF%E7%94%A8YCSB%20%E8%AF%84%E6%B5%8Bredis%E6%80%A7%E8%83%BD.html</url>
    <content><![CDATA[<h1 id="使用YCSB-评测redis性能"><a href="#使用YCSB-评测redis性能" class="headerlink" title="使用YCSB 评测redis性能"></a>使用YCSB 评测redis性能</h1><p>YCSB是雅虎推出的可以评测许多主流数据库性能的基准测试，其中包括Redis。</p>
<a id="more"></a>
<h2 id="安装YCSB"><a href="#安装YCSB" class="headerlink" title="安装YCSB"></a>安装YCSB</h2><ol>
<li><p>安装java和maven</p>
<ol>
<li><p>机子已经有了java，所以只用安装maven Ubuntu安装命令为：</p>
<p><code>sudo apt-get install maven</code></p>
</li>
</ol>
</li>
<li><p>安装YCSB </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone http://github.com/brianfrankcooper/YCSB.git</span><br><span class="line">cd YCSB</span><br><span class="line">mvn -pl com.yahoo.ycsb:redis-binding -am clean package</span><br></pre></td></tr></table></figure>
<p>必须是gitclone的源码包才能执行mvn 命令。wget或者curl下来包是已经编译好了的无需执行mvn命令。</p>
</li>
<li><p><code>mvn -pl com.yahoo.ycsb:redis-binding -am clean package</code> 报错：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[INFO] Scanning for projects...</span><br><span class="line">[ERROR] [ERROR] Could not find the selected project in the reactor: com.yahoo.ycsb:redis-binding @ </span><br><span class="line">[ERROR] Could not find the selected project in the reactor: com.yahoo.ycsb:redis-binding -&gt; [Help 1]</span><br><span class="line">[ERROR] </span><br><span class="line">[ERROR] To see the full stack trace of the errors, re-run Maven with the -e switch.</span><br><span class="line">[ERROR] Re-run Maven using the -X switch to enable full debug logging.</span><br><span class="line">[ERROR] </span><br><span class="line">[ERROR] For more information about the errors and possible solutions, please read the following articles:</span><br><span class="line">[ERROR] [Help 1] http://cwiki.apache.org/confluence/display/MAVEN/MavenExecutionException</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>原因：此命令是在gitclone后未编译的时候使用的。而我之前是下载的编译好的tar.gz包，解压后是已经编译好了的。所以再次执行编译的命令时会报错。</p>
<h2 id="使用YCSB"><a href="#使用YCSB" class="headerlink" title="使用YCSB"></a>使用YCSB</h2><p>将redis-server启动后开始使用YCSB</p>
<h3 id="设置数据库"><a href="#设置数据库" class="headerlink" title="设置数据库"></a>设置数据库</h3><p>需要先创建<code>usertable</code>的表，因为YCSB客户端默认是对<code>usertable</code> 进行操作。Redis将数据存储在内存中，不需要相关操作。</p>
<h3 id="选择合适的DB-interface"><a href="#选择合适的DB-interface" class="headerlink" title="选择合适的DB interface"></a>选择合适的DB interface</h3><p>YCSB的操作是通过DB interface来实现的。最基本的DB interface是<code>com.yahoo.ycsb.BasicDB</code>，会将输出输出到<code>System.out</code>里。可以通过继承DB interface来自定义DB interface，也可以使用原有的DB interface。Redis不需要此步操作。</p>
<h3 id="选择合适的负载"><a href="#选择合适的负载" class="headerlink" title="选择合适的负载"></a>选择合适的负载</h3><p>YCSB提供了6种负载，负载在worloads目录下。详情见<a href="https://github.com/brianfrankcooper/YCSB/wiki/Core-Workloads" target="_blank" rel="noopener">https://github.com/brianfrankcooper/YCSB/wiki/Core-Workloads</a></p>
<ol>
<li><strong>Workload A: Update heavy workload</strong> 读写比例为： 50/50 混合负载 </li>
<li><strong>Workload A: Update heavy workload</strong> 读写比例为：95/5  读为主的负载</li>
<li><strong>Workload C: Read only</strong>  100% 的读  只读负载</li>
<li><strong>Workload D: Read latest workload</strong>  读取最近的数据负载</li>
<li><strong>Workload E: Short ranges</strong>  小范围的查询负载</li>
<li><strong>Workload F: Read-modify-write</strong> 读修改写负载</li>
</ol>
<p>自定义负载：参考<a href="https://github.com/brianfrankcooper/YCSB/wiki/Implementing-New-Workloads" target="_blank" rel="noopener">https://github.com/brianfrankcooper/YCSB/wiki/Implementing-New-Workloads</a></p>
<p>可以通过修改参数文件或者新建java类来实现</p>
<p>需要注意的是YCSB的读写负载是针对哈希类型的数据而不是简单的字符串</p>
<h3 id="指定需要的运行参数"><a href="#指定需要的运行参数" class="headerlink" title="指定需要的运行参数"></a>指定需要的运行参数</h3><p>主要是指定redis的ip ，端口，密码等。</p>
<p>命令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./bin/ycsb load redis -s -P workloads/workloada -p &quot;redis.host=127.0.0.1&quot; -p &quot;redis.port=6379&quot; &gt; outputLoad.txt</span><br></pre></td></tr></table></figure>
<p><code>-s</code> : <strong>status</strong>.十秒打印一次状态</p>
<h3 id="加载负载"><a href="#加载负载" class="headerlink" title="加载负载"></a>加载负载</h3><p>命令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./bin/ycsb load redis -s -P workloads/workloada &gt; outputLoad.txt</span><br></pre></td></tr></table></figure>
<h3 id="运行负载"><a href="#运行负载" class="headerlink" title="运行负载"></a>运行负载</h3><p>命令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./bin/ycsb run redis -s -P workloads/workloada &gt; outputRun.txt</span><br></pre></td></tr></table></figure>
<p>可以使用basic数据库来打印YCSB向数据库中写入的具体数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin/ycsb.sh load basic -P workloads/workloada</span><br><span class="line">bin/ycsb.sh run basic -P workloads/workloada</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://datawine.github.io/2018/12/11/YCSB%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/" target="_blank" rel="noopener">https://datawine.github.io/2018/12/11/YCSB%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/</a></p>
<p><a href="https://github.com/brianfrankcooper/YCSB/tree/master/redis" target="_blank" rel="noopener">https://github.com/brianfrankcooper/YCSB/tree/master/redis</a>  </p>
]]></content>
      <tags>
        <tag>redis</tag>
        <tag>benchmark</tag>
      </tags>
  </entry>
  <entry>
    <title>apt-get install失败</title>
    <url>/apt-get%20install%20%E5%A4%B1%E8%B4%A5.html</url>
    <content><![CDATA[<h2 id="apt-get-install失败"><a href="#apt-get-install失败" class="headerlink" title="apt-get install失败"></a>apt-get install失败</h2><a id="more"></a>
<h3 id="第一阶段"><a href="#第一阶段" class="headerlink" title="第一阶段"></a>第一阶段</h3><ol>
<li><p>使用perf 报错 内核无法找到perf</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@hw103:/home/yky/redis-5.0.3# perf </span><br><span class="line">WARNING: perf not found for kernel 4.15.0-45</span><br><span class="line"></span><br><span class="line">  You may need to install the following packages for this specific kernel:</span><br><span class="line">    linux-tools-4.15.0-45-generic</span><br><span class="line">    linux-cloud-tools-4.15.0-45-generic</span><br><span class="line"></span><br><span class="line">  You may also want to install one of the following packages to keep up to date:</span><br><span class="line">    linux-tools-generic</span><br><span class="line">    linux-cloud-tools-generic</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>安装此内核的通用工具时错误</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@hw103:/home/yky/redis-5.0.3# apt-get install  linux-tools-4.15.0-45-generic</span><br><span class="line">Reading package lists... Done</span><br><span class="line">Building dependency tree       </span><br><span class="line">Reading state information... Done</span><br><span class="line">You might want to run &apos;apt-get -f install&apos; to correct these:</span><br><span class="line">The following packages have unmet dependencies:</span><br><span class="line"> console-setup : Depends: keyboard-configuration (= 1.178ubuntu2.7) but 1.108ubuntu15.3 is to be installed</span><br><span class="line"> console-setup-linux : Depends: keyboard-configuration (= 1.178ubuntu2.7) but 1.108ubuntu15.3 is to be installed</span><br><span class="line">                       Breaks: keyboard-configuration (&lt; 1.138) but 1.108ubuntu15.3 is to be installed</span><br><span class="line"> linux-tools-4.15.0-45-generic : Depends: linux-tools-4.15.0-45 but it is not going to be installed</span><br><span class="line">E: Unmet dependencies. Try &apos;apt-get -f install&apos; with no packages (or specify a solution).</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用apt-get -f install 时报错</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">update-rc.d: error: insserv rejected the script header</span><br><span class="line">dpkg: error processing archive /var/cache/apt/archives/keyboard-configuration_1.178ubuntu2.7_all.deb (--unpack):</span><br><span class="line"> subprocess new pre-installation script returned error exit status 1</span><br><span class="line">dpkg-query: warning: files list file for package &apos;keyboard-configuration&apos; missing; assuming package has no files currently installed</span><br><span class="line">dpkg-query: warning: files list file for package &apos;keyboard-configuration&apos; missing; assuming package has no files currently installed</span><br><span class="line">dpkg-query: warning: files list file for package &apos;keyboard-configuration&apos; missing; assuming package has no files currently installed</span><br><span class="line">Errors were encountered while processing:</span><br><span class="line"> /var/cache/apt/archives/keyboard-configuration_1.178ubuntu2.7_all.deb</span><br><span class="line">E: Sub-process /usr/bin/dpkg returned an error code (1)</span><br></pre></td></tr></table></figure>
<p>问题综述：</p>
<ol>
<li><code>apt-get install lib</code>时报错 Unmet dependencies</li>
<li><code>apt-get install -f</code> 时报错Sub-process /usr/bin/dpkg returned an error code (1)</li>
</ol>
</li>
</ol>
<ol>
<li><p>第一阶段解决办法</p>
<p>在/var/lib/dpkg/目录下有个info文件 ，然后文件中没有keyboard-configuration的相关文件但是有info的备份info_backup  ，这里面有相关的文件，于是将keyboard-configuration的所有相关文件都拷贝到了/var/lib/dpkg/info 中。</p>
<p>在info_backup目录下执行如下命令拷贝</p>
<p><code>cp keyboard-configuration.* ../info</code></p>
<p>随后再次执行安装内核通用工具 报错为第二阶段</p>
</li>
</ol>
<h3 id="第二阶段"><a href="#第二阶段" class="headerlink" title="第二阶段"></a>第二阶段</h3><ol>
<li><p>安装此内核的通用工具时时报错：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">insserv: Starting redis depends on plymouth and therefore on system facility `$all&apos; which can not be true!</span><br><span class="line">insserv: exiting now without changing boot order!</span><br><span class="line">update-rc.d: error: insserv rejected the script header</span><br><span class="line">dpkg: error processing package avahi-daemon (--configure):</span><br><span class="line"> subprocess installed post-installation script returned error exit status 1</span><br><span class="line">No apport report written because MaxReports is reached already</span><br><span class="line">                                                              No apport report written because MaxReports is reached already</span><br><span class="line">                                                                                                                            dpkg: dependency problems prevent configuration o</span><br><span class="line">f avahi-utils: avahi-utils depends on avahi-daemon; however:</span><br><span class="line">  Package avahi-daemon is not configured yet.</span><br><span class="line"></span><br><span class="line">dpkg: error processing package avahi-utils (--configure):</span><br><span class="line"> dependency problems - leaving unconfigured</span><br><span class="line">Setting up unattended-upgrades (1.1ubuntu1.18.04.9) ...</span><br><span class="line">dpkg: error processing package unattended-upgrades (--configure):</span><br><span class="line"> subprocess installed post-installation script returned error exit status 10</span><br><span class="line">No apport report written because MaxReports is reached already</span><br><span class="line">                                                              Setting up linux-tools-4.15.0-45 (4.15.0-45.48) ...</span><br><span class="line">Setting up linux-tools-4.15.0-45-generic (4.15.0-45.48) ...</span><br><span class="line">Processing triggers for initramfs-tools (0.122ubuntu8.14) ...</span><br><span class="line">Errors were encountered while processing:</span><br><span class="line"> udev</span><br><span class="line"> snapd</span><br><span class="line"> ubuntu-core-launcher</span><br><span class="line"> kmod</span><br><span class="line"> ubuntu-drivers-common</span><br><span class="line"> whoopsie</span><br><span class="line"> openssh-server</span><br><span class="line"> ssh</span><br><span class="line"> avahi-daemon</span><br><span class="line"> avahi-utils</span><br><span class="line"> unattended-upgrades</span><br><span class="line">E: Sub-process /usr/bin/dpkg returned an error code (1)</span><br></pre></td></tr></table></figure>
</li>
<li><p>解决办法：/var/lib/dpkg/info 目录下将上述出现问题的模块的postinst文件重命名。</p>
<p>在/var/lib/dpkg/info 下写了个脚本</p>
<p>solution.sh</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">for pack in $(cat module.txt)</span><br><span class="line">do </span><br><span class="line">    mv &quot;$pack&quot;.postinst &quot;$pack&quot;.postinst.bak</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>其中module.txt的内容为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">udev</span><br><span class="line">snapd</span><br><span class="line">ubuntu-core-launcher</span><br><span class="line">kmod</span><br><span class="line">ubuntu-drivers-common</span><br><span class="line">whoopsie</span><br><span class="line">openssh-server</span><br><span class="line">ssh</span><br><span class="line">avahi-daemon</span><br><span class="line">avahi-utils</span><br><span class="line">unattended-upgrades</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行脚本后 使用<code>sudo apt-get upgrade</code> 进行更新</p>
</li>
<li><p>参考：</p>
<ol>
<li><a href="https://www.codelast.com/%E5%8E%9F%E5%88%9B-%E8%A7%A3%E5%86%B3ubuntu-%E6%97%A0%E6%B3%95%E7%94%A8-apt-get-install-%E5%AE%89%E8%A3%85%E4%BB%BB%E4%BD%95%E8%BD%AF%E4%BB%B6dpkg-error-processing-package-xxx%E7%9A%84%E9%97%AE/" target="_blank" rel="noopener">https://www.codelast.com/%E5%8E%9F%E5%88%9B-%E8%A7%A3%E5%86%B3ubuntu-%E6%97%A0%E6%B3%95%E7%94%A8-apt-get-install-%E5%AE%89%E8%A3%85%E4%BB%BB%E4%BD%95%E8%BD%AF%E4%BB%B6dpkg-error-processing-package-xxx%E7%9A%84%E9%97%AE/</a></li>
<li><a href="https://askubuntu.com/questions/949760/dpkg-warning-files-list-file-for-package-missing" target="_blank" rel="noopener">https://askubuntu.com/questions/949760/dpkg-warning-files-list-file-for-package-missing</a></li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title>Make学习</title>
    <url>/make%E5%AD%A6%E4%B9%A0.html</url>
    <content><![CDATA[<h1 id="make学习"><a href="#make学习" class="headerlink" title="make学习"></a>make学习</h1><p>开始阅读redis源码，都说redis很简单，源码不多。但是源码包下载下来后却发现不知道从何处入手，有那么多文件和源码。后面查找资料才发现阅读源码的第一步就是阅读Makefile，项目如何构建和源码间的关联都写在了Makefile文件中。之前没有接触过Makefile，记录下Make的学习。</p>
<a id="more"></a>
<h2 id="makefile的格式"><a href="#makefile的格式" class="headerlink" title="makefile的格式"></a>makefile的格式</h2><ol>
<li><p>概述</p>
<p>makefile 文件由一系列rules组成 rules的格式为：</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;target&gt; : &lt;prerequisites&gt; </span><br><span class="line">[tab]  &lt;commands&gt;</span><br></pre></td></tr></table></figure>
<p>​    “目标”是必需的，不可省略；”前置条件”和”命令”都是可选的，但是两者之中必须至少存在一个。 </p>
<p>​    每条规则就明确两件事：构建目标的前置条件是什么，以及如何构建。 </p>
<ol>
<li><p>target</p>
<p>一个目标（target）就构成一条规则。目标通常是文件名，指明Make命令所要构建的对象，比如上文的 a.txt 目标可以是一个文件名，也可以是多个文件名，之间用空格分隔。（make的时候指定文件名从而对该文件进行构建build）</p>
<p>除了文件名，目标还可以是某个操作的名字，这称为”伪目标”（phony target）。伪目标不生成文件，只执行命令。</p>
<p>比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">clean:</span><br><span class="line">      rm *.o</span><br></pre></td></tr></table></figure>
<p>此时执行<code>make clean</code> 命令则会进行<code>rm *.o</code> 的操作。</p>
<p>但是当存在clean这个文件时，那么这个命令不会执行。因为Make发现clean文件已经存在，就认为没有必要重新构建了，就不会执行指定的rm命令。</p>
<p>为了避免这种情况，可以明确声明clean是”伪目标”，写法如下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.PHONY: clean</span><br><span class="line">clean:</span><br><span class="line">        rm *.o temp</span><br></pre></td></tr></table></figure>
<p>如果Make命令运行时没有指定目标，默认会执行Makefile文件的第一个目标。 </p>
</li>
<li><p>prerequisites</p>
<p>前置条件通常是一组文件名，之间用空格分隔。它指定了”目标”是否重新构建的判断标准：只要有一个前置文件不存在，或者有过更新（前置文件的last-modification时间戳比目标的时间戳新），”目标”就需要重新构建。 </p>
<p>没有前置条件，就意味着它跟其他文件都无关，只要这个target文件还不存在 就需要执行命令构建</p>
<p>如果需要生成多个文件，往往采用下面的写法。 </p>
<p><code>source: file1 file2 file3</code>  </p>
<p>无需加上命令，当三个文件不存在时，执行<code>make source</code>就会生成这三个文件。</p>
</li>
<li><p>commands</p>
<p>命令（commands）表示如何更新目标文件，由一行或多行的Shell命令组成。它是构建”目标”的具体指令，它的运行结果通常就是生成目标文件。 </p>
<p>每行命令之前必须有一个tab键 </p>
<p>需要注意的是，每行命令在一个单独的shell中执行。这些Shell之间没有继承关系。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var-lost:</span><br><span class="line">    export foo=bar</span><br><span class="line">    echo &quot;foo=[$$foo]&quot;</span><br></pre></td></tr></table></figure>
<p>上面代码执行后（<code>make var-lost</code>），取不到foo的值。因为两行命令在两个不同的进程执行。 </p>
<p>解决办法：</p>
<ol>
<li><p>命令写在同1行</p>
</li>
<li><p>换行符前加反斜杠转义</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var-kept:</span><br><span class="line">    export foo=bar; \</span><br><span class="line">    echo &quot;foo=[$$foo]&quot;</span><br></pre></td></tr></table></figure>
<ol>
<li>加上<code>.ONESHELL:</code>命令 </li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.ONESHELL:</span><br><span class="line">var-kept:</span><br><span class="line">    export foo=bar; </span><br><span class="line">    echo &quot;foo=[$$foo]&quot;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
<h2 id="makefile的语法"><a href="#makefile的语法" class="headerlink" title="makefile的语法"></a>makefile的语法</h2><ol>
<li><p>注释</p>
<p>井号（#）在Makefile中表示注释。 </p>
</li>
<li><p>回声（echoing）</p>
<p>正常情况下，make会打印每条命令，然后再执行，这就叫做回声（echoing）。</p>
<p>在命令的前面加上@，就可以关闭回声。 </p>
<p>由于在构建过程中，需要了解当前在执行哪条命令，所以通常只在注释和纯显示的echo命令前面加上@。 </p>
</li>
<li><p>通配符</p>
<p>由于在构建过程中，需要了解当前在执行哪条命令，所以通常只在注释和纯显示的echo命令前面加上@。 </p>
</li>
<li><p>模式匹配</p>
<p>Make命令允许对文件名，进行类似正则运算的匹配，主要用到的匹配符是%。比如，假定当前目录下有 f1.c 和 f2.c 两个源码文件，需要将它们编译为对应的对象文件。 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%.o: %.c</span><br></pre></td></tr></table></figure>
<p>等同于</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">f1.o: f1.c</span><br><span class="line">f2.o: f2.c</span><br></pre></td></tr></table></figure>
<p>使用匹配符%，可以将大量同类型的文件，只用一条规则就完成构建。 </p>
</li>
<li><p>变量和赋值符</p>
<p>Makefile 允许使用等号自定义变量。 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">txt = Hello World</span><br><span class="line">test:</span><br><span class="line">    @echo $(txt)</span><br></pre></td></tr></table></figure>
<p>上面代码中，变量 txt 等于 Hello World。调用时，变量需要放在 $( ) 之中 </p>
<p>调用Shell变量，需要在美元符号前，再加一个美元符号，这是因为Make命令会对美元符号转义。 </p>
</li>
<li><p>内置变量</p>
<p>Make命令提供一系列内置变量，比如，$(CC) 指向当前使用的编译器，$(MAKE) 指向当前使用的Make工具。这主要是为了跨平台的兼容性 gmake、cmake、dmake等等。</p>
<p>$(AR) ：函数库打包程序,将对应的gcc编译出来的obj文件打包成静态链接库程序。</p>
<p>ar可以集合许多文件，成为单一的备存文件。在备存文件中，所有成员文件皆保有原来的属性与权限。</p>
</li>
<li><p>自动变量</p>
<ol>
<li><p>$@指代当前目标，就是Make命令当前构建的那个目标  target</p>
</li>
<li><p>$&lt;指代第一个前置条件。比如，规则为 t: p1 p2，那么$&lt; 就指代p1 </p>
</li>
<li><p>$？指代比目标更新的所有前置条件，之间以空格分隔。比如，规则为 t: p1 p2，其中 p2 的时间戳比 t 新，$?就指代p2。 </p>
</li>
<li><p>$^指代所有前置条件，之间以空格分隔。比如，规则为 t: p1 p2，那么 $^ 就指代 p1 p2 。 </p>
</li>
<li><p>$<em>指代匹配符 % 匹配的部分， 比如% 匹配 f1.txt 中的f1 ，$</em> 就表示 f1。 </p>
</li>
<li><p>$(@D) 和 $(@F)$(@D) 和 $(@F) 分别指向 $@ 的目录名和文件名。比如，$@是 src/input.c，那么$(@D) 的值为 src ，$(@F) 的值为 input.c。 </p>
</li>
<li><p>$(&lt;D) 和 $(&lt;F)</p>
<p>$(&lt;D) 和 $(&lt;F) 分别指向 $&lt; 的目录名和文件名。</p>
</li>
</ol>
</li>
<li><p>其他</p>
<ol>
<li><p><code>.DEFAULT：</code>表示找不到匹配规则时，就执行该recipe。  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">default:all</span><br><span class="line">.DEFAULT:</span><br><span class="line">	commands</span><br></pre></td></tr></table></figure>
<p>这里当执行<code>make default</code> 时会转到<code>make all</code> 因为default：all 这个target没有隐式规则。所以最后会执行commands。</p>
</li>
<li><p>忽略命令的出错，可以在Makefile的命令行前加一个减号”-“(在Tab键之后)，标记为不管命令出不出错都认为是成功的。如：     </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">clean:        </span><br><span class="line">	-(rm -f *.o )</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>include filename</code> 将filename中的内容导入，如果找不到会停止make， <code>-include filename</code> 则不会停止make。 </p>
</li>
</ol>
</li>
</ol>
<h2 id="几种等号"><a href="#几种等号" class="headerlink" title="几种等号"></a>几种等号</h2><p>= 是最基本的赋值<br>:= 是覆盖之前的值<br>?= 是如果没有被赋值过就赋予等号后面的值<br>+= 是添加等号后面的值</p>
<p>=与:= 的区别</p>
<p> =：make会将整个makefile展开后，再决定变量的值。也就是说，变量的值将会是整个makefile中最后被指定的值。例子为：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">x = foo</span><br><span class="line">y = <span class="variable">$(x)</span> bar</span><br><span class="line">x = xyz</span><br></pre></td></tr></table></figure>
<p>y的值将会是 xyz bar ，而不是 foo bar 。因为展开后最终变成的是xyz</p>
<p>:=表示变量的值决定于它在makefile中的位置，而不是整个makefile展开后的最终值。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">x := foo</span><br><span class="line">y := <span class="variable">$(x)</span> bar</span><br><span class="line">x := xyz</span><br></pre></td></tr></table></figure>
<p>y的值将会是 foo bar ，而不是 xyz bar 了。</p>
<h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><ol>
<li><a href="http://www.ruanyifeng.com/blog/2015/02/make.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2015/02/make.html</a></li>
<li><a href="https://gist.github.com/isaacs/62a2d1825d04437c6f08" target="_blank" rel="noopener">https://gist.github.com/isaacs/62a2d1825d04437c6f08</a> makefile文件教程</li>
<li><a href="https://www.gnu.org/software/make/manual/make.html" target="_blank" rel="noopener">https://www.gnu.org/software/make/manual/make.html</a> GNUmake手册</li>
<li><a href="https://blog.csdn.net/shouso888/article/details/7226030" target="_blank" rel="noopener">https://blog.csdn.net/shouso888/article/details/7226030</a> 等号解释</li>
</ol>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>make</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux命令学习之wc</title>
    <url>/Linux%20%E5%91%BD%E4%BB%A4%20%E5%AD%A6%E4%B9%A0.html</url>
    <content><![CDATA[<h1 id="Linux-命令学习wc命令"><a href="#Linux-命令学习wc命令" class="headerlink" title="Linux 命令学习wc命令"></a>Linux 命令学习wc命令</h1><h2 id="wc命令"><a href="#wc命令" class="headerlink" title="wc命令"></a><code>wc</code>命令</h2><a id="more"></a>
<ol>
<li>作用：Word Count 功能为统计指定文件中的字节数、字数、行数，并将统计结果显示输出。 </li>
<li>格式：<ul>
<li><code>wc [option] filepath</code></li>
</ul>
</li>
<li>参数<ul>
<li><code>-c</code> 统计字节数</li>
<li><code>-l</code> 统计行数</li>
<li><code>-m</code> 统计字符数 标志不能与 -c 标志一起使用。 </li>
<li><code>-w</code> 统计字（单词word）数。一个字被定义为由空白、跳格或换行字符分隔的字符串 </li>
<li><code>-L</code>  打印最长行的长度。 </li>
<li><code>-help</code> 显示帮助信息 </li>
<li><code>--version</code> 显示版本信息 </li>
</ul>
</li>
<li>参考网址：<a href="http://www.cnblogs.com/peida/archive/2012/12/18/2822758.html" target="_blank" rel="noopener">http://www.cnblogs.com/peida/archive/2012/12/18/2822758.html</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>command</tag>
      </tags>
  </entry>
  <entry>
    <title>tee命令解析</title>
    <url>/tee%E5%91%BD%E4%BB%A4%E8%A7%A3%E6%9E%90.html</url>
    <content><![CDATA[<h1 id="make-2-gt-amp-1-tee-log-txt-命令解析"><a href="#make-2-gt-amp-1-tee-log-txt-命令解析" class="headerlink" title="make 2&gt;&amp;1 | tee log.txt 命令解析"></a>make 2&gt;&amp;1 | tee log.txt 命令解析</h1><p>在安装mpich 的时候遇到了很多这个命令，此处学习下这个命令：<code>2&gt;&amp;1 | tee log.txt</code> </p>
<a id="more"></a>
<p>这个命令共有三个部分： <code>2&gt;&amp;1</code> <code>|</code>  <code>tee log.txt</code></p>
<h2 id="2-gt-amp-1"><a href="#2-gt-amp-1" class="headerlink" title="2&gt;&amp;1"></a>2&gt;&amp;1</h2><p>shell中：最常使用的 FD (file descriptor) 大概有三个 </p>
<p>0表示标准输入Standard Input (STDIN)  </p>
<p>1表示标准输出Standard Output (STDOUT)  </p>
<p> 2表示标准错误输出 Standard Error Output (STDERR)  </p>
<p>‘&gt;’ 默认为标准输出重定向 （类似于c++ 中的 &gt;&gt;？）</p>
<p>在标准情况下, 这些FD分别跟如下设备关联 </p>
<p>stdin(0): keyboard  键盘输入,并返回在前端   </p>
<p>stdout(1): monitor  正确返回值 输出到前端   </p>
<p>stderr(2): monitor 错误返回值 输出到前端  </p>
<p>1&gt;&amp;2  正确返回值传递给2输出通道 &amp;2表示2输出通道   如果此处错写成 1&gt;2, 就表示把1输出重定向到文件2中  2&gt;&amp;1 错误返回值传递给1输出通道, 同样&amp;1表示1输出通道.  </p>
<h2 id="管道"><a href="#管道" class="headerlink" title="|管道"></a>|管道</h2><p>管道的作用是提供一个通道，将上一个程序的标准输出重定向到下一个程序作为下一个程序的标准输入。 </p>
<h2 id="tee-log-txt"><a href="#tee-log-txt" class="headerlink" title="tee log.txt"></a>tee log.txt</h2><p>tee从标准输入中读取，并将读入的内容写到标准输出以及文件中。  此处将数据读入并写入到log.txt中</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这个命令将标准错误输出重定向到标准输出，然后再将标准输出重定向到log.txt文件中</p>
<p>常用于make 后面将log信息保存下来。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>command</tag>
      </tags>
  </entry>
  <entry>
    <title>BigdataBench deploy</title>
    <url>/BigdataBench-deploy.html</url>
    <content><![CDATA[<h1 id="Bigdatabench-4-0-MPI版本-安装"><a href="#Bigdatabench-4-0-MPI版本-安装" class="headerlink" title="Bigdatabench 4.0 MPI版本 安装"></a>Bigdatabench 4.0 MPI版本 安装</h1><a id="more"></a>
<p>官网上面的指南BigDataBench User Manual有一些错误。</p>
<p>本机环境：</p>
<p>​    Centos 6.9</p>
<p>​    gcc (GCC) 4.8.2 20140120 (Red Hat 4.8.2-15)</p>
<p>​    g++ (GCC) 4.8.2 20140120 (Red Hat 4.8.2-15)</p>
<h2 id="mpi的安装"><a href="#mpi的安装" class="headerlink" title="mpi的安装"></a>mpi的安装</h2><p>这部分网上资料很多，而Manual中有一点错误</p>
<ol>
<li><p>需要保证c 编译器 如gcc c++ 编译器 如：g++</p>
</li>
<li><p>基础安装</p>
<ol>
<li>从官网下载安装包解压</li>
</ol>
<ul>
<li><code>wget http://www.mpich.org/static/downloads/3.2.1/mpich-3.2.1.tar.gz</code>  从官网下载安装包</li>
<li><code>tar -zxvf mpich-3.2.1.tar.gz</code>  解压</li>
<li><code>cd mpich-3.2.1</code></li>
</ul>
<ol>
<li>配置安装目录   本机安装在mpich-install目录下</li>
</ol>
<ul>
<li><code>./configure –prefix=/home/mpich-install 2&gt;&amp;1 | tee c.txt</code> 手册中&amp;被错写为$了 <code>2&gt;&amp;1 | tee c.txt</code> 表示将输出的标准出错信息重定向到c.txt中。</li>
</ul>
<ol>
<li>build</li>
</ol>
<ul>
<li><code>make 2&gt;&amp;1 | tee m.txt</code></li>
</ul>
<ol>
<li>安装</li>
</ol>
<ul>
<li><code>make install 2&gt;&amp;1 | tee mi.txt</code></li>
</ul>
<ol>
<li>将安装目录添加到PATH 环境变量中</li>
</ol>
<ul>
<li><code>vim ~/.bashrc</code></li>
<li><code>export PATH=$PATH:/home/mpich-install/bin</code> 在最后一行添加</li>
<li><code>source ~/.bashrc</code> 重启生效</li>
</ul>
</li>
<li><p>检查</p>
<ol>
<li>检查路径<ul>
<li><code>which mpicc</code> </li>
<li><code>which mpic++</code></li>
</ul>
</li>
</ol>
</li>
<li><p>验证 </p>
<p>在mpich的安装包目录下有提供例子程序运行</p>
<ol>
<li><code>cd mpich-3.2.1/examples</code></li>
<li><code>mpicc cpi.c -o cpi</code> 编译cpi.c程序求pi值</li>
<li><code>mpirun -n 4 ./cpi</code> 使用4个进程 注意<code>./</code>否则报错找不到文件</li>
</ol>
<p>如果是集群环境在每个节点将mpich安装在相同的路径然后编辑一个machine_file （里面是各个节点的host）然后<code>mpirun -f machine_file -n 3 ./cpi</code> 在集群上并行运行</p>
</li>
</ol>
<h2 id="boost-安装"><a href="#boost-安装" class="headerlink" title="boost 安装"></a>boost 安装</h2><p>boost当前最新版本是：1.67 但是BigdataBench用的是1.43版本推荐安装这个旧版本</p>
<ol>
<li><p><code>wget https://sourceforge.net/projects/boost/files/boost/1.43.0/boost_1_43_0.tar.gz/download</code> </p>
</li>
<li><p>若下载下来的文件名为：downloads 则使用mv命令重命名在当前文件目录下:</p>
<p><code>mv downloads boost_1_43_0.tar.gz</code>  </p>
</li>
<li><p>解压<code>tar -zxvf boost_1_43_0.tar.gz</code>  之后<code>cd boost_1_43_0</code></p>
</li>
<li><p><code>sh bootstrap.sh</code>  执行这个命令运行脚本后会多出很多配置文件</p>
</li>
<li><p>使用mpi,这一步骤很重要否则后续cmake时会提示找不到：boost_mpi</p>
<ol>
<li><p>对低版本的boost </p>
<ol>
<li><p><code>which mpic++</code> 找mpich的目录</p>
</li>
<li><p><code>vim tools/build/v2/user-config.jam</code></p>
</li>
<li><p>在最后添加： using mpi:后面是mpich的目录</p>
<p><code>#MPI config</code></p>
<p><code>using mpi : /usr/lib64/mpich/bin/mpic++ ;</code></p>
</li>
</ol>
</li>
<li><p>对高版本的boost直接在boost_1_67_0目录下修改project-config.jam即可</p>
</li>
</ol>
</li>
<li><p><code>./bjam</code> 进行编译</p>
</li>
<li><p><code>./bjam install</code> 这一步是必需的但在手册中没有表明。</p>
</li>
</ol>
<h2 id="BigdataBench的配置"><a href="#BigdataBench的配置" class="headerlink" title="BigdataBench的配置"></a>BigdataBench的配置</h2><p>进入BigDataBench的安装根目录：</p>
<ol>
<li><code>vim conf.properties</code> 添加$JAVA_HOME， $MPI_HOME ，$BigdataBench_HOMEMPI的路径</li>
<li><code>sh prepar.sh</code> </li>
</ol>
<p>至此安装理论上已经成功。但仍然遇到了其他问题</p>
<h2 id="Perminsion-denied问题"><a href="#Perminsion-denied问题" class="headerlink" title="Perminsion denied问题"></a>Perminsion denied问题</h2><p>最开始的安装包是从windows下面考过去的结果生成cc的数据后无法运行执行脚本</p>
<p><img src="BigdataBench-deploy\runcc.png" alt=""></p>
<p>原因是此时的run_connectedComponents已经不是可执行文件了（不是绿色的）需要<code>chmod a+x run_connectedComponents</code>来将文件的权限修改为可执行文件权限（修改后变为绿色）</p>
<p>后面wget下载后解压配置之后直接就是可执行文件！</p>
<h2 id="ldd-程序-动态链接库缺失"><a href="#ldd-程序-动态链接库缺失" class="headerlink" title="ldd 程序 动态链接库缺失"></a>ldd 程序 动态链接库缺失</h2><p><code>[root@hw073 ConnectedComponent]# ldd run_connectedComponents</code><br><code>linux-vdso.so.1 =&gt;  (0x00007ffdfc8d4000)</code><br><code>librt.so.1 =&gt; /lib64/librt.so.1 (0x0000003156e00000)</code><br><code>libpthread.so.0 =&gt; /lib64/libpthread.so.0 (0x0000003156a00000)</code></p>
<p><code>libboost_serialization-mt.so.1.43.0 =&gt; not found</code><br><code>libboost_filesystem-mt.so.1.43.0 =&gt; not found</code><br><code>libboost_system-mt.so.1.43.0 =&gt; not found</code><br><code>libstdc++.so.6 =&gt; /usr/lib64/libstdc++.so.6 (0x0000003162200000)</code><br><code>libm.so.6 =&gt; /lib64/libm.so.6 (0x0000003157200000)</code><br><code>libgcc_s.so.1 =&gt; /lib64/libgcc_s.so.1 (0x0000003161a00000)</code><br><code>libc.so.6 =&gt; /lib64/libc.so.6 (0x0000003156600000)</code><br><code>/lib64/ld-linux-x86-64.so.2 (0x0000003155e00000)</code></p>
<p>最开始以为是没有指定LD_LIBRARY_PATH ，因为明明有这个文件的，后面使用find / -name 命令发现还是找不到，仔细一看ldd 的信息，发现上述文件都多了个-mt</p>
<p>解决办法： 在boost安装时的库。本机：<code>/usr/local/lib</code> 有着及其相似的3个文件<code>libboost_filesystem.so.1.43.0</code> 、<code>libboost_filesystem.so.1.43.0</code> ，<code>libboost_system.so.1.43.0</code> 均少了个-mt，因此将上述三个文件均拷贝一份命名为上述缺少的动态库文件。</p>
<p><code>cd /usr/local/lib</code> #切换到对应的目录下</p>
<p><code>cp libboost_system.so.1.43.0 libboost_system-mt.so.1.43.0</code> #拷贝为对应的文件名</p>
]]></content>
      <categories>
        <category>deploy</category>
      </categories>
      <tags>
        <tag>bigdatabench</tag>
      </tags>
  </entry>
  <entry>
    <title>图计算常用算法</title>
    <url>/%E5%9B%BE%E8%AE%A1%E7%AE%97%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95.html</url>
    <content><![CDATA[<h1 id="图算法的典型操作"><a href="#图算法的典型操作" class="headerlink" title="图算法的典型操作"></a>图算法的典型操作</h1><p>关于一些常见图算法的调研与学习。</p>
<a id="more"></a>
<h2 id="常用图算法"><a href="#常用图算法" class="headerlink" title="常用图算法"></a>常用图算法</h2><h3 id="PageRank"><a href="#PageRank" class="headerlink" title="PageRank"></a>PageRank</h3><ol>
<li><p>背景    </p>
<ol>
<li>既考虑入链数量，又考虑了网页质量因素，二者相结合 数量与权重的结合</li>
<li>算法与主题无关，因为PR值是根据图计算出来的</li>
</ol>
</li>
<li><p>算法原理</p>
<ol>
<li><p>基本思想</p>
<p>A有链接指向B，表明A认为B比A重要。A将自身权重分配一部分给B。</p>
<p>$W(B)=W(A)/N$   W(A) 是A的PR值，W(B)是A 分配的权重，N是A的出链数</p>
</li>
<li><p>PageRank公式修正</p>
<p>存在出链为0的孤立网页，增加阻力系数q ，一般取q=0.85，其意义是用户有1-q的概率不点击此页面上面的所有链接。同时还有随机直接跳转的概率，如直接输入网址，点击书签等。完整公式如下：</p>
<p><img src="E:\data\ict\docs\page rank.png" alt=""></p>
</li>
</ol>
</li>
</ol>
<h3 id="Connected-component"><a href="#Connected-component" class="headerlink" title="Connected component"></a>Connected component</h3><ol>
<li>定义<ol>
<li>连通分支：图中，某个子图的任意两点有边连接，而子图之间无边连接</li>
<li>问题：cc是寻找连通分支的算法？？</li>
</ol>
</li>
<li>通过BFS、DFS算法的便利就可以找到连通分支，每个白色节点开始的就是一个连通分支。</li>
<li>常见算法<ol>
<li>DFS<ol>
<li>原理：访问某个顶点后只有当某个节点是叶结点后才会访问其余相邻节点。</li>
<li>步骤：<ol>
<li>选择一个结点作为起始结点，标记为灰色</li>
<li>从该节点的邻居结点中选择一个结点，标记为灰色，继续这个操作</li>
<li>当选中的结点时叶子结点时，将其涂黑并返回到上一个父节点。</li>
<li>重复2,3直到所有结点都被访问。</li>
</ol>
</li>
</ol>
</li>
<li>BFS   （DFS，BFS不是图的遍历算法吗）。<ol>
<li>原理：在进一步遍历中顶点之前，先访问当前结点的所有邻接结点。</li>
<li>步骤：<ol>
<li>选择一个顶点作为起始节点，放入队列，标记为灰色，其余标记为白色</li>
<li>寻找队列首部结点的所有邻居节点，将其放入队列中并标记为灰色，将队列首部结点出队，并标记为黑色  </li>
<li>重复2步骤，直到队列中的节点全部为空。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="SSSP-single-source-shortest-paths"><a href="#SSSP-single-source-shortest-paths" class="headerlink" title="SSSP (single-source shortest paths)"></a>SSSP (single-source shortest paths)</h3><ol>
<li>单独的起点与目标点之间最短路径的计算。起点固定，寻找与其他所有结点之间的最短路径。包括单源单汇，单源多汇</li>
<li>常见算法<ol>
<li>Dijkstra<ol>
<li>步骤<ol>
<li>将所有顶点分成两个集合A、B，其中集合A表示已经求得从V0出发的最短路径的顶点集合，集合B为为待求解的顶点集合。初始时有A={V0}</li>
<li>将集合A与集合B相连的边（A中的所有结点与B中所有的结点形成的边）按照从V0出发的最短权重和递增次序排序，取最短的边，将该条边在集合B中所对应的顶点加入到集合A中</li>
<li>重复第二步，直至B为空集。</li>
</ol>
</li>
<li>总结：<ol>
<li>最短中的最短：每次迭代时比较的是当前状态下以V0为起点，A中顶点为中间点的到各顶点之间的最短路径权重，最后再选择在当前所有最短路径中路径最短的一个顶点加入A。也就是说每次加入A集合的点是最短路径中的最短。</li>
<li>给定目标点，在每次迭代时，并不知道能否到达最后的目标点，所以把到所有结点的最短距离都算出来了。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="Betweenness-Centrality（中介中心性）"><a href="#Betweenness-Centrality（中介中心性）" class="headerlink" title="Betweenness Centrality（中介中心性）"></a>Betweenness Centrality（中介中心性）</h3><ol>
<li><p>定义 ：中心性用来衡量节结点的重要性。Betweenness Centrality ：考虑的是该节点出现在其他两节点之间的最短路径上的比率。</p>
</li>
<li><p>思想：如果一个成员位于其他成员的多条最短路上，那么该成员就是核心成员，就具有较大的中介中心性。</p>
</li>
<li><p>步骤</p>
<p>其中<img src="https://i2.wp.com/upload.wikimedia.org/math/b/b/7/bb79bd91213d03edf0c8fc04fbd51085.png" alt="\sigma_{st}">表示的是节点s和t之间的最短路径的数量，而<img src="https://i2.wp.com/upload.wikimedia.org/math/4/2/c/42c33f5f78864175f0d9c9af1c492f5d.png" alt="\sigma_{st}(v)">是最短路径中经过节点v的数量。</p>
<ol>
<li><p>计算各个点对之间最短路径的长度和条数，用于计算pair-dependencies: δst(v) =σst(v)/σst</p>
<p><img src="http://static.oschina.net/uploads/img/201305/11121047_IQnh.jpg" alt="clip_image004"></p>
</li>
<li><p>对于每个节点，累积属于自己的pair-dependencies</p>
</li>
</ol>
<p><img src="https://i2.wp.com/upload.wikimedia.org/math/4/c/c/4cc6eaa2dce9d504feeed5bd88b96d73.png" alt=""></p>
</li>
</ol>
<h3 id="LBP算法-Local-Binary-Pattern-局部二值模式"><a href="#LBP算法-Local-Binary-Pattern-局部二值模式" class="headerlink" title="LBP算法(Local Binary Pattern, 局部二值模式)"></a>LBP算法(Local Binary Pattern, 局部二值模式)</h3><ol>
<li><p>定义：LBP是一种用来描述图像局部纹理特征的算子。</p>
<ol>
<li>原始的LBP算子定义为在3*3的窗口内，以窗口中心像素为阈值，将相邻的8个像素的灰度值与其进行比较，若周围像素值大于中心像素值，则该像素点的位置被标记为1，否则为0</li>
</ol>
<p><img src="http://hi.csdn.net/attachment/201104/13/0_1302700245WllL.gif" alt="img"></p>
</li>
<li><p>作用是进行特征提取，而且，提取的特征是图像的纹理特征，并且，是局部的纹理特征.</p>
</li>
<li><p>改进版本</p>
<ol>
<li>原型LBP算子 </li>
<li>LBP等价模式</li>
</ol>
</li>
</ol>
<h3 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h3><ol>
<li>定义：无环连通图，图中所有结点均参与，所有边的权重加起来最小。</li>
<li>算法<ol>
<li>Prim算法  <ol>
<li>步骤：设N=(V,{E})是连通网， TE是N上最小生成树中边的集合 <ol>
<li>初始令U={u0},(u0V), TE=φ</li>
<li>在所有uU,vV-U的边(u,v)E中，找一条代价最小<br>的边(u0,v0), 并保证不形成回路 </li>
<li>将(u0,v0)并入集合TE，同时v0并入U </li>
<li>重复上述操作直至U=V为止，则T=(V,{TE})为N的<br>最小生成树  </li>
</ol>
</li>
<li>总结：每次迭代加入所有连通边中权值最小的。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="三角计数"><a href="#三角计数" class="headerlink" title="三角计数"></a>三角计数</h3><ol>
<li>定义：寻找无向图中的所有三角形</li>
<li>步骤<ol>
<li>建立邻接表：<ol>
<li>如果A-B &amp; A &lt; B，则将B加入A的邻接表 如果A-B &amp; B &lt; A，则将A加入B的邻接表  A&lt;B比较的是id</li>
</ol>
</li>
<li>遍历每个节点，对于结点A，遍历A邻接表中的结点，如果邻接结点B,C两两之间存在边，则A、B、C三者之间存在三角形</li>
</ol>
</li>
</ol>
<h3 id="社区发现"><a href="#社区发现" class="headerlink" title="社区发现"></a>社区发现</h3><ol>
<li><p>社区定义：同一社区内的节点与节点之间的连接很紧密，而社区与社区之间的连接比较稀疏。社区是一个子图</p>
</li>
<li><p>数学描述：<img src="https://img-blog.csdn.net/20130710080910046" alt=""></p>
</li>
<li><p>衡量标准：模块度</p>
<ol>
<li>计算公式</li>
</ol>
<p><img src="https://img-blog.csdn.net/20130710081032203" alt=""></p>
</li>
<li><p>常见算法</p>
<ol>
<li>GN算法<ol>
<li>思想：在一个网络之中，通过社区内部的边的最短路径相对较少，而通过社区之间的边的最短路径的数目则相对较多。从社区内部走大概率会走很多条边。</li>
<li>步骤<ol>
<li>计算每一条边的边介数。边介数（betweenness）：网络中任意两个节点通过此边的最短路径的数目。</li>
<li>删除边介数最大的边</li>
<li>重复（1）（2），直到网络中的任一顶点作为一个社区为止。</li>
</ol>
</li>
<li>缺陷<ol>
<li>不知道最后会有多少个社区</li>
<li>在计算边介数的时候可能会有很对重复计算最短路径的情况，时间复杂度太高</li>
<li>GN算法不能判断算法终止位置</li>
</ol>
</li>
</ol>
</li>
<li>LPA算法（标签传播算法）<ol>
<li>思路<ol>
<li>自己是什么标签，由邻居决定。邻居中什么标签最多，则此结点是什么标签</li>
</ol>
</li>
<li>步骤<ol>
<li>为所有结点指定一个唯一的标签</li>
<li>逐轮刷新所有结点的标签，直到达到收敛要求位置。刷新规则： 对于某一个节点，考察其所有邻居节点的标签，并进行统计，将出现个数最多的那个标签赋给当前节点。当个数最多的标签不唯一时，随机选一个。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><ol>
<li>定义 ：<strong>拓扑排序（Topological Sorting）</strong>是一个<strong>有向无环图（DAG, Directed Acyclic Graph）</strong>的所有顶点的线性序列。且该序列必须满足下面两个条件：<ol>
<li>每个顶点出现且只出现一次</li>
<li>若存在一条从顶点 A 到顶点 B 的路径，那么在序列中顶点 A 出现在顶点 B 的前面</li>
</ol>
</li>
<li>步骤<ol>
<li>从 DAG 图中选择一个 没有前驱（即入度为0）的顶点并输出</li>
<li>从图中删除该顶点和所有以它为起点的有向边</li>
<li>重复 1 和 2 直到当前的 DAG 图为空或<strong>当前图中不存在无前驱的顶点为止</strong>。后一种情况说明有向图中必然存在环<br><img src="http://img.blog.csdn.net/20150507001759702" alt="img"></li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>graph</tag>
      </tags>
  </entry>
  <entry>
    <title>ceph 部署文档</title>
    <url>/ceph%E9%83%A8%E7%BD%B2%E6%96%87%E6%A1%A3.html</url>
    <content><![CDATA[<h1 id="ceph-部署文档"><a href="#ceph-部署文档" class="headerlink" title="ceph 部署文档"></a>ceph 部署文档</h1><a id="more"></a>
<hr>
<h1 id="1-配置所有节点"><a href="#1-配置所有节点" class="headerlink" title="1.配置所有节点"></a>1.配置所有节点</h1><h2 id="创建ceph用户"><a href="#创建ceph用户" class="headerlink" title="创建ceph用户"></a>创建ceph用户</h2><h2 id="安装配置NTP"><a href="#安装配置NTP" class="headerlink" title="安装配置NTP"></a>安装配置NTP</h2><ol>
<li><code>systemctl enable ntp</code>  ubuntu 14.04不可用，感觉已经安装过了，因此跳过。</li>
</ol>
<h2 id="配置hosts文件"><a href="#配置hosts文件" class="headerlink" title="配置hosts文件"></a>配置hosts文件</h2><p><code>172.16.1.93 object1</code><br><code>172.16.1.94 object2</code><br><code>172.16.1.95 object3</code><br><code>172.16.1.66 object4</code><br><code>172.16.1.92 controller</code></p>
<hr>
<h1 id="2-配置ssh服务器"><a href="#2-配置ssh服务器" class="headerlink" title="2. 配置ssh服务器"></a>2. 配置ssh服务器</h1><p>修改ssh的配置文件</p>
<p>Host controller<br>        Hostname gd92<br>        User cephuser<br>Host object1<br>        Hostname gd93<br>        User cephuser<br>Host object2<br>        Hostname hw101<br>        User cephuser<br>Host object3<br>        Hostname gd95<br>        User cephuser<br>Host object4<br>        Hostname gd66<br>        User cephuser</p>
<p>生成密钥并拷贝到4个osd节点上，无需拷贝到controller节点</p>
<hr>
<h1 id="3-安装ceph"><a href="#3-安装ceph" class="headerlink" title="3.安装ceph"></a>3.安装ceph</h1><p>主要参考链接：这些链接的操作大都一致，部分的顺序会有变化。</p>
<p><a href="https://linux.cn/article-8182-1.html#4_10238" target="_blank" rel="noopener">https://linux.cn/article-8182-1.html#4_10238</a></p>
<p><a href="https://blog.csdn.net/styshoo/article/details/55471132" target="_blank" rel="noopener">https://blog.csdn.net/styshoo/article/details/55471132</a></p>
<p><a href="https://blog.csdn.net/styshoo/article/details/58572816" target="_blank" rel="noopener">https://blog.csdn.net/styshoo/article/details/58572816</a></p>
<h2 id="部署监控节点出现的问题"><a href="#部署监控节点出现的问题" class="headerlink" title="部署监控节点出现的问题"></a>部署监控节点出现的问题</h2><p><code>ceph-deploy mon create-initial</code></p>
<ol>
<li><p><code>ceph-mon --cluster ceph --mkfs -i gd92 --keyring /var/lib/ceph/tmp/ceph-gd92.mon.keyring</code></p>
<p>问题：ceph.conf的配置文件中的<code>public network=172.16.1.92/24</code> 掩码前面多打了空格</p>
<p>修改后重新执行命令，并加上<code>--overwrite-conf</code> </p>
</li>
<li><p>[info]Running command: ceph —cluster=ceph —admin-daemon /var/run/ceph/ceph-mon.controller.asok mon_status</p>
<p><code>admin_socket: exception getting command descriptions: [Errno 2] No such file or directory</code></p>
<p>似乎是ceph -deploy 的问题，或者是ubuntu14.04的问题。教程是ubuntu16.04的</p>
<p>此问题非hostname 不对应</p>
<p>非conf 不同步导致。—overwrtie-conf  无作用。</p>
<p>解决办法：按照14.04方法重新安装ceph-deploy</p>
</li>
</ol>
<h2 id="部署osd节点出现的问题"><a href="#部署osd节点出现的问题" class="headerlink" title="部署osd节点出现的问题"></a>部署osd节点出现的问题</h2><ol>
<li>使用<code>ceph-deploy disk list ceph-osd1 ceph-osd2 ceph-osd3</code>检查磁盘可用性时报错，使用<code>ceph-deploy osd prepare ceph-osd1:/dev/sdb ceph-osd2:/dev/sdb ceph-osd3:/dev/sdb</code> 在数据盘上面准备时也报错<br>Running command: fdisk -l  File “/usr/lib/python2.7/distpackages/ceph_deploy/util/decorators.py”, line 69, in newfunc<br>问题：未知<br>解决办法：将osd节点的数据目录放在指定目录，不用整个数据盘</li>
<li>最后部署后集群状况是health -ok，但是4osds，有3个osd up，一个osd down<br>问题：down掉的节点磁盘有问题。<br>解决办法：先卸载磁盘，重新格式化，挂载，重新激活osd节点</li>
</ol>
<h2 id="部署rgw节点出现的问题"><a href="#部署rgw节点出现的问题" class="headerlink" title="部署rgw节点出现的问题"></a>部署rgw节点出现的问题</h2><ol>
<li><p>显示rgw进程在工作，但是使用：<a href="http://controller:7480" target="_blank" rel="noopener">http://controller:7480</a> 显示拒绝连接。并且新建S3账号，测试时未返回正确结果。</p>
<p>问题：未知</p>
<p>尝试方法：重新部署</p>
<p>解决办法：重新部署后最开始将端口设置为80，发现可以创建s3账号，但是无法正确测试，显示创建bucket出错，查看rgw的log，发现端口被占用，无法打开，后面重新设置端口为7480问题解决，测试均正确。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>deploy</category>
      </categories>
      <tags>
        <tag>ceph</tag>
      </tags>
  </entry>
</search>
